
===== main.ts =====

import {
	App,
	Editor,
	MarkdownView,
	Modal,
	Notice,
	Plugin
} from 'obsidian';

import {
	MyPluginSettings,
	DEFAULT_SETTINGS,
	SampleSettingTab
} from './src/settings/settings';

import { SecretsManager } from './utils/secrets';

/**
 * Main Plugin Class
 */
export default class MyPlugin extends Plugin {
	settings: MyPluginSettings;
	secrets: SecretsManager;

	/**
	 * Plugin entry point
	 */
	async onload() {
		console.log('[MyPlugin] Loaded');

		// Load plugin settings
		await this.loadSettings();

		// Initialize SecretsManager
		this.secrets = new SecretsManager(this.app);

		// Example usage
		const openai = this.secrets.getSecret("openai");
		console.log("[MyPlugin] OpenAI Secret:", openai);

		// Add ribbon icon
		const ribbonIconEl = this.addRibbonIcon('dice', 'Sample Plugin', (evt: MouseEvent) => {
			new Notice('This is a notice!');
		});
		ribbonIconEl.addClass('my-plugin-ribbon-class');

		// Add status bar item
		const statusBarItemEl = this.addStatusBarItem();
		statusBarItemEl.setText('Status Bar Text');

		// Simple modal command
		this.addCommand({
			id: 'open-sample-modal-simple',
			name: 'Open sample modal (simple)',
			callback: () => {
				new SampleModal(this.app).open();
			}
		});

		// Editor command
		this.addCommand({
			id: 'sample-editor-command',
			name: 'Sample editor command',
			editorCallback: (editor: Editor, view: MarkdownView) => {
				console.log('[MyPlugin] Selected Text:', editor.getSelection());
				editor.replaceSelection('Sample Editor Command');
			}
		});

		// Complex checkable command
		this.addCommand({
			id: 'open-sample-modal-complex',
			name: 'Open sample modal (complex)',
			checkCallback: (checking: boolean) => {
				const markdownView = this.app.workspace.getActiveViewOfType(MarkdownView);
				if (markdownView) {
					if (!checking) {
						new SampleModal(this.app).open();
					}
					return true;
				}
			}
		});

		// Add settings tab
		this.addSettingTab(new SampleSettingTab(this.app, this));

		// Register global DOM event
		this.registerDomEvent(document, 'click', (evt: MouseEvent) => {
			console.log('[MyPlugin] DOM click', evt);
		});

		// Register interval task
		this.registerInterval(window.setInterval(() => {
			console.log('[MyPlugin] Interval running');
		}, 5 * 60 * 1000));
	}

	/**
	 * Called when plugin is unloaded
	 */
	onunload() {
		console.log('[MyPlugin] Unloaded');
	}

	/**
	 * Load plugin settings
	 */
	async loadSettings() {
		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
	}

	/**
	 * Save plugin settings
	 */
	async saveSettings() {
		await this.saveData(this.settings);
	}
}

/**
 * Basic modal class
 */
class SampleModal extends Modal {
	constructor(app: App) {
		super(app);
	}

	onOpen() {
		const { contentEl } = this;
		contentEl.setText('Woah!');
	}

	onClose() {
		const { contentEl } = this;
		contentEl.empty();
	}
}

===== src/types.ts =====


===== src/ui/PromptModal.ts =====


===== src/settings/settings.ts =====

import { App, PluginSettingTab, Setting, Notice } from 'obsidian';
import type MyPlugin from '../../main';
import { providerFetchers, providerMetadata } from './providers/index';

export interface ProviderConfig {
	apiKey: string;
	model: string;
}

export interface MyPluginSettings {
	defaultProvider: string;
	backupProvider: string;
	providers: Record<string, ProviderConfig>;
}

// Dynamically generate DEFAULT_SETTINGS.providers from providerMetadata
export const DEFAULT_SETTINGS: MyPluginSettings = {
	defaultProvider: 'openai',
	backupProvider: 'local',
	providers: Object.keys(providerMetadata).reduce((acc, key) => {
		acc[key] = {
			apiKey: '',
			model: providerMetadata[key].defaultModel
		};
		return acc;
	}, {} as Record<string, ProviderConfig>)
};

export class SampleSettingTab extends PluginSettingTab {
	plugin: MyPlugin;
	selectedProviderKey: string;
	availableModels: string[] = [];
	workingProviders: Set<string> = new Set();

	constructor(app: App, plugin: MyPlugin) {
		super(app, plugin);
		this.plugin = plugin;
		this.selectedProviderKey = plugin.settings.defaultProvider || Object.keys(providerMetadata)[0];
		this.ensureProviderConfigExists(this.selectedProviderKey);
	}

	ensureProviderConfigExists(providerKey: string): ProviderConfig | undefined {
		if (!this.plugin.settings.providers[providerKey] && providerMetadata[providerKey]) {
			this.plugin.settings.providers[providerKey] = {
				apiKey: '',
				model: providerMetadata[providerKey].defaultModel
			};
			console.log(`Added missing provider configuration for: ${providerKey}`);
		}
		return this.plugin.settings.providers[providerKey];
	}

	display(): void {
		const { containerEl } = this;
		containerEl.empty();

		containerEl.createEl('h2', { text: 'LLM Provider Settings' });

		// Dropdowns for Default/Backup Providers
		const createProviderDropdown = (setting: Setting, settingKey: 'defaultProvider' | 'backupProvider') => {
			setting.addDropdown(dropdown => {
				const validProviders = Object.entries(this.plugin.settings.providers)
					.filter(([id, cfg]) =>
						(id === 'local' || cfg.apiKey) &&
						this.workingProviders.has(id)
					);

				dropdown.addOption('', '--- Select ---');
				if (validProviders.length === 0) {
					dropdown.addOption('', 'No validated providers available');
					dropdown.setDisabled(true);
				} else {
					validProviders.forEach(([id]) => dropdown.addOption(id, id));
					dropdown.setDisabled(false);
				}

				const currentValue = this.plugin.settings[settingKey];
				dropdown.setValue(validProviders.some(([id]) => id === currentValue) ? currentValue : '');

				dropdown.onChange(async value => {
					if (value === '') {
						new Notice(`Cleared ${settingKey === 'defaultProvider' ? 'Default' : 'Backup'} Provider.`);
					} else {
						new Notice(`${settingKey === 'defaultProvider' ? 'Default' : 'Backup'} provider set to ${value}`);
					}
					this.plugin.settings[settingKey] = value;
					await this.plugin.saveSettings();
				});
			});
		};

		const defaultProviderSetting = new Setting(containerEl)
			.setName('Default Provider')
			.setDesc('Primary provider (must be validated).');
		createProviderDropdown(defaultProviderSetting, 'defaultProvider');

		const backupProviderSetting = new Setting(containerEl)
			.setName('Backup Provider')
			.setDesc('Used if the default provider fails (must be validated).');
		createProviderDropdown(backupProviderSetting, 'backupProvider');

		containerEl.createEl('h3', { text: 'Configure Providers' });

		// Provider Selection Dropdown
		new Setting(containerEl)
			.setName('Select Provider to Configure')
			.setDesc('Choose a provider from the list to set its API key and model.')
			.addDropdown(dropdown => {
				Object.keys(providerMetadata).forEach(providerKey =>
					dropdown.addOption(providerKey, providerKey)
				);

				if (!providerMetadata[this.selectedProviderKey]) {
					this.selectedProviderKey = Object.keys(providerMetadata)[0];
				}

				dropdown.setValue(this.selectedProviderKey);

				dropdown.onChange(value => {
					this.selectedProviderKey = value;
					this.availableModels = [];
					this.ensureProviderConfigExists(this.selectedProviderKey);
					this.display();
				});
			});

		if (!this.selectedProviderKey || !providerMetadata[this.selectedProviderKey]) {
			containerEl.createEl('p', { text: 'Invalid provider selected.' });
			return;
		}

		const currentConfig = this.ensureProviderConfigExists(this.selectedProviderKey);
		if (!currentConfig) {
			containerEl.createEl('p', { text: `Configuration for ${this.selectedProviderKey} is missing.` });
			return;
		}

		containerEl.createEl('h4', { text: `Configure: ${this.selectedProviderKey}` });

		// API Key Input + Validation Button
		const apiKeySetting = new Setting(containerEl)
			.setName(`${this.selectedProviderKey} API Key`)
			.setDesc(`API key for ${this.selectedProviderKey}. Required for validation.`);

		if (!providerMetadata[this.selectedProviderKey].requiresApiKey) {
			apiKeySetting.setDesc(`'${this.selectedProviderKey}' provider does not require an API key.`);
		} else {
			apiKeySetting.addText(text => {
				text.setPlaceholder('Enter your API key')
					.setValue(currentConfig.apiKey)
					.onChange(async value => {
						currentConfig.apiKey = value.trim();
						this.workingProviders.delete(this.selectedProviderKey);
						this.availableModels = [];
						await this.plugin.saveSettings();
					});
				text.inputEl.type = 'password';
				text.inputEl.style.width = '300px';
			});
		}

		apiKeySetting.addExtraButton(btn => {
			btn.setIcon('refresh-ccw')
				.setTooltip(`Validate ${this.selectedProviderKey} key & fetch models`)
				.onClick(async () => {
					if (providerMetadata[this.selectedProviderKey].requiresApiKey && !currentConfig.apiKey) {
						new Notice(`API Key required for ${this.selectedProviderKey}`, 5000);
						return;
					}
					new Notice(`Validating ${this.selectedProviderKey}...`);
					btn.setDisabled(true);

					const models = await this.fetchAvailableModels(this.selectedProviderKey, currentConfig.apiKey);

					if (models.length > 0) {
						this.availableModels = models;
						this.workingProviders.add(this.selectedProviderKey);
						new Notice(`${this.selectedProviderKey}: ${models.length} model(s) retrieved. Key validated!`, 5000);
						if (!models.includes(currentConfig.model)) {
							currentConfig.model = models[0];
							new Notice(`Model reset to ${models[0]} as previous was unavailable.`, 3000);
						}
						await this.plugin.saveSettings();
					} else {
						this.availableModels = [];
						this.workingProviders.delete(this.selectedProviderKey);
						new Notice(`${this.selectedProviderKey}: Validation failed. No models found or invalid API key.`, 5000);
					}
					btn.setDisabled(false);
					this.display();
				});

			if (this.workingProviders.has(this.selectedProviderKey)) {
				const statusSpan = btn.extraSettingsEl.createEl("span", { text: " ✅ Valid", cls: "setting-item-description" });
				if (statusSpan instanceof HTMLElement) {
					statusSpan.style.color = "green";
					statusSpan.style.marginLeft = "10px";
				}
			} else if (providerMetadata[this.selectedProviderKey].requiresApiKey && currentConfig.apiKey) {
				const statusSpan = btn.extraSettingsEl.createEl("span", { text: " ❓ Needs Validation", cls: "setting-item-description" });
				if (statusSpan instanceof HTMLElement) {
					statusSpan.style.color = "orange";
					statusSpan.style.marginLeft = "10px";
				}
			} else if (!providerMetadata[this.selectedProviderKey].requiresApiKey) {
				this.workingProviders.add(this.selectedProviderKey);
				const statusSpan = btn.extraSettingsEl.createEl("span", { text: " (N/A)", cls: "setting-item-description" });
				if (statusSpan instanceof HTMLElement) {
					statusSpan.style.color = "grey";
					statusSpan.style.marginLeft = "10px";
				}
			}
		});

		// Model Selection Dropdown
		const modelSetting = new Setting(containerEl)
			.setName(`${this.selectedProviderKey} Model`)
			.setDesc(`Select the model to use for ${this.selectedProviderKey}.`);

		modelSetting.addDropdown(dropdown => {
			const modelOptions = this.availableModels.length > 0
				? this.availableModels
				: (currentConfig.model ? [currentConfig.model] : [providerMetadata[this.selectedProviderKey].defaultModel]);

			if (modelOptions.length === 0 || (modelOptions.length === 1 && !modelOptions[0])) {
				dropdown.addOption('', 'No models available');
				dropdown.setDisabled(true);
			} else {
				modelOptions.forEach(m => dropdown.addOption(m, m));
				dropdown.setDisabled(false);
			}

			const currentModel = currentConfig.model;
			dropdown.setValue(modelOptions.includes(currentModel) ? currentModel : modelOptions[0] || '');

			dropdown.onChange(async value => {
				currentConfig.model = value;
				await this.plugin.saveSettings();
				new Notice(`${this.selectedProviderKey} model set to ${value}`);
			});
		});

		if (this.availableModels.length > 1) {
			containerEl.createEl('h5', { text: 'Available Models (fetched):' });
			const listEl = containerEl.createEl('ul', { cls: 'provider-model-list' });
			this.availableModels.forEach(model => {
				listEl.createEl('li', { text: model });
			});
		}

		if (this.plugin.settings.providers[this.selectedProviderKey]) {
			new Setting(containerEl)
				.setName(`Remove ${this.selectedProviderKey} Configuration`)
				.setDesc(`This will remove the API key and model selection for ${this.selectedProviderKey}. It can be re-configured later.`)
				.addButton(btn => {
					btn.setButtonText('Remove')
						.setIcon('trash')
						.setWarning()
						.onClick(async () => {
							const providerToDelete = this.selectedProviderKey;
							const wasDefault = this.plugin.settings.defaultProvider === providerToDelete;
							const wasBackup = this.plugin.settings.backupProvider === providerToDelete;

							delete this.plugin.settings.providers[providerToDelete];
							this.workingProviders.delete(providerToDelete);
							this.availableModels = [];

							if (wasDefault) this.plugin.settings.defaultProvider = '';
							if (wasBackup) this.plugin.settings.backupProvider = '';

							this.selectedProviderKey = Object.keys(this.plugin.settings.providers)[0]
								|| Object.keys(providerMetadata)[0];
							this.ensureProviderConfigExists(this.selectedProviderKey);

							await this.plugin.saveSettings();
							new Notice(`${providerToDelete} configuration removed.`);
							this.display();
						});
				});
		}
	}

	async fetchAvailableModels(providerKey: string, apiKey: string): Promise<string[]> {
		const fetcher = providerFetchers[providerKey];
		if (!fetcher) {
			new Notice(`Model fetching not implemented for provider: ${providerKey}`);
			return [];
		}
		try {
			const models = await fetcher(apiKey, this.plugin.app);
			return models;
		} catch (err) {
			console.error(`[${providerKey}] Model fetch error:`, err);
			new Notice(`Error fetching models for ${providerKey}: ${err.message}`, 5000);
			return [];
		}
	}
}
===== src/settings/providers/anthropic.ts =====

import { requestUrl } from 'obsidian';

// Define response types based on Anthropic API documentation
interface AnthropicModel {
    id: string;
    created_at: string;
    display_name: string;
    type: string;
}

interface AnthropicAPIResponse {
    data: AnthropicModel[];
    first_id: string | null;
    last_id: string | null;
    has_more: boolean;
}

export async function fetchAnthropicModels(apiKey: string): Promise<string[]> {
    const models: string[] = [];
    let afterId: string | null = null;
    const apiVersion = '2024-10-22'; // Updated to a safer version; adjust based on Anthropic docs
    const limit = 20; // Default limit per documentation

    try {
        do {
            const url = new URL('https://api.anthropic.com/v1/models');
            url.searchParams.append('limit', limit.toString());
            if (afterId) {
                url.searchParams.append('after_id', afterId);
            }

            console.log('[Anthropic] Sending request:', {
                url: url.toString(),
                headers: { 'x-api-key': '[REDACTED]', 'anthropic-version': apiVersion }
            });

            const response = await requestUrl({
                url: url.toString(),
                method: 'GET',
                headers: {
                    'x-api-key': apiKey.trim(),
                    'anthropic-version': apiVersion
                    // Removed Content-Type for GET request
                }
            });

            if (response.status >= 400) {
                let errorMessage = `Anthropic error: ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log('[Anthropic] Error response body:', errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 400) {
                        errorMessage += '. Check the anthropic-version or query parameters.';
                    } else if (response.status === 401) {
                        errorMessage += '. Verify your API key in the Anthropic Console (https://console.anthropic.com).';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const data = response.json as AnthropicAPIResponse;
            const modelIds = data.data?.map(m => m.id).sort() ?? [];
            models.push(...modelIds);
            afterId = data.has_more ? data.last_id : null;

            console.log('[Anthropic] Fetched models:', modelIds, 'Has more:', data.has_more);
        } while (afterId);

        return models;
    } catch (error) {
        console.error('[Anthropic] Model fetch error:', error);
        throw error;
    }
}
===== src/settings/providers/openai.ts =====

import { requestUrl } from 'obsidian';

export async function fetchOpenAIModels(apiKey: string): Promise<string[]> {
	try {
		const url = 'https://api.openai.com/v1/models';
		const response = await requestUrl({
			url,
			method: 'GET',
			headers: { Authorization: `Bearer ${apiKey}` }
		});

		if (response.status >= 400) {
			throw new Error(`OpenAI error: ${response.status} ${response.text}`);
		}
		return response.json.data?.map((m: any) => m.id).sort() ?? [];
	} catch (err) {
		console.error('[OpenAI] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/groq.ts =====

import { requestUrl } from 'obsidian';

export async function fetchGroqModels(apiKey: string): Promise<string[]> {
	try {
		const url = 'https://api.groq.com/openai/v1/models';
		const response = await requestUrl({
			url,
			method: 'GET',
			headers: { Authorization: `Bearer ${apiKey}` }
		});

		if (response.status >= 400) {
			throw new Error(`Groq error: ${response.status} ${response.text}`);
		}
		return response.json.data?.map((m: any) => m.id).sort() ?? [];
	} catch (err) {
		console.error('[Groq] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/gemini.ts =====

import { requestUrl } from 'obsidian';

export async function fetchGeminiModels(apiKey: string): Promise<string[]> {
	try {
		const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`;
		const response = await requestUrl({ url, method: 'GET' });

		if (response.status >= 400) {
			throw new Error(`Gemini error: ${response.status} ${response.text}`);
		}
		return response.json.models?.map((m: any) => m.name).sort() ?? [];
	} catch (err) {
		console.error('[Gemini] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/grok.ts =====

import { requestUrl } from 'obsidian';

interface XAIModel {
    id: string;
    created: number;
    object: string;
    owned_by: string;
}

interface XAIAPIResponse {
    data: XAIModel[];
}

export async function fetchGrokModels(apiKey: string): Promise<string[]> {
    try {
        const url = 'https://api.x.ai/v1/models';
        console.log('[Grok] Sending request:', {
            url,
            headers: { Authorization: `Bearer ${apiKey.trim()}` }
        });

        const response = await requestUrl({
            url,
            method: 'GET',
            headers: {
                Authorization: `Bearer ${apiKey.trim()}`,
                'Content-Type': 'application/json' // Added for compatibility
            }
        });

        if (response.status >= 400) {
            let errorMessage = `xAI error: ${response.status}`;
            try {
                const errorBody = response.json?.error?.message || response.text || 'No additional details';
                console.log('[Grok] Error response body:', errorBody);
                errorMessage += ` - ${errorBody}`;
                if (response.status === 403) {
                    errorMessage += '. Check your API key, permissions, or account status at console.x.ai.';
                }
            } catch {
                errorMessage += ' - Failed to parse error details';
            }
            throw new Error(errorMessage);
        }

        const models = (response.json as XAIAPIResponse).data?.map(m => m.id).sort() ?? [];
        console.log('[Grok] Fetched models:', models);
        return models;
    } catch (err) {
        console.error('[Grok] Model fetch error:', err);
        throw err;
    }
}
===== src/settings/providers/local.ts =====

import { requestUrl } from 'obsidian';

export async function fetchLocalModels(): Promise<string[]> {
	try {
		// Check if Ollama is running
		await requestUrl({ url: 'http://localhost:11434', method: 'GET' });
		const response = await requestUrl({ url: 'http://localhost:11434/api/tags', method: 'GET' });
		return response.json.models?.map((m: any) => m.name).sort() ?? [];
	} catch (err) {
		console.error('[Local] Model fetch error:', err);
		throw new Error("Unable to connect to Ollama at http://localhost:11434");
	}
}
===== src/settings/providers/openrouter.ts =====

import { requestUrl } from 'obsidian';

export async function fetchOpenRouterModels(apiKey: string): Promise<string[]> {
	try {
		const url = 'https://openrouter.ai/api/v1/models';
		const response = await requestUrl({
			url,
			method: 'GET',
			headers: { Authorization: `Bearer ${apiKey}` }
		});

		if (response.status >= 400) {
			throw new Error(`OpenRouter error: ${response.status} ${response.text}`);
		}
		return response.json.data?.map((m: any) => m.id).sort() ?? [];
	} catch (err) {
		console.error('[OpenRouter] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/index.ts =====

import { App } from 'obsidian';
import { fetchOpenAIModels } from './openai';
import { fetchLocalModels } from './local';
import { fetchAnthropicModels } from './anthropic';
import { fetchGroqModels } from './groq';
import { fetchGeminiModels } from './gemini';
import { fetchOpenRouterModels } from './openrouter';
import { fetchGrokModels } from './grok';

export interface ProviderMetadata {
	key: string;
	defaultModel: string;
	requiresApiKey: boolean;
}

export const providerMetadata: Record<string, ProviderMetadata> = {
	openai: { key: 'openai', defaultModel: 'gpt-3.5-turbo', requiresApiKey: true },
	local: { key: 'local', defaultModel: 'llama2', requiresApiKey: false },
	anthropic: { key: 'anthropic', defaultModel: 'claude-3-opus-20240229', requiresApiKey: true },
	groq: { key: 'groq', defaultModel: 'mixtral-8x7b-32768', requiresApiKey: true },
	gemini: { key: 'gemini', defaultModel: 'models/gemini-pro', requiresApiKey: true },
	openrouter: { key: 'openrouter', defaultModel: 'openrouter/google/gemma-7b-it', requiresApiKey: true },
	grok: { key: 'grok', defaultModel: 'grok-3-beta', requiresApiKey: true }
};

type FetchFunction = (apiKey: string, app: App) => Promise<string[]>;

export const providerFetchers: Record<string, FetchFunction> = {
  openai: fetchOpenAIModels,
  local: fetchLocalModels,
  anthropic: fetchAnthropicModels,
  groq: fetchGroqModels,
  gemini: fetchGeminiModels,
  openrouter: fetchOpenRouterModels,
  grok: fetchGrokModels
};

===== src/gateway/LLMAdapter.ts =====


===== src/gateway/Gateway.ts =====

