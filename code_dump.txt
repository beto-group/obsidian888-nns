
===== main.ts =====

import {
    App,
    Editor,
    MarkdownView,
    Modal,
    Notice,
    Plugin
} from 'obsidian';

import { SampleSettingTab } from './src/settings/settings';
import { DEFAULT_SETTINGS } from './src/settings/defaults';
import { MyPluginSettings } from './src/settings/types';
import { SecretsManager } from './src/utils/secrets';
import { AiConsoleModal } from './src/ui/console/AiConsoleModal';
import { registerAiNNS, unregisterAiNNS } from './src/api/aiNNS';

/**
 * Main Plugin Class
 */
export default class MyPlugin extends Plugin {
    settings: MyPluginSettings;
    secrets: SecretsManager;

    /**
     * Plugin entry point
     */
    async onload() {
        console.log('[MyPlugin] Loading plugin...');

        // Initialize SecretsManager and wait for it to load secrets from file
        this.secrets = new SecretsManager(this.app);
        await this.secrets.initialize();

        // Log stored secrets for debugging
        try {
            const storedSecrets = await this.secrets.listSecrets();
            console.log('[MyPlugin] Stored secret keys on load:', storedSecrets);
        } catch (error) {
            console.error("[MyPlugin] Error listing secrets on load:", error);
        }

        // Load plugin settings
        await this.loadSettings();

        // Example usage: Try to get a secret
        try {
            const openai = await this.secrets.getSecret("openai");
            if (openai) {
                console.log("[MyPlugin] Found OpenAI Secret on load (length):", openai.length);
            }
        } catch (error) {
            console.error("[MyPlugin] Error getting OpenAI secret on load:", error);
        }

        // Register aiNNS API on global scope
        try {
            await registerAiNNS(this.app, this.secrets, this.settings);
            console.log('[MyPlugin] aiNNS API registered successfully.');
        } catch (error) {
            console.error('[MyPlugin] Error registering aiNNS API:', error);
        }

        // --- UI and Commands ---

        // Add ribbon icon (opens AI Console)
        const ribbonIconEl = this.addRibbonIcon('rocket', 'Open AI Console', (evt: MouseEvent) => {
            try {
                new AiConsoleModal(this.app, this.settings, this.secrets).open();
            } catch (error) {
                console.error('[MyPlugin] Error opening AiConsoleModal from ribbon:', error);
                new Notice('Failed to open AI Console Modal.');
            }
        });
        ribbonIconEl.addClass('my-plugin-ribbon-class');

        // Add status bar item
        const statusBarItemEl = this.addStatusBarItem();
        statusBarItemEl.setText('Status Bar Text');

        // Simple modal command
        this.addCommand({
            id: 'open-sample-modal-simple',
            name: 'Open sample modal (simple)',
            callback: () => {
                new SampleModal(this.app).open();
            }
        });

        // Editor command
        this.addCommand({
            id: 'sample-editor-command',
            name: 'Sample editor command',
            editorCallback: (editor: Editor, view: MarkdownView) => {
                console.log('[MyPlugin] Selected Text:', editor.getSelection());
                editor.replaceSelection('Sample Editor Command');
            }
        });

        // Complex checkable command
        this.addCommand({
            id: 'open-sample-modal-complex',
            name: 'Open sample modal (complex)',
            checkCallback: (checking: boolean) => {
                const markdownView = this.app.workspace.getActiveViewOfType(MarkdownView);
                if (markdownView) {
                    if (!checking) {
                        new SampleModal(this.app).open();
                    }
                    return true;
                }
                return false;
            }
        });

        // Add command to open AiConsoleModal
        this.addCommand({
            id: 'open-ai-console-modal',
            name: 'Open AI Console Modal',
            callback: () => {
                try {
                    new AiConsoleModal(this.app, this.settings, this.secrets).open();
                } catch (error) {
                    console.error('[MyPlugin] Error opening AiConsoleModal:', error);
                    new Notice('Failed to open AI Console Modal.');
                }
            }
        });

        // Add settings tab
        this.addSettingTab(new SampleSettingTab(this.app, this, this.secrets));

        // Register global DOM event
        this.registerDomEvent(document, 'click', (evt: MouseEvent) => {
            // console.log('[MyPlugin] DOM click', evt);
        });

        // Register interval task
        this.registerInterval(window.setInterval(() => {
            // console.log('[MyPlugin] Interval running');
        }, 5 * 60 * 1000));

        console.log('[MyPlugin] Plugin loaded successfully.');
    }

    /**
     * Called when plugin is unloaded
     */
    onunload() {
        console.log('[MyPlugin] Unloaded');
        // Unregister aiNNS API to clean up global scope
        unregisterAiNNS();
    }

    /**
     * Load plugin settings
     */
    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    /**
     * Save plugin settings
     */
    async saveSettings() {
        await this.saveData(this.settings);
    }
}

/**
 * Basic modal class
 */
class SampleModal extends Modal {
    constructor(app: App) {
        super(app);
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.setText('Woah!');
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

===== src/types.ts =====


===== src/ui/components/TabComponent.ts =====

import { App, setIcon } from 'obsidian';
import { consoleCSS } from '../console/styles/consoleStyles';

/**
 * Interface for a tab in the TabComponent.
 */
export interface Tab {
  id: string;
  name: string;
  render(container: HTMLElement): void;
  cleanup(): void;
}

/**
 * Configuration for a tab, including its icon.
 */
export interface TabConfig {
  tab: Tab;
  icon: string;
}

/**
 * Reusable TabComponent for managing and rendering tabs.
 */
export class TabComponent {
  private activeTabId: string;
  private container: HTMLElement | null = null;
  private tabContentContainer: HTMLElement | null = null;
  private styleElement: HTMLStyleElement | null = null;

  constructor(
    private app: App,
    private tabs: TabConfig[],
    initialTabId: string
  ) {
    this.activeTabId = tabs.some(t => t.tab.id === initialTabId) ? initialTabId : tabs[0]?.tab.id;
  }

  /**
   * Renders the tab selector and content area into the provided container.
   */
  render(container: HTMLElement): void {
    this.container = container;

    // Inject CSS styles
    this.styleElement = document.createElement('style');
    this.styleElement.textContent = consoleCSS;
    document.head.appendChild(this.styleElement);

    // Create tab selector
    const tabSelector = this.container.createEl('div', { cls: 'ai-console-tab-selector' });

    // Render tab buttons
    this.tabs.forEach(({ tab, icon }) => {
      const isActive = tab.id === this.activeTabId;
      const tabButton = tabSelector.createEl('button', {
        cls: `ai-console-tab-button${isActive ? ' active' : ''}`,
      });
    
      // Use the icon from TabConfig
      const iconEl = tabButton.createEl('span', { cls: 'ai-console-tab-icon' });
      setIcon(iconEl, icon);
    
      // Add label with proper spacing
      tabButton.createSpan({ cls: 'ai-console-tab-label', text: tab.name.split(' ')[0] });
    
      // Handle click
      tabButton.addEventListener('click', () => this.switchTab(tab.id));
    });

    // Create content container
    this.tabContentContainer = this.container.createEl('div', { cls: 'ai-console-tab-content' });

    // Render initial active tab
    this.renderActiveTab();
  }

  /**
Interp   * Switches to the specified tab and re-renders the content.
   */
  private switchTab(tabId: string): void {
    if (tabId === this.activeTabId) return;
    this.activeTabId = tabId;
    this.renderActiveTab();
  }

  /**
   * Renders the content of the active tab and updates button states.
   */
  private renderActiveTab(): void {
    if (!this.container || !this.tabContentContainer) return;

    // Update button states
    const buttons = this.container.querySelectorAll('.ai-console-tab-button');
    const activeTabName = this.tabs.find(t => t.tab.id === this.activeTabId)?.tab.name.split(' ')[0] || '';

    buttons.forEach(button => {
      const buttonLabel = button.querySelector('.ai-console-tab-label')?.textContent || '';
      const isActive = buttonLabel === activeTabName;
      button.classList.toggle('active', isActive);
    });

    // Clear and render active tab content
    this.tabContentContainer.empty();
    const activeTab = this.tabs.find(t => t.tab.id === this.activeTabId)?.tab;
    if (activeTab) {
      activeTab.render(this.tabContentContainer);
    }
  }

  /**
   * Cleans up the component, including styles and tab content.
   */
  cleanup(): void {
    this.tabs.forEach(({ tab }) => tab.cleanup());
    if (this.container) {
      this.container.empty();
    }
    if (this.styleElement && this.styleElement.parentNode) {
      this.styleElement.parentNode.removeChild(this.styleElement);
    }
    this.container = null;
    this.tabContentContainer = null;
    this.styleElement = null;
  }

  /**
   * Gets the ID of the currently active tab.
   */
  getActiveTabId(): string {
    return this.activeTabId;
  }
}
===== src/ui/console/AiConsoleModal.ts =====

import { App, Modal, Notice } from 'obsidian';
import type { MyPluginSettings } from '../../settings/types';
import type { SecretsManager } from '../../utils/secrets';
import { TextConsoleTab } from './tabs/TextConsoleTab';
import { ImageConsoleTab } from './tabs/ImageConsoleTab';
import { VideoConsoleTab } from './tabs/VideoConsoleTab';
import { AudioConsoleTab } from './tabs/AudioConsoleTab';
import { OcrConsoleTab } from './tabs/OcrConsoleTab';
import { ThreeDConsoleTab } from './tabs/ThreeDConsoleTab';
import { TabComponent, TabConfig } from '../components/TabComponent';

// Common interface for history entries
export interface BaseHistoryEntry {
    provider: string;
    model: string;
    prompt: string;
    timestamp: string;
}

interface PromptHistoryEntry extends BaseHistoryEntry {
    output: string;
}

export interface ImageHistoryEntry extends BaseHistoryEntry {
    imageUrls: string[];
}

type HistoryEntry = PromptHistoryEntry | ImageHistoryEntry;

interface ConsoleTab {
    id: string;
    name: string;
    icon: string;
    render(container: HTMLElement): void;
    cleanup(): void;
    renderHistory?(history: HistoryEntry[]): void;
}

export class AiConsoleModal extends Modal {
    private settings: MyPluginSettings;
    private secrets: SecretsManager;
    private tabs: ConsoleTab[] = [];
    private tabComponent: TabComponent;
    private history: HistoryEntry[] = [];
    private maxHistoryEntries = 10;

    constructor(app: App, settings: MyPluginSettings, secrets: SecretsManager) {
        super(app);
        this.settings = settings;
        this.secrets = secrets;
        this.initializeTabs();
        const tabConfigs: TabConfig[] = this.tabs.map(tab => ({
            tab,
            icon: tab.icon
        }));
        this.tabComponent = new TabComponent(this.app, tabConfigs, 'text');
    }

    private initializeTabs() {
        this.tabs = [
            new TextConsoleTab(this.app, this.settings, this.secrets, this.addToHistory.bind(this), this.renderHistory.bind(this)),
            new ImageConsoleTab(this.app, this.settings, this.secrets, this.addToHistory.bind(this), this.renderHistory.bind(this)),
            new VideoConsoleTab(this.app, this.settings, this.secrets),
            new AudioConsoleTab(this.app, this.settings, this.secrets),
            new OcrConsoleTab(this.app, this.settings, this.secrets),
            new ThreeDConsoleTab(this.app, this.settings, this.secrets)
        ];
    }

    onOpen() {
        console.log('[AiConsoleModal] Opening modal...');
        this.titleEl.setText('AI Console Playground');
        this.contentEl.empty();
        const container = this.contentEl.createEl('div', { cls: 'ai-console-container' });
        this.tabComponent.render(container);
    }

    private addToHistory(entry: HistoryEntry) {
        this.history.unshift(entry);
        if (this.history.length > this.maxHistoryEntries) {
            this.history.pop();
        }
        this.renderHistory();
    }

    public renderHistory() {
        const activeTab = this.tabs.find(tab => tab.id === this.tabComponent.getActiveTabId());
        if (activeTab && activeTab.renderHistory) {
            activeTab.renderHistory(this.history);
        }
    }

    onClose() {
        this.tabComponent.cleanup();
        console.log('[AiConsoleModal] Modal closed.');
    }
}
===== src/ui/console/tabs/ImageConsoleTab.ts =====

// src/ui/console/tabs/ImageConsoleTab.ts
import { App, Notice, Setting } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';
import { ImageGateway } from '../../../gateways/ImageGateway';
import { ProviderSelector } from '../sections/ProviderSelector';
import { PromptInput } from '../sections/PromptInput';
import { PromptHistory } from '../sections/PromptHistory';

interface ImageHistoryEntry {
  provider: string;
  model: string;
  prompt: string;
  imageUrls: string[];
  timestamp: string;
  size?: string;
  quality?: string;
  output_format?: string;
}

export class ImageConsoleTab {
  id = 'image';
  name = 'Image Playground';
  icon = 'image';

  private imageGateway?: ImageGateway;
  private providerSelector: ProviderSelector;
  private promptInput: PromptInput;
  private promptHistory: PromptHistory;
  private history: ImageHistoryEntry[] = [];
  private validProviders = ['openai', 'stabilityai', 'grok'];
  private blobUrls: string[] = [];

  private sizeDropdown?: HTMLSelectElement;
  private nImagesInput?: HTMLInputElement;
  private qualityDropdown?: HTMLSelectElement;
  private outputFormatDropdown?: HTMLSelectElement;
  private outputArea?: HTMLElement;

  private providerModels: Record<string, string[]> = {
    openai: ['dall-e-3', 'dall-e-2', 'gpt-image-1'],
    stabilityai: ['stable-diffusion'],
    grok: ['grok-image'],
  };

  private defaultModels: Record<string, string> = {
    openai: 'dall-e-3',
    stabilityai: 'stable-diffusion',
    grok: 'grok-image',
  };

  private modelSizes: Record<string, string[]> = {
    'dall-e-3': ['1024x1024', '1792x1024', '1024x1792'],
    'dall-e-2': ['256x256', '512x512', '1024x1024'],
    'gpt-image-1': ['1024x1024', '1536x1024', '1024x1536'],
    'stable-diffusion': ['512x512', '1024x1024'],
    'grok-image': ['1024x1024'],
  };

  private maxN: Record<string, number> = {
    'dall-e-3': 1,
    'dall-e-2': 10,
    'gpt-image-1': 10,
    'stable-diffusion': 4,
    'grok-image': 1,
  };

  private modelQualities: Record<string, string[]> = {
    'dall-e-3': ['standard', 'hd'],
    'dall-e-2': [],
    'gpt-image-1': ['low', 'medium', 'high', 'auto'],
    'stable-diffusion': [],
    'grok-image': [],
  };

  private outputFormats: string[] = ['png', 'jpeg', 'webp'];

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager,
    private addToHistory?: (entry: ImageHistoryEntry) => void,
    private updateHistoryCallback?: () => void
  ) {
    this.providerSelector = new ProviderSelector(app, settings, secrets, this.validProviders, this.providerModels);
    this.promptInput = new PromptInput();
    this.promptHistory = new PromptHistory();
  }

  async render(container: HTMLElement) {
    console.log('[ImageConsoleTab] Rendering...');

    try {
      this.imageGateway = await ImageGateway.create(this.secrets, this.settings);
      console.log('[ImageGateway] ImageGateway initialized successfully.');
    } catch (error: any) {
      console.error('[ImageConsoleTab] Failed to initialize ImageGateway:', error);
      new Notice('Failed to initialize Image Console.');
      container.createEl('p', { text: 'Error initializing Image Console.' });
      return;
    }

    container.style.display = 'flex';
    container.style.flexDirection = 'column';

    const fixedSection = container.createEl('div', { cls: 'ai-console-fixed-section' });

    await this.providerSelector.render(fixedSection);

    if (!this.providerSelector.getSelectedProvider()) {
      new Notice('No providers available. Please configure API keys.');
      return;
    }

    const updateUI = () => {
      const provider = this.providerSelector.getSelectedProvider();
      const model = this.providerSelector.getSelectedModel() || this.defaultModels[provider] || 'dall-e-3';

      console.log('[ImageConsoleTab] updateUI called - Provider:', provider, 'Model:', model);

      // Update size dropdown
      if (this.sizeDropdown) {
        const currentSize = this.sizeDropdown.value || '';
        console.log('[ImageConsoleTab] Current size:', currentSize);
        this.sizeDropdown.innerHTML = '';
        const sizes = this.modelSizes[model] || ['1024x1024'];
        sizes.forEach(size => this.sizeDropdown!.add(new Option(size, size)));
        this.sizeDropdown.value = sizes.includes(currentSize) ? currentSize : sizes[0];
        console.log('[ImageConsoleTab] Updated size dropdown:', this.sizeDropdown.value);
      } else {
        console.warn('[ImageConsoleTab] sizeDropdown is undefined');
      }

      // Update max n
      if (this.nImagesInput) {
        const max = this.maxN[model] || 1;
        this.nImagesInput.max = max.toString();
        const currentN = parseInt(this.nImagesInput.value) || 1;
        if (currentN > max) {
          this.nImagesInput.value = max.toString();
        }
        console.log('[ImageConsoleTab] Updated n input: max=', max, 'value=', this.nImagesInput.value);
      } else {
        console.warn('[ImageConsoleTab] nImagesInput is undefined');
      }

      // Update quality dropdown
      if (this.qualityDropdown?.parentElement?.parentElement) {
        const qualitySetting = this.qualityDropdown.parentElement.parentElement as HTMLElement;
        const qualities = this.modelQualities[model] || [];
        console.log('[ImageConsoleTab] Qualities for model:', model, qualities);
        if (qualities.length === 0) {
          qualitySetting.style.display = 'none';
          console.log('[ImageConsoleTab] Quality dropdown hidden');
        } else {
          qualitySetting.style.display = 'block';
          const currentQuality = this.qualityDropdown.value || '';
          this.qualityDropdown.innerHTML = '';
          qualities.forEach(q => this.qualityDropdown!.add(new Option(q.charAt(0).toUpperCase() + q.slice(1), q)));
          this.qualityDropdown.value = qualities.includes(currentQuality) ? currentQuality : qualities[0];
          console.log('[ImageConsoleTab] Updated quality dropdown:', this.qualityDropdown.value);
        }
      } else {
        console.warn('[ImageConsoleTab] qualityDropdown or its parent is undefined');
      }

      // Update output format dropdown
      if (this.outputFormatDropdown?.parentElement?.parentElement) {
        const outputFormatSetting = this.outputFormatDropdown.parentElement.parentElement as HTMLElement;
        if (model === 'gpt-image-1') {
          outputFormatSetting.style.display = 'block';
          const currentFormat = this.outputFormatDropdown.value || '';
          this.outputFormatDropdown.innerHTML = '';
          this.outputFormats.forEach(f => this.outputFormatDropdown!.add(new Option(f.toUpperCase(), f)));
          this.outputFormatDropdown.value = this.outputFormats.includes(currentFormat) ? currentFormat : 'png';
          console.log('[ImageConsoleTab] Updated output format dropdown:', this.outputFormatDropdown.value);
        } else {
          outputFormatSetting.style.display = 'none';
          console.log('[ImageConsoleTab] Output format dropdown hidden');
        }
      } else {
        console.warn('[ImageConsoleTab] outputFormatDropdown or its parent is undefined');
      }
    };

    // Trigger updateUI on provider change
    this.providerSelector.onProviderChange((provider: string) => {
      console.log('[ImageConsoleTab] Provider changed to:', provider);
      updateUI();
    });

    // Trigger updateUI on model change
    this.providerSelector.onModelChange((model: string) => {
      console.log('[ImageConsoleTab] Model changed to:', model);
      updateUI();
    });

    const promptRow = fixedSection.createEl('div', { cls: 'ai-console-prompt-section-full' });
    this.promptInput.render(promptRow, () => {});
    const promptTextarea = promptRow.querySelector('textarea');
    if (promptTextarea?.nextElementSibling?.tagName === 'BUTTON') {
      promptTextarea.nextElementSibling.remove();
    }

    const controlsRow = fixedSection.createEl('div', { cls: 'ai-console-controls-row' });

    new Setting(controlsRow)
      .setName('Size')
      .addDropdown(dropdown => {
        this.sizeDropdown = dropdown.selectEl;
        console.log('[ImageConsoleTab] sizeDropdown initialized');
      })
      .controlEl.style.flex = '0 0 auto';

    new Setting(controlsRow)
      .setName('N')
      .addText(text => {
        this.nImagesInput = text.inputEl;
        this.nImagesInput.type = 'number';
        this.nImagesInput.min = '1';
        this.nImagesInput.value = '1';
        this.nImagesInput.style.width = '50px';
      })
      .controlEl.style.flex = '0 0 auto';

    new Setting(controlsRow)
      .setName('Quality')
      .addDropdown(dropdown => {
        this.qualityDropdown = dropdown.selectEl;
        console.log('[ImageConsoleTab] qualityDropdown initialized');
      })
      .controlEl.style.flex = '0 0 auto';

    new Setting(controlsRow)
      .setName('Output Format')
      .addDropdown(dropdown => {
        this.outputFormatDropdown = dropdown.selectEl;
        console.log('[ImageConsoleTab] outputFormatDropdown initialized');
      })
      .controlEl.style.flex = '0 0 auto';

    const runButtonRow = fixedSection.createEl('div', { cls: 'ai-console-run-button-row' });
    const runButton = runButtonRow.createEl('button', { text: 'Run', cls: 'ai-console-run-btn' });
    runButton.addEventListener('click', this.runPrompt.bind(this));

    const scrollableSection = container.createEl('div', { cls: 'ai-console-scrollable-section' });

    const outputSection = scrollableSection.createEl('div', { cls: 'ai-console-output-section' });
    outputSection.createEl('h4', { text: 'Generated Images' });
    this.outputArea = outputSection.createEl('div', { cls: 'ai-console-image-grid' });

    this.promptHistory.render(scrollableSection, this.historyClickHandler.bind(this));
    if (this.updateHistoryCallback) {
      this.updateHistoryCallback();
    }

    this.providerSelector.setProvider('openai', this.defaultModels['openai']);

    console.log('[ImageConsoleTab] Performing initial UI update...');
    updateUI();

    const styleEl = container.createEl('style');
    styleEl.textContent = `
      .ai-console-fixed-section {
        flex-shrink: 0;
      }
      .ai-console-scrollable-section {
        flex: 1;
        overflow-y: auto;
        max-height: 300px;
        padding-bottom: 16px;
      }
      .ai-console-image-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 16px;
      }
      .ai-console-controls-row {
        display: flex;
        overflow-x: auto;
        gap: 16px;
        margin-bottom: 8px;
        padding-bottom: 4px;
        white-space: nowrap;
      }
      .ai-console-controls-row::-webkit-scrollbar {
        height: 8px;
      }
      .ai-console-controls-row::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
      }
      .ai-console-controls-row::-webkit-scrollbar-track {
        background: #333;
      }
      .ai-console-run-button-row {
        display: flex;
        justify-content: center;
        margin-bottom: 16px;
      }
      .ai-console-run-btn {
        background-color: #7d57c1;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
      }
      .ai-console-run-btn:hover {
        background-color: #5c3a9e;
      }
    `;
  }

  private async runPrompt() {
    console.log('[ImageConsoleTab] Run button clicked.');

    const provider = this.providerSelector.getSelectedProvider();
    const model = this.providerSelector.getSelectedModel() || this.defaultModels[provider] || 'dall-e-3';
    const prompt = this.promptInput.getPrompt().trim();
    const size = this.sizeDropdown?.value || '1024x1024';
    const n = parseInt(this.nImagesInput?.value || '1', 10) || 1;
    const quality = this.qualityDropdown?.value || (model === 'dall-e-3' ? 'standard' : 'auto');
    const output_format = this.outputFormatDropdown?.value || 'png';

    console.log('[ImageConsoleTab] runPrompt - provider:', provider, 'model:', model, 'prompt:', prompt, 'size:', size, 'n:', n, 'quality:', quality, 'output_format:', output_format);

    if (!prompt) {
      new Notice('Please enter a prompt.');
      return;
    }
    if (!provider) {
      new Notice('Please select a provider.');
      return;
    }
    if (!this.imageGateway) {
      new Notice('ImageGateway not initialized.');
      return;
    }

    if (prompt.length > 1000) {
      new Notice('Prompt is too long. Please shorten it to 1000 characters or less.');
      return;
    }
    if (prompt.toLowerCase().includes('harmful') || prompt.toLowerCase().includes('explicit')) {
      new Notice('Prompt may violate content policies. Please revise.');
      return;
    }

    const request: any = {
      prompt,
      model,
      size,
      n,
    };

    // Model-specific request fields
    if (model === 'gpt-image-1') {
      request.output_format = output_format;
      if (quality && quality !== 'auto') {
        request.quality = quality; // low, medium, high
      }
    } else {
      request.response_format = 'b64_json';
      if (model === 'dall-e-3' && quality) {
        request.quality = quality; // standard or hd
      }
    }

    console.log('[ImageConsoleTab] Generated request:', request);

    const adapter = (this.imageGateway as any).adapters[provider];
    if (!adapter) {
      new Notice(`No adapter found for provider: ${provider}.`);
      console.error('[ImageConsoleTab] No adapter found for provider:', provider);
      return;
    }

    try {
      if (this.outputArea) {
        this.outputArea.empty();
        this.outputArea.setText('Generating...');
      }

      const result = await adapter.generate(request);

      if (this.outputArea) {
        this.outputArea.empty();
        const renderableUrls: string[] = [];
        result.imageUrls.forEach((url: string) => {
          let imgSrc = url;
          try {
            const binary = atob(url);
            const array = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
              array[i] = binary.charCodeAt(i);
            }
            const blob = new Blob([array], { type: `image/${model === 'gpt-image-1' ? output_format : 'png'}` });
            imgSrc = URL.createObjectURL(blob);
            this.blobUrls.push(imgSrc);
          } catch (e) {
            console.error('[ImageConsoleTab] Failed to decode base64:', e);
            return;
          }
          renderableUrls.push(imgSrc);
          const img = this.outputArea!.createEl('img', {
            attr: { src: imgSrc, style: 'max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);' },
          });
          img.onerror = () => {
            img.remove();
            this.outputArea!.createEl('p', { text: 'Failed to load image.' });
            if (imgSrc.startsWith('blob:')) {
              URL.revokeObjectURL(imgSrc);
              this.blobUrls = this.blobUrls.filter(u => u !== imgSrc);
            }
          };
          img.onload = () => {
            if (imgSrc.startsWith('blob:')) {
              URL.revokeObjectURL(imgSrc);
              this.blobUrls = this.blobUrls.filter(u => u !== imgSrc);
            }
          };
        });

        const historyEntry: ImageHistoryEntry = {
          provider,
          model,
          prompt,
          imageUrls: renderableUrls,
          timestamp: new Date().toLocaleString(),
          size,
          quality,
          output_format: model === 'gpt-image-1' ? output_format : undefined,
        };

        this.history.unshift(historyEntry);
        if (this.history.length > 10) this.history.pop();
        if (this.addToHistory) this.addToHistory(historyEntry);
        if (this.updateHistoryCallback) this.updateHistoryCallback();

        console.log('[ImageConsoleTab] Image(s) generated:', renderableUrls);
      }
    } catch (error: any) {
      console.error('[ImageConsoleTab] Generation error:', error);
      let errorMessage = error.message || 'Unknown error';
      if (error.message.includes('400')) {
        errorMessage += '. Check model parameters (e.g., gpt-image-1 does not support response_format).';
      }
      new Notice(`Failed to generate image: ${errorMessage}`);
      if (this.outputArea) this.outputArea.setText(`Error: ${errorMessage}`);
    }
  }

  private historyClickHandler(entry: ImageHistoryEntry) {
    this.providerSelector.setProvider(entry.provider, entry.model);
    this.promptInput.setPrompt(entry.prompt);
    if (this.sizeDropdown) this.sizeDropdown.value = entry.size || '1024x1024';
    if (this.qualityDropdown) this.qualityDropdown.value = entry.quality || (entry.model === 'dall-e-3' ? 'standard' : 'auto');
    if (this.outputFormatDropdown && entry.output_format) this.outputFormatDropdown.value = entry.output_format;
    console.log('[ImageConsoleTab] History entry selected:', entry);
  }

  cleanup() {
    this.blobUrls.forEach(url => URL.revokeObjectURL(url));
    this.blobUrls = [];
    this.providerSelector.cleanup();
    this.promptInput.cleanup();
    this.promptHistory.cleanup();
  }

  renderHistory(history: (ImageHistoryEntry | any)[]) {
    const imageHistory = history.filter((entry): entry is ImageHistoryEntry => 'imageUrls' in entry);
    this.promptHistory.updateHistory(imageHistory, this.historyClickHandler.bind(this));
  }
}
===== src/ui/console/tabs/ThreeDConsoleTab.ts =====

import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';

export class ThreeDConsoleTab {
  id = '3d';
  name = '3D Playground';
  icon = 'cube';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: '3D Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/VideoConsoleTab.ts =====

// src/ui/console/tabs/VideoConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';

export class VideoConsoleTab {
  id = 'video';
  name = 'Video Playground';
  icon = 'film';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'Video Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/TextConsoleTab.ts =====

// src/ui/console/tabs/TextConsoleTab.ts
import { App, Notice, Setting, SliderComponent, TextComponent } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';
import { TextGateway } from '../../../gateways/TextGateway';
import type { LLMRequest, LLMResponse } from '../../../core/Adapter';
import { ProviderSelector } from '../sections/ProviderSelector';
import { ParameterControls } from '../sections/ParameterControls';
import { PromptInput } from '../sections/PromptInput';
import { OutputViewer } from '../sections/OutputViewer';
import { PromptHistory } from '../sections/PromptHistory';

interface PromptHistoryEntry {
  provider: string;
  model: string;
  prompt: string;
  output: string;
  timestamp: string;
}

export class TextConsoleTab {
  id = 'text';
  name = 'Text Playground';
  icon = 'file-text';
  private textGateway?: TextGateway;
  private providerSelector: ProviderSelector;
  private parameterControls: ParameterControls;
  private promptInput: PromptInput;
  private outputViewer: OutputViewer;
  private promptHistory: PromptHistory;

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager,
    private addToHistory: (entry: PromptHistoryEntry) => void,
    renderHistory: () => void
  ) {
    this.providerSelector = new ProviderSelector(app, settings, secrets);
    this.parameterControls = new ParameterControls();
    this.promptInput = new PromptInput();
    this.outputViewer = new OutputViewer();
    this.promptHistory = new PromptHistory();
  }

  async render(container: HTMLElement) {
    console.log('[TextConsoleTab] Rendering...');
    try {
      this.textGateway = await TextGateway.create(this.secrets, this.settings);
      console.log('[TextConsoleTab] TextGateway initialized successfully.');
    } catch (error: any) {
      console.error('[TextConsoleTab] Failed to initialize TextGateway:', error);
      new Notice('Failed to initialize Text Console. Some features may be limited.');
      container.createEl('p', { text: 'Error initializing Text Console.' });
    }

    // Render sections
    this.providerSelector.render(container, this.textGateway);
    this.parameterControls.render(container);
    this.promptInput.render(container, this.runPrompt.bind(this));
    this.outputViewer.render(container);
    this.promptHistory.render(container, this.historyClickHandler.bind(this));
  }

  private async runPrompt() {
    console.log('[TextConsoleTab] Run button clicked.');
    const provider = this.providerSelector.getSelectedProvider();
    const model = this.providerSelector.getSelectedModel() || this.settings.providers[provider]?.model || '';
    const prompt = this.promptInput.getPrompt().trim();
    const temperature = this.parameterControls.getTemperature();
    const maxTokens = this.parameterControls.getMaxTokens();

    this.outputViewer.clear();

    if (!prompt) {
      new Notice('Please enter a prompt.');
      return;
    }
    if (!provider) {
      new Notice('Please select a provider.');
      return;
    }
    if (!this.textGateway) {
      new Notice('TextGateway not initialized. Cannot generate response.');
      this.outputViewer.setOutput('Error: TextGateway not initialized.');
      return;
    }

    const request: LLMRequest = { prompt, model, temperature, maxTokens };
    const adapter = (this.textGateway as any).adapters[provider];
    if (!adapter) {
      new Notice(`No adapter found for provider: ${provider}. Please check configuration.`);
      this.outputViewer.setOutput(`Error: No adapter for ${provider}.`);
      console.error('[TextConsoleTab] No adapter found for provider:', provider);
      return;
    }

    try {
      this.outputViewer.setOutput('Generating...');
      console.log('[TextConsoleTab] Testing provider:', provider, 'with request:', {
        prompt: prompt.length > 50 ? prompt.slice(0, 50) + '...' : prompt,
        model,
        temperature,
        maxTokens,
      });

      const result: LLMResponse = await adapter.generate(request);
      let output = '[No result returned]';
      let tokensUsed = 0;

      if (result && typeof result.output === 'string') {
        output = result.output.trim();
        tokensUsed = result.tokensUsed || 0;
      } else {
        console.warn('[TextConsoleTab] Unexpected response format from provider:', provider, result);
        output = '[Unexpected response format]';
      }

      this.outputViewer.setOutput(output);
      this.outputViewer.setCode(`await window.aiNNS.text.generate("${prompt.replace(/"/g, '\\"')}", { model: "${model}", temperature: ${temperature}, maxTokens: ${maxTokens} });`);
      this.addToHistory({ provider, model, prompt, output, timestamp: new Date().toLocaleString() });
      console.log('[TextConsoleTab] Response received for', provider, ':', {
        output: output.length > 50 ? output.slice(0, 50) + '...' : output,
        tokensUsed,
      });
    } catch (error: any) {
      console.error('[TextConsoleTab] Generation error for', provider, ':', error);
      let errorMessage = `Error: ${error.message || 'Unknown error'}`;
      this.outputViewer.setOutput(errorMessage);
      new Notice(`Failed to generate with ${provider}: ${error.message || 'Unknown error'}`);
    }
  }

  private historyClickHandler(entry: PromptHistoryEntry) {
    this.providerSelector.setProvider(entry.provider, entry.model);
    this.promptInput.setPrompt(entry.prompt);
  }

  cleanup() {
    this.providerSelector.cleanup();
    this.parameterControls.cleanup();
    this.promptInput.cleanup();
    this.outputViewer.cleanup();
    this.promptHistory.cleanup();
  }

  renderHistory(history: PromptHistoryEntry[]) {
    this.promptHistory.updateHistory(history, this.historyClickHandler.bind(this));
  }
}
===== src/ui/console/tabs/OcrConsoleTab.ts =====

// src/ui/console/tabs/OcrConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';

export class OcrConsoleTab {
  id = 'ocr';
  name = 'OCR Playground';
  icon = 'scan';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'OCR Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/AudioConsoleTab.ts =====

// src/ui/console/tabs/AudioConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';

export class AudioConsoleTab {
  id = 'audio';
  name = 'Audio Playground';
  icon = 'volume-2';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'Audio Console (Coming Soon)' });
  }

  cleanup() {}
}

===== src/ui/console/sections/ParameterControls.ts =====

// src/ui/console/sections/ParameterControls.ts
import { Setting, SliderComponent, TextComponent, Notice } from 'obsidian';

export class ParameterControls {
  private temperatureSlider?: SliderComponent;
  private maxTokensInput?: TextComponent;

  render(container: HTMLElement) {
    const paramsContainer = container.createEl('div', { cls: 'ai-console-params' });
    paramsContainer.createEl('h4', { text: 'Parameters' });

    try {
      new Setting(paramsContainer)
        .setName('Temperature')
        .setDesc('Controls randomness (0.0 to 1.0).')
        .addSlider(slider => {
          this.temperatureSlider = slider.setLimits(0, 1, 0.1).setValue(0.7).setDynamicTooltip();
        });
    } catch (error) {
      console.error('[ParameterControls] Error creating temperature slider:', error);
      paramsContainer.createEl('p', { text: 'Error loading temperature slider.' });
    }

    try {
      new Setting(paramsContainer)
        .setName('Max Tokens')
        .setDesc('Maximum number of tokens to generate.')
        .addText(text => {
          this.maxTokensInput = text
            .setPlaceholder('1000')
            .setValue('1000')
            .onChange(value => {
              if (isNaN(parseInt(value)) && value !== '') {
                new Notice('Max Tokens must be a number.');
                text.setValue('1000');
              }
            });
        });
    } catch (error) {
      console.error('[ParameterControls] Error creating max tokens input:', error);
      paramsContainer.createEl('p', { text: 'Error loading max tokens input.' });
    }
  }

  getTemperature(): number {
    try {
      return parseFloat(this.temperatureSlider!.getValue().toString()) || 0.7;
    } catch (error) {
      console.error('[ParameterControls] Error getting temperature:', error);
      return 0.7;
    }
  }

  getMaxTokens(): number {
    try {
      return parseInt(this.maxTokensInput!.getValue()) || 1000;
    } catch (error) {
      console.error('[ParameterControls] Error getting max tokens:', error);
      return 1000;
    }
  }

  cleanup() {
    // No cleanup needed for sliders and inputs
  }
}
===== src/ui/console/sections/ProviderSelector.ts =====

// src/ui/console/sections/ProviderSelector.ts
import { App, Setting, Notice } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';
import { providerMetadata, providerFetchers } from '../../../settings/providers/index';
import type { TextGateway } from '../../../gateways/TextGateway';

export class ProviderSelector {
  private providerSelectEl: HTMLSelectElement;
  private modelSelectEl: HTMLSelectElement;
  private providers: string[] = [];
  private providerChangeListeners: ((provider: string) => void)[] = [];
  private modelChangeListeners: ((model: string) => void)[] = []; // Added for model change events

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager,
    private allowedProviders?: string[], // Optional filter for providers
    private providerModels?: Record<string, string[]> // Optional override for models per provider
  ) {}

  async render(container: HTMLElement, textGateway?: TextGateway) {
    const controlsSection = container.createEl('div', { cls: 'ai-console-controls' });
    controlsSection.createEl('h3', { text: 'Settings' });

    this.providers = [];

    try {
      for (const key of Object.keys(this.settings.providers)) {
        // Only include providers that are in allowedProviders, if provided
        if (this.allowedProviders && !this.allowedProviders.includes(key)) {
          continue;
        }
        const meta = providerMetadata[key];
        if (meta.requiresApiKey) {
          const apiKey = await this.secrets.getSecret(key);
          if (apiKey) this.providers.push(key);
        } else {
          this.providers.push(key);
        }
      }
      console.log('[ProviderSelector] Providers loaded:', this.providers);
    } catch (error) {
      console.error('[ProviderSelector] Error gathering providers:', error);
      new Notice('Failed to load providers. Using fallback options.');
    }

    new Setting(controlsSection)
      .setName('Provider')
      .setDesc('Select the AI provider to use.')
      .addDropdown(dropdown => {
        this.providerSelectEl = dropdown.selectEl;
        if (this.providers.length === 0) {
          dropdown.addOption('', 'No providers available');
        } else {
          this.providers.forEach(p => dropdown.addOption(p, p));
          const defaultProvider = this.settings.categories?.text?.defaultProvider;
          const initial = defaultProvider && this.providers.includes(defaultProvider)
            ? defaultProvider
            : this.providers[0];
          dropdown.setValue(initial);

          dropdown.onChange(async value => {
            console.log('[ProviderSelector] Provider changed to:', value);
            await this.updateModelDropdown(value);
            this.providerChangeListeners.forEach(listener => listener(value));
          });
        }
      });

    const modelSetting = new Setting(controlsSection)
      .setName('Model')
      .setDesc('Select the model for the selected provider.');

    modelSetting.controlEl.style.flexDirection = 'column';
    modelSetting.controlEl.style.alignItems = 'stretch';

    modelSetting.addDropdown(dropdown => {
      this.modelSelectEl = dropdown.selectEl;
      this.modelSelectEl.style.width = '100%'; // Make dropdown full width
      this.modelSelectEl.setAttr('data-type', 'model'); // Add for debugging or future use
      dropdown.setDisabled(this.providers.length === 0);
      dropdown.onChange(value => {
        console.log('[ProviderSelector] Model changed to:', value);
        this.modelChangeListeners.forEach(listener => listener(value));
      });
    });

    if (this.providers.length > 0) {
      try {
        await this.updateModelDropdown(this.providerSelectEl.value);
      } catch (error) {
        console.error('[ProviderSelector] Error populating models:', error);
      }
    }
  }

  private async updateModelDropdown(provider: string) {
    console.log('[ProviderSelector] Updating model dropdown for provider:', provider);
    this.modelSelectEl.innerHTML = '';
    this.modelSelectEl.disabled = true;

    if (!provider || !this.settings.providers[provider]) {
      this.modelSelectEl.add(new Option('No models available', ''));
      return;
    }

    try {
      let models: string[] = [];

      // Use provided providerModels if available, otherwise fetch dynamically
      if (this.providerModels && this.providerModels[provider]) {
        models = this.providerModels[provider];
      } else {
        if (providerMetadata[provider].requiresApiKey) {
          const apiKey = await this.secrets.getSecret(provider);
          if (apiKey) {
            models = await providerFetchers[provider](apiKey, this.app);
          }
        } else {
          models = await providerFetchers[provider]('', this.app);
        }
      }

      if (!models.length) {
        this.modelSelectEl.add(new Option('No models available', ''));
        return;
      }

      models.forEach(m => this.modelSelectEl.add(new Option(m, m)));
      const current = this.settings.providers[provider].model;
      this.modelSelectEl.value = models.includes(current) ? current : models[0];
      this.modelSelectEl.disabled = false;
      console.log('[ProviderSelector] Models loaded:', models);
      // Trigger model change event to ensure UI updates
      this.modelChangeListeners.forEach(listener => listener(this.modelSelectEl.value));
    } catch (error) {
      console.error('[ProviderSelector] Error fetching models:', error);
      this.modelSelectEl.add(new Option('Error fetching models', ''));
    }
  }

  onProviderChange(listener: (provider: string) => void) {
    this.providerChangeListeners.push(listener);
  }

  onModelChange(listener: (model: string) => void) {
    this.modelChangeListeners.push(listener);
  }

  getSelectedProvider(): string {
    return this.providerSelectEl.value;
  }

  getSelectedModel(): string {
    return this.modelSelectEl.value;
  }

  setProvider(provider: string, model: string) {
    if (this.providers.includes(provider)) {
      this.providerSelectEl.value = provider;
      this.updateModelDropdown(provider).then(() => {
        if (this.modelSelectEl.options.length > 0) {
          this.modelSelectEl.value = model;
          // Trigger model change event
          this.modelChangeListeners.forEach(listener => listener(model));
        }
      });
      this.providerChangeListeners.forEach(listener => listener(provider));
    }
  }

  cleanup() {
    this.providerChangeListeners = [];
    this.modelChangeListeners = [];
  }
}
===== src/ui/console/sections/OutputViewer.ts =====

// src/ui/console/sections/OutputViewer.ts
export class OutputViewer {
    private outputArea: HTMLElement;
    private codeBlock: HTMLElement;
  
    render(container: HTMLElement) {
      const outputSection = container.createEl('div', { cls: 'ai-console-output-section' });
      outputSection.createEl('h4', { text: 'Output' });
      this.outputArea = outputSection.createEl('div', { cls: 'ai-console-output' });
      this.codeBlock = outputSection.createEl('pre', { cls: 'ai-console-code' });
    }
  
    setOutput(output: string) {
      this.outputArea.setText(output);
    }
  
    setCode(code: string) {
      this.codeBlock.setText(code);
    }
  
    clear() {
      this.outputArea.empty();
      this.codeBlock.empty();
    }
  
    cleanup() {
      // No cleanup needed for output elements
    }
  }
===== src/ui/console/sections/PromptHistory.ts =====

import type { App } from 'obsidian';
import type { BaseHistoryEntry, ImageHistoryEntry } from '../AiConsoleModal';

// Type guard to check if entry is ImageHistoryEntry
function isImageHistoryEntry(entry: BaseHistoryEntry): entry is ImageHistoryEntry {
    return 'imageUrls' in entry;
}

export class PromptHistory {
    private container?: HTMLElement;

    constructor() {}

    render(container: HTMLElement, onClick: (entry: BaseHistoryEntry) => void) {
        this.container = container.createEl('div', { cls: 'ai-console-history-section' });
        this.container.createEl('h4', { text: 'History' });
        this.updateHistory([], onClick);
    }

    updateHistory<T extends BaseHistoryEntry>(history: T[], onClick: (entry: T) => void) {
        if (!this.container) return;

        const historyContainer = this.container.querySelector('.ai-console-history') || this.container.createEl('div', { cls: 'ai-console-history' });
        historyContainer.empty();

        if (history.length === 0) {
            historyContainer.createEl('p', { text: 'No history yet.' });
            return;
        }

        history.forEach((entry, index) => {
            const entryEl = historyContainer.createEl('div', { cls: 'ai-console-history-entry' });
            entryEl.createEl('p', { text: `Prompt: ${entry.prompt.slice(0, 50)}${entry.prompt.length > 50 ? '...' : ''}` });
            entryEl.createEl('p', { text: `Provider: ${entry.provider}` });
            entryEl.createEl('p', { text: `Model: ${entry.model}` });
            entryEl.createEl('p', { text: `Time: ${entry.timestamp}` });

            // Display image thumbnail for image entries
            if (isImageHistoryEntry(entry) && entry.imageUrls?.length > 0) {
                entryEl.createEl('img', {
                    attr: { 
                        src: entry.imageUrls[0], 
                        style: 'max-width: 50px; max-height: 50px; margin-top: 5px;'
                    }
                });
            }

            entryEl.addEventListener('click', () => onClick(entry));
        });
    }

    cleanup() {
        if (this.container) {
            this.container.empty();
            this.container = undefined;
        }
    }
}
===== src/ui/console/sections/PromptInput.ts =====

// src/ui/console/sections/PromptInput.ts
import { Notice } from 'obsidian';

export class PromptInput {
  private promptInput: HTMLTextAreaElement;

  render(container: HTMLElement, onRun: () => void) {
    const promptSection = container.createEl('div', { cls: 'ai-console-prompt-section' });
    this.promptInput = promptSection.createEl('textarea', {
      attr: { placeholder: 'Enter your prompt here...' },
      cls: 'ai-console-prompt'
    }) as HTMLTextAreaElement;

    const runBtn = promptSection.createEl('button', { text: 'Run', cls: 'ai-console-run-btn' });
    runBtn.addEventListener('click', onRun);
  }

  getPrompt(): string {
    return this.promptInput.value;
  }

  setPrompt(prompt: string) {
    this.promptInput.value = prompt;
  }

  cleanup() {
    // No cleanup needed for textarea
  }
}

===== src/ui/console/styles/consoleStyles.ts =====

export const consoleCSS = `
.ai-console-container {
  padding: 20px;
  max-width: 900px;
  margin: auto;
  background: var(--background-primary);
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.ai-console-tab-selector {
  display: flex;
  gap: 0;
  margin-bottom: 0;
  background: #2F2F2F;
  padding: 0;
  border-bottom: 1px solid var(--background-modifier-border);
  flex-wrap: nowrap; /* Prevent wrapping to ensure all tabs are visible */
  overflow-x: auto; /* Allow horizontal scrolling if tabs overflow */
  -webkit-overflow-scrolling: touch; /* Smooth scrolling on touch devices */
}

/* Custom Scrollbar Styling */
.ai-console-tab-selector::-webkit-scrollbar {
  height: 4px; /* Slimmer scrollbar */
}

.ai-console-tab-selector::-webkit-scrollbar-track {
  background: #2F2F2F; /* Match the background of the tab selector */
}

.ai-console-tab-selector::-webkit-scrollbar-thumb {
  background: var(--background-modifier-border); /* Subtle thumb color */
  border-radius: 2px;
}

.ai-console-tab-selector::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted); /* Slightly lighter on hover */
}

.ai-console-tab-button {
  display: flex;
  align-items: center;
  gap: 8px; /* Gap between icon and label */
  padding: 8px 14px; /* Increased padding for better spacing */
  border: none;
  border-right: 1px solid var(--background-modifier-border);
  background: #2F2F2F;
  color: var(--text-faint);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  text-align: center;
  justify-content: center;
  opacity: 0.4;
  min-width: 70px; /* Slightly increased min-width for better spacing */
  white-space: nowrap; /* Prevent text wrapping */
  flex-shrink: 0; /* Prevent the button from shrinking too much */
}

.ai-console-tab-button:last-child {
  border-right: none;
}

.ai-console-tab-button:hover:not(.active) {
  background: #3A3A3A;
  color: var(--text-muted);
  opacity: 0.6;
}

.ai-console-tab-button.active {
  background: var(--background-primary);
  color: var(--text-normal);
  border-top-left-radius: 6px;
  border-top-right-radius: 6px;
  border-bottom: none;
  position: relative;
  z-index: 1;
  opacity: 1;
}

.ai-console-tab-icon {
  width: 16px;
  height: 16px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0; /* Prevent icon from shrinking */
}

.ai-console-tab-icon svg {
  fill: currentColor;
  stroke: currentColor;
  opacity: inherit;
}

.ai-console-tab-label {
  display: inline-block;
  flex-shrink: 0; /* Prevent label from shrinking */
}

.ai-console-tab-content {
  padding: 16px;
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border);
  border-top: none;
  border-radius: 0 0 6px 6px;
}

.ai-console-controls {
  margin-bottom: 20px;
  padding: 15px;
  background: var(--background-secondary);
  border-radius: 6px;
  border: 1px solid var(--background-modifier-border);
}

.ai-console-controls h3 {
  margin: 0 0 15px 0;
  font-size: 18px;
  color: var(--text-normal);
}

.ai-console-params {
  margin-top: 15px;
  padding-top: 10px;
  border-top: 1px solid var(--background-modifier-border);
}

.ai-console-params h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--text-normal);
}

.ai-console-prompt-section {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  align-items: flex-end;
}

.ai-console-prompt {
  flex: 1;
  width: 100%;
  height: 120px;
  padding: 10px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 6px;
  background: var(--background-primary-alt);
  color: var(--text-normal);
  font-size: 14px;
  resize: vertical;
  transition: border-color 0.2s ease;
}

.ai-console-prompt:focus {
  border-color: var(--interactive-accent);
  outline: none;
}

.ai-console-run-btn {
  padding: 10px 20px;
  background: var(--interactive-accent);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  transition: background 0.2s ease;
}

.ai-console-run-btn:hover {
  background: var(--interactive-accent-hover);
}

.ai-console-output-section {
  margin-bottom: 20px;
}

.ai-console-output-section h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--text-normal);
}

.ai-console-output {
  padding: 15px;
  background: var(--background-secondary);
  border-radius: 6px;
  min-height: 120px;
  white-space: pre-wrap;
  border: 1px solid var(--background-modifier-border);
  font-size: 14px;
  color: var(--text-normal);
}

.ai-console-code {
  margin-top: 10px;
  padding: 15px;
  background: var(--code-block-background);
  border-radius: 6px;
  overflow-x: auto;
  font-size: 13px;
  color: var(--text-muted);
  border: 1px solid var(--background-modifier-border);
}

.ai-console-history {
  margin-top: 20px;
  padding: 15px;
  background: var(--background-secondary);
  border-radius: 6px;
  border: 1px solid var(--background-modifier-border);
}

.ai-console-history h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--text-normal);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
}

.ai-console-history-list {
  list-style: none;
  padding: 0;
  max-height: 200px;
  overflow-y: auto;
}

.ai-console-history-list li {
  padding: 10px;
  border-bottom: 1px solid var(--background-modifier-border);
  cursor: pointer;
  font-size: 14px;
  color: var(--text-normal);
  transition: background 0.2s ease;
}

.ai-console-history-list li:hover {
  background: var(--background-modifier-hover);
}

.ai-console-history-list li:last-child {
  border-bottom: none;
}

.ai-console-history-list strong {
  color: var(--text-accent);
}

.ai-console-history-list span {
  color: var(--text-muted);
}
.ai-console-controls-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
  flex-wrap: nowrap;
}

.ai-console-controls-spacer {
  flex-grow: 1;
}
`;
===== src/settings/validation.ts =====

import { Notice } from 'obsidian'; // Added import for Notice
import { SampleSettingTab } from './settings';
import { providerFetchers, providerMetadata } from './providers/index';
import { ensureProviderConfigExists } from './utils'; // Fixed import

export async function validateAllStoredSecrets(tab: SampleSettingTab): Promise<void> {
    if (tab.isValidating) return;
    tab.isValidating = true;
    console.log("[Settings] Starting initial validation of all stored secrets...");

    tab.workingProviders.clear();
    tab.availableModels = {};

    let storedKeys: string[] = [];
    try {
        storedKeys = await tab.secrets.listSecrets();
        console.log("[Settings] Stored secret keys found:", storedKeys);
    } catch (error) {
        console.error("[Settings] Failed to list secrets during validation:", error);
        tab.isValidating = false;
        return;
    }

    let settingsChanged = false;

    const validationPromises = Object.keys(providerMetadata).map(async (providerKey) => {
        const meta = providerMetadata[providerKey];
        const requiresApiKey = meta.requiresApiKey;
        const hasStoredSecret = storedKeys.includes(providerKey);

        ensureProviderConfigExists(tab, providerKey);

        if (!requiresApiKey) {
            tab.workingProviders.add(providerKey);
            console.log(`[Settings] Added non-API-key provider: ${providerKey}`);
            try {
                const models = await fetchAvailableModels(tab, providerKey, undefined);
                tab.availableModels[providerKey] = models;
                if (models.length > 0) {
                    const currentModel = tab.plugin.settings.providers[providerKey]?.model;
                    if (!currentModel || !models.includes(currentModel)) {
                        console.log(`[Settings] Resetting model for ${providerKey} to ${models[0]}`);
                        tab.plugin.settings.providers[providerKey].model = models[0];
                        settingsChanged = true;
                    }
                } else {
                    console.warn(`[Settings] No models found for non-API-key provider: ${providerKey}`);
                }
            } catch (error) {
                console.error(`[Settings] Error fetching models for non-API-key provider ${providerKey}:`, error);
                tab.availableModels[providerKey] = [];
            }
            return;
        }

        if (hasStoredSecret) {
            let apiKey: string | undefined;
            try {
                apiKey = await tab.secrets.getSecret(providerKey);
            } catch (error) {
                console.error(`[Settings] Failed to get secret for ${providerKey}:`, error);
                return;
            }

            if (apiKey) {
                console.log(`[Settings] Auto-validating stored secret for: ${providerKey}`);
                try {
                    const models = await fetchAvailableModels(tab, providerKey, apiKey);
                    tab.availableModels[providerKey] = models;

                    if (models.length > 0) {
                        tab.workingProviders.add(providerKey);
                        const currentModel = tab.plugin.settings.providers[providerKey]?.model;
                        if (!currentModel || !models.includes(currentModel)) {
                            console.log(`[Settings] Resetting model for ${providerKey} to ${models[0]}`);
                            tab.plugin.settings.providers[providerKey].model = models[0];
                            settingsChanged = true;
                        }
                        console.log(`[Settings] Auto-validation successful for: ${providerKey}`);
                    } else {
                        console.log(`[Settings] Auto-validation failed for stored secret: ${providerKey}. Needs manual re-validation.`);
                    }
                } catch (error) {
                    console.error(`[Settings] Auto-validation model fetch error for ${providerKey}:`, error);
                    tab.availableModels[providerKey] = [];
                }
            } else {
                console.warn(`[Settings] Secret listed for ${providerKey} but getSecret returned undefined.`);
                tab.availableModels[providerKey] = [];
            }
        } else {
            console.log(`[Settings] No stored secret found for API key provider: ${providerKey}`);
            tab.availableModels[providerKey] = [];
        }
    });

    await Promise.all(validationPromises);

    if (settingsChanged) {
        await tab.plugin.saveSettings();
    }

    tab.isValidating = false;
    tab.hasDoneInitialValidation = true;
    console.log("[Settings] Finished initial validation. Working providers:", Array.from(tab.workingProviders));

    tab.display();
}

export async function fetchAvailableModels(
    tab: SampleSettingTab,
    providerKey: string,
    apiKey: string | undefined
): Promise<string[]> {
    const fetcher = providerFetchers[providerKey];
    const meta = providerMetadata[providerKey];

    if (!meta) {
        console.error(`[Settings] No metadata found for provider: ${providerKey}`);
        return [];
    }
    if (meta.requiresApiKey && !apiKey) {
        console.warn(`[Settings] fetchAvailableModels called for ${providerKey} which requires an API key, but none was provided.`);
        return [];
    }
    if (!fetcher) {
        new Notice(`Model fetching not implemented for provider: ${providerKey}`);
        console.warn(`Model fetching not implemented for provider: ${providerKey}`);
        return [];
    }

    try {
        const models = await fetcher(apiKey || '', tab.plugin.app);
        return Array.isArray(models) ? models : [];
    } catch (err) {
        console.error(`[${providerKey}] Model fetch error during fetchAvailableModels:`, err);
        throw err;
    }
}
===== src/settings/defaults.ts =====

import { Category, ProviderConfig, MyPluginSettings } from './types';
import { providerMetadata } from './providers/index';

// Define supported providers per category
export const categoryProviders: Record<Category, string[]> = {
    text: ['openai', 'anthropic', 'groq', 'gemini', 'openrouter', 'grok', 'local'],
    image: ['openai', 'stabilityai', 'grok'],
    video: [], // No providers yet; placeholder for future
    audio: [], // No providers yet
    ocr: [], // No providers yet
    '3D': ['stabilityai'] // Added 3D category with stabilityai as a provider
};

// Dynamically generate DEFAULT_SETTINGS
export const DEFAULT_SETTINGS: MyPluginSettings = {
    categories: {
        text: { defaultProvider: 'openai', backupProvider: '' },
        image: { defaultProvider: 'openai', backupProvider: '' },
        video: { defaultProvider: '', backupProvider: '' },
        audio: { defaultProvider: '', backupProvider: '' },
        ocr: { defaultProvider: '', backupProvider: '' },
        '3D': { defaultProvider: '', backupProvider: '' }
    },
    providers: Object.keys(providerMetadata).reduce((acc, key) => {
        acc[key] = {
            model: providerMetadata[key].defaultModel
        };
        return acc;
    }, {} as Record<string, ProviderConfig>)
};

===== src/settings/settings.ts =====

import { App, PluginSettingTab } from 'obsidian';
import type MyPlugin from '../../main';
import { SecretsManager } from '../utils/secrets';
import { validateAllStoredSecrets } from './validation';
import { renderCategoryTabs } from './components/CategoryTabs';
import { renderProviderSelector } from './components/ProviderSelector';
import { renderProviderConfig } from './components/ProviderConfig';
import { ensureProviderConfigExists } from './utils';
import { providerMetadata } from './providers/index';
import { DEFAULT_SETTINGS } from './defaults';

export class SampleSettingTab extends PluginSettingTab {
    plugin: MyPlugin;
    secrets: SecretsManager;
    selectedProviderKey: string;
    availableModels: Record<string, string[]> = {};
    workingProviders: Set<string> = new Set();
    isValidating: boolean = false;
    hasDoneInitialValidation: boolean = false;

    constructor(app: App, plugin: MyPlugin, secretsManager: SecretsManager) {
        super(app, plugin);
        this.plugin = plugin;
        this.secrets = secretsManager;

        // Initialize selected provider
        const firstCategory = 'text';
        const defaultProvider = this.plugin.settings.categories[firstCategory].defaultProvider;
        if (defaultProvider && providerMetadata[defaultProvider]) {
            this.selectedProviderKey = defaultProvider;
        } else if (Object.keys(providerMetadata).length > 0) {
            this.selectedProviderKey = Object.keys(providerMetadata)[0];
        } else {
            this.selectedProviderKey = '';
        }

        if (this.selectedProviderKey) {
            ensureProviderConfigExists(this, this.selectedProviderKey);
        }
    }

    async display(): Promise<void> {
        if (!this.hasDoneInitialValidation && !this.isValidating) {
            setTimeout(() => validateAllStoredSecrets(this), 0);
        }

        const { containerEl } = this;
        containerEl.empty();

        containerEl.createEl('h2', { text: 'LLM Provider Settings' });

        // Render category tabs
        renderCategoryTabs(this, containerEl);

        containerEl.createEl('h3', { text: 'Configure Providers' });

        // Render provider selection dropdown
        renderProviderSelector(this, containerEl);

        // Render configuration for selected provider
        if (this.selectedProviderKey && providerMetadata[this.selectedProviderKey]) {
            renderProviderConfig(this, containerEl);
        } else {
            containerEl.createEl('p', { text: 'Please select a provider to configure.' });
        }
    }
}
===== src/settings/utils.ts =====

import { SampleSettingTab } from './settings';
import { providerMetadata } from './providers/index';
import { ProviderConfig } from './types';

export function ensureProviderConfigExists(tab: SampleSettingTab, providerKey: string): ProviderConfig | undefined {
    if (!providerKey) return undefined;

    const meta = providerMetadata[providerKey];
    if (!meta) {
        console.error(`[Settings] No metadata found for provider key: ${providerKey}`);
        return undefined;
    }

    if (!tab.plugin.settings.providers[providerKey]) {
        tab.plugin.settings.providers[providerKey] = {
            model: meta.defaultModel
        };
        console.log(`[Settings] Added missing provider configuration for: ${providerKey}`);
    }
    return tab.plugin.settings.providers[providerKey];
}

export function getTabIcon(category: string): string {
    const tabIcons: Record<string, string> = {
        text: 'text',
        image: 'image',
        video: 'video',
        audio: 'volume-2',
        ocr: 'scan',
        '3D': 'cube'
    };
    return tabIcons[category] || 'circle';
}
===== src/settings/types.ts =====

export type Category = 'text' | 'image' | 'video' | 'audio' | 'ocr' | '3D';

export interface ProviderConfig {
    model: string;
}

export interface CategorySettings {
    defaultProvider: string;
    backupProvider: string;
}

export interface MyPluginSettings {
    categories: Record<Category, CategorySettings>;
    providers: Record<string, ProviderConfig>;
}
===== src/settings/providers/local.ts =====

import { requestUrl } from 'obsidian';

export async function fetchLocalModels(): Promise<string[]> {
	try {
		// Check if Ollama is running
		await requestUrl({ url: 'http://localhost:11434', method: 'GET' });
		const response = await requestUrl({ url: 'http://localhost:11434/api/tags', method: 'GET' });
		return response.json.models?.map((m: any) => m.name).sort() ?? [];
	} catch (err) {
		console.error('[Local] Model fetch error:', err);
		throw new Error("Unable to connect to Ollama at http://localhost:11434");
	}
}
===== src/settings/providers/index.ts =====

import { App } from 'obsidian';
import { AnthropicBaseAdapter } from '../../adapters/base/AnthropicBaseAdapter';
import { GeminiBaseAdapter } from '../../adapters/base/GeminiBaseAdapter';
import { GrokBaseAdapter } from '../../adapters/base/GrokBaseAdapter';
import { GroqBaseAdapter } from '../../adapters/base/GroqBaseAdapter';
import { OpenAIBaseAdapter } from '../../adapters/base/OpenAIBaseAdapter';
import { OpenRouterBaseAdapter } from '../../adapters/base/OpenRouterBaseAdapter';
import { StabilityAIBaseAdapter } from '../../adapters/base/StabilityAIBaseAdapter';
import { fetchLocalModels } from './local';

export interface ProviderMetadata {
    key: string;
    defaultModel: string;
    requiresApiKey: boolean;
}

export const providerMetadata: Record<string, ProviderMetadata> = {
    openai: { key: 'openai', defaultModel: 'gpt-3.5-turbo', requiresApiKey: true },
    local: { key: 'local', defaultModel: 'llama2', requiresApiKey: false },
    anthropic: { key: 'anthropic', defaultModel: 'claude-3-opus-20240229', requiresApiKey: true },
    groq: { key: 'groq', defaultModel: 'mixtral-8x7b-32768', requiresApiKey: true },
    gemini: { key: 'gemini', defaultModel: 'models/gemini-pro', requiresApiKey: true },
    openrouter: { key: 'openrouter', defaultModel: 'openrouter/google/gemma-7b-it', requiresApiKey: true },
    grok: { key: 'grok', defaultModel: 'grok-1', requiresApiKey: true },
    stabilityai: { key: 'stabilityai', defaultModel: 'stable-diffusion-xl-v1', requiresApiKey: true }
};

type FetchFunction = (apiKey: string, app?: App) => Promise<string[]>;

export const providerFetchers: Record<string, FetchFunction> = {
    openai: async (apiKey: string) => {
        return await OpenAIBaseAdapter.fetchModels(apiKey);
    },
    local: fetchLocalModels,
    anthropic: async (apiKey: string) => {
        return await AnthropicBaseAdapter.fetchModels(apiKey);
    },
    groq: async (apiKey: string) => {
        return await GroqBaseAdapter.fetchModels(apiKey);
    },
    gemini: async (apiKey: string) => {
        return await GeminiBaseAdapter.fetchModels(apiKey);
    },
    openrouter: async (apiKey: string) => {
        return await OpenRouterBaseAdapter.fetchModels(apiKey);
    },
    grok: async (apiKey: string) => {
        return await GrokBaseAdapter.fetchModels(apiKey);
    },
    stabilityai: async (apiKey: string) => {
        return await StabilityAIBaseAdapter.fetchModels(apiKey);
    }
};
===== src/settings/components/ProviderSelector.ts =====

import { SampleSettingTab } from '../settings';
import { providerMetadata } from '../providers/index';
import { ensureProviderConfigExists } from '../utils';
import { Setting } from 'obsidian';

export function renderProviderSelector(tab: SampleSettingTab, containerEl: HTMLElement): void {
    new Setting(containerEl)
        .setName('Select Provider to Configure')
        .setDesc('Choose a provider to set its API key (if required) and model.')
        .addDropdown(dropdown => {
            Object.keys(providerMetadata).forEach(providerKey =>
                dropdown.addOption(providerKey, providerKey)
            );

            if (!providerMetadata[tab.selectedProviderKey]) {
                tab.selectedProviderKey = Object.keys(providerMetadata)[0] || '';
            }

            dropdown.setValue(tab.selectedProviderKey);

            dropdown.onChange(value => {
                tab.selectedProviderKey = value;
                ensureProviderConfigExists(tab, tab.selectedProviderKey);
                tab.display();
            });
        });
}
===== src/settings/components/CategoryTabs.ts =====

import { SampleSettingTab } from '../settings';
import { categoryProviders } from '../defaults';
import { TabComponent, TabConfig } from '../../ui/components/TabComponent';
import { getTabIcon } from '../utils';
import { Setting, Notice } from 'obsidian';
import { Category } from '../types';

export function renderCategoryTabs(tab: SampleSettingTab, containerEl: HTMLElement): void {
    const tabs: TabConfig[] = Object.keys(categoryProviders).map(category => ({
        tab: {
            id: category,
            name: category.charAt(0).toUpperCase() + category.slice(1),
            render: (tabContainer: HTMLElement) => renderCategoryTab(tab, tabContainer, category as Category),
            cleanup: () => {} // No cleanup needed for static settings
        },
        icon: getTabIcon(category)
    }));

    const tabComponent = new TabComponent(tab.app, tabs, 'text');
    const tabContainer = containerEl.createEl('div', { cls: 'category-tabs' });
    tabComponent.render(tabContainer);
}

function renderCategoryTab(tab: SampleSettingTab, container: HTMLElement, category: Category) {
    const catSettings = tab.plugin.settings.categories[category] || {
        defaultProvider: '',
        backupProvider: ''
    };

    // Create settings for default and backup providers
    const createProviderDropdown = (setting: Setting, settingKey: 'defaultProvider' | 'backupProvider') => {
        setting.addDropdown(dropdown => {
            const validProviders = categoryProviders[category]
                .filter(id => tab.workingProviders.has(id));

            dropdown.addOption('', '--- Select ---');

            if (validProviders.length === 0) {
                dropdown.addOption('', 'No validated providers available');
                dropdown.setDisabled(true);
            } else {
                validProviders.forEach(id => dropdown.addOption(id, id));
                dropdown.setDisabled(false);
            }

            const currentValue = catSettings[settingKey];
            dropdown.setValue(validProviders.includes(currentValue) ? currentValue : '');

            dropdown.onChange(async value => {
                const settingName = settingKey === 'defaultProvider' ? 'Default' : 'Backup';
                if (value === '') {
                    new Notice(`Cleared ${settingName} Provider for ${category}.`);
                } else {
                    new Notice(`${settingName} provider for ${category} set to ${value}`);
                }
                catSettings[settingKey] = value;
                await tab.plugin.saveSettings();
            });
        });
    };

    const defaultProviderSetting = new Setting(container)
        .setName(`Default Provider for ${category}`)
        .setDesc(`Primary provider for ${category} (must be validated).`);
    createProviderDropdown(defaultProviderSetting, 'defaultProvider');

    const backupProviderSetting = new Setting(container)
        .setName(`Backup Provider for ${category}`)
        .setDesc(`Used if the default provider for ${category} fails (must be validated).`);
    createProviderDropdown(backupProviderSetting, 'backupProvider');
}
===== src/settings/components/ProviderConfig.ts =====

import { SampleSettingTab } from '../settings';
import { providerMetadata, providerFetchers } from '../providers/index';
import { ensureProviderConfigExists } from '../utils';
import { fetchAvailableModels } from '../validation'; // Fixed import
import { Setting, Notice } from 'obsidian';
import { renderRemoveKeyButton } from './RemoveKeyButton';

export function renderProviderConfig(tab: SampleSettingTab, containerEl: HTMLElement): void {
    const selectedMeta = providerMetadata[tab.selectedProviderKey];
    const currentConfig = ensureProviderConfigExists(tab, tab.selectedProviderKey);
    if (!currentConfig) {
        containerEl.createEl('p', { text: `Error: Configuration could not be created for ${tab.selectedProviderKey}.` });
        return;
    }

    containerEl.createEl('h4', { text: `Configure: ${selectedMeta.key}` });

    // --- API Key Input + Validation Button ---
    const apiKeySetting = new Setting(containerEl);
    const requiresApiKey = selectedMeta.requiresApiKey;

    apiKeySetting.setName(`${selectedMeta.key} API Key`)
        .setDesc(requiresApiKey
            ? `Enter/update key and click Validate.`
            : `This provider does not require an API key.`);

    let apiKeyInput: HTMLInputElement | null = null;

    if (requiresApiKey) {
        apiKeySetting.addText(text => {
            apiKeyInput = text.inputEl;
            text.setPlaceholder('Enter API key here')
                .setValue('')
                .onChange(async value => {});
            text.inputEl.type = 'password';
            text.inputEl.style.width = '300px';
        });
    }

    apiKeySetting.addExtraButton(btn => {
        btn.setIcon('refresh-ccw')
            .setTooltip(requiresApiKey
                ? `Validate ${selectedMeta.key} key & fetch models`
                : 'Fetch available models (no API key needed)')
            .onClick(async () => {
                let apiKeyToValidate: string | undefined = undefined;
                const currentProvider = tab.selectedProviderKey;

                if (requiresApiKey) {
                    if (!apiKeyInput) return;
                    apiKeyToValidate = apiKeyInput.value.trim();
                    if (!apiKeyToValidate) {
                        apiKeyToValidate = await tab.secrets.getSecret(currentProvider);
                        if (!apiKeyToValidate) {
                            new Notice(`API Key required for ${currentProvider}. Enter one or check storage.`, 5000);
                            return;
                        }
                        new Notice(`Re-validating stored key for ${currentProvider}...`);
                    } else {
                        new Notice(`Validating new key for ${currentProvider}...`);
                        await tab.secrets.setSecret(currentProvider, apiKeyToValidate);
                        console.log(`[Settings] Saved new API key for ${currentProvider} before validation.`);
                    }
                } else {
                    new Notice(`Fetching models for ${currentProvider}...`);
                }

                btn.setDisabled(true);
                tab.workingProviders.delete(currentProvider);

                try {
                    const models = await fetchAvailableModels(tab, currentProvider, apiKeyToValidate);
                    tab.availableModels[currentProvider] = models;

                    if (models.length > 0) {
                        tab.workingProviders.add(currentProvider);
                        new Notice(`${currentProvider}: ${models.length} model(s) found. ${requiresApiKey ? 'Key validated!' : 'Models fetched!'}`, 5000);

                        const config = ensureProviderConfigExists(tab, currentProvider);
                        if (config && (!models.includes(config.model))) {
                            config.model = models[0];
                            new Notice(`Model reset to ${models[0]} as previous was unavailable.`, 3000);
                            await tab.plugin.saveSettings();
                        }
                    } else {
                        new Notice(`${currentProvider}: Validation failed. No models found${requiresApiKey ? ' or invalid API key' : ''}. Check console.`, 5000);
                    }
                } catch (error) {
                    console.error(`[Settings] Manual validation error for ${currentProvider}:`, error);
                    tab.availableModels[currentProvider] = [];
                    new Notice(`${currentProvider}: Validation failed. ${error.message}`, 7000);
                } finally {
                    btn.setDisabled(false);
                    tab.display();
                }
            });

        const statusContainer = btn.extraSettingsEl.createSpan({ cls: "setting-item-description" });
        statusContainer.style.marginLeft = "10px";

        if (tab.workingProviders.has(tab.selectedProviderKey)) {
            statusContainer.setText(" Valid");
            statusContainer.style.color = "green";
        } else if (requiresApiKey) {
            tab.secrets.getSecret(tab.selectedProviderKey).then(storedKey => {
                if (tab.selectedProviderKey === selectedMeta.key) {
                    if (storedKey) {
                        statusContainer.setText(" Validation Needed / Failed");
                        statusContainer.style.color = "orange";
                    } else {
                        statusContainer.setText(" No Key Set");
                        statusContainer.style.color = "red";
                    }
                }
            }).catch(err => {
                console.error("Error checking secret for status:", err);
                statusContainer.setText(" Error checking key");
                statusContainer.style.color = "red";
            });
        } else {
            if (tab.availableModels[tab.selectedProviderKey]?.length > 0) {
                statusContainer.setText(" Models Fetched");
                statusContainer.style.color = "green";
            } else {
                statusContainer.setText(" Fetch Models");
                statusContainer.style.color = "orange";
            }
        }
    });

    // --- Model Selection Dropdown ---
    const modelSetting = new Setting(containerEl)
        .setName(`${selectedMeta.key} Model`)
        .setDesc(`Select the model for ${selectedMeta.key}. (List updated after validation)`);

    modelSetting.addDropdown(dropdown => {
        const modelOptions = tab.availableModels[tab.selectedProviderKey] ?? [];
        const defaultModel = selectedMeta.defaultModel;
        let optionsToShow = [...modelOptions];

        const currentSelectedModel = currentConfig.model;
        if (currentSelectedModel && !optionsToShow.includes(currentSelectedModel)) {
            optionsToShow.push(currentSelectedModel);
        }
        if (optionsToShow.length === 0 && defaultModel) {
            optionsToShow.push(defaultModel);
        }

        optionsToShow.sort();

        if (optionsToShow.length === 0) {
            dropdown.addOption('', 'No models available (Validate key/Fetch first)');
            dropdown.setDisabled(true);
        } else {
            optionsToShow.forEach(m => dropdown.addOption(m, m));
            dropdown.setDisabled(false);
        }

        dropdown.setValue(optionsToShow.includes(currentSelectedModel) ? currentSelectedModel : optionsToShow[0] || '');

        dropdown.onChange(async value => {
            currentConfig.model = value;
            await tab.plugin.saveSettings();
            new Notice(`${selectedMeta.key} model set to ${value}`);
        });
    });

    // --- Display Fetched Models ---
    const currentModels = tab.availableModels[tab.selectedProviderKey] ?? [];
    if (currentModels.length > 0) {
        const detailsEl = containerEl.createEl('details');
        detailsEl.createEl('summary', { text: `View ${currentModels.length} Available Models` });
        const listEl = detailsEl.createEl('ul', { cls: 'provider-model-list' });
        const modelsToShow = currentModels.slice(0, 25);
        modelsToShow.forEach(model => {
            listEl.createEl('li', { text: model });
        });
        if (currentModels.length > 25) {
            listEl.createEl('li', { text: `... and ${currentModels.length - 25} more.` });
        }
    }

    // --- Remove Configuration Button ---
    renderRemoveKeyButton(tab, containerEl);
}
===== src/settings/components/RemoveKeyButton.ts =====

import { SampleSettingTab } from '../settings';
import { providerMetadata } from '../providers/index';
import { Setting, Notice } from 'obsidian';
import { Category } from '../types';

export function renderRemoveKeyButton(tab: SampleSettingTab, containerEl: HTMLElement): void {
    tab.secrets.getSecret(tab.selectedProviderKey).then(storedKey => {
        const selectedMeta = providerMetadata[tab.selectedProviderKey];
        if (tab.selectedProviderKey === selectedMeta.key && storedKey) {
            new Setting(containerEl)
                .setName(`Remove ${selectedMeta.key} API Key`)
                .setDesc(`Removes the stored API key for ${selectedMeta.key}. The model selection will be kept.`)
                .addButton(btn => {
                    btn.setButtonText('Remove Key')
                        .setIcon('trash')
                        .setWarning()
                        .onClick(async () => {
                            const providerToDelete = tab.selectedProviderKey;
                            new Notice(`Removing API key for ${providerToDelete}...`);

                            await tab.secrets.deleteSecret(providerToDelete);

                            tab.workingProviders.delete(providerToDelete);
                            tab.availableModels[providerToDelete] = [];

                            // Reset default/backup providers for affected categories
                            Object.keys(tab.plugin.settings.categories).forEach(category => {
                                const catSettings = tab.plugin.settings.categories[category as Category];
                                if (catSettings.defaultProvider === providerToDelete) {
                                    catSettings.defaultProvider = '';
                                    new Notice(`Default provider for ${category} cleared as its key was removed.`, 3000);
                                }
                                if (catSettings.backupProvider === providerToDelete) {
                                    catSettings.backupProvider = '';
                                    new Notice(`Backup provider for ${category} cleared as its key was removed.`, 3000);
                                }
                            });

                            await tab.plugin.saveSettings();
                            new Notice(`${providerToDelete} API key removed.`);

                            tab.display();
                        });
                });
        }
    }).catch(err => console.error("Error checking secret for remove button:", err));
}
===== src/core/Adapter.ts =====

// src/core/Adapter.ts
export interface LLMRequest {
  prompt: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
}

export interface LLMResponse {
  output: string;
  tokensUsed?: number;
}

export interface ImageRequest {
  prompt: string;
  model?: string;
  size?: string;
  n?: number;
  quality?: 'standard' | 'hd' | 'low' | 'medium' | 'high' | 'auto';
  response_format?: 'url' | 'b64_json';
  user?: string;
  // gpt-image-1 specific fields
  output_format?: 'png' | 'jpeg' | 'webp';
  background?: string;
  moderation?: boolean;
  output_compression?: 'none' | 'low' | 'medium' | 'high';
}

export interface ImageResponse {
  imageUrls: string[];
}

export interface LLMAdapter {
  generate(req: LLMRequest): Promise<LLMResponse>;
}

export interface ImageAdapter {
  generate(request: ImageRequest): Promise<ImageResponse>;
}
===== src/core/Gateway.ts =====


===== src/utils/secrets.ts =====

import { App, Vault, normalizePath } from 'obsidian';

// Define the path for the secrets directory and file
const SECRETS_DIR_PATH = '.secrets/nns';
const SECRETS_FILE_PATH = normalizePath(`${SECRETS_DIR_PATH}/secrets.json`);

/**
 * Manages storing and retrieving secrets (like API keys) securely
 * within the Obsidian vault in a dedicated file.
 */
export class SecretsManager {
    private app: App;
    private vault: Vault;
    // In-memory cache of the secrets
    private secrets: Record<string, string> = {};
    // Flag to indicate if secrets have been loaded from the file
    private isLoaded: boolean = false;
    // Promise to ensure loading completes before other operations if needed
    private loadPromise: Promise<void> | null = null;

    /**
     * Creates an instance of SecretsManager.
     * @param app - The Obsidian App instance.
     */
    constructor(app: App) {
        this.app = app;
        this.vault = app.vault;
        // Start loading secrets immediately but don't block constructor
        this.loadPromise = this.loadSecretsFromFile();
    }

    /**
     * Ensures that the initial loading of secrets from the file is complete.
     * Should be called after instantiation and before relying on secrets being present.
     */
    async initialize(): Promise<void> {
        if (!this.loadPromise) {
             // Should not happen with current constructor, but safeguard
            this.loadPromise = this.loadSecretsFromFile();
        }
        // Ensure the promise is awaited only once
        if (this.loadPromise) {
            await this.loadPromise;
        }
        console.log('[SecretsManager] Initialized and secrets loaded.');
    }

    /**
     * Loads secrets from the JSON file in the vault.
     * Creates the directory and file if they don't exist.
     */
    private async loadSecretsFromFile(): Promise<void> {
        try {
            // Ensure directory exists before trying to read the file
            await this.ensureDirectoryExists();

            if (await this.vault.adapter.exists(SECRETS_FILE_PATH)) {
                const content = await this.vault.adapter.read(SECRETS_FILE_PATH);
                if (content) {
                    try {
                        this.secrets = JSON.parse(content);
                        console.log(`[SecretsManager] Secrets loaded from ${SECRETS_FILE_PATH}`);
                    } catch (parseError) {
                        console.error(`[SecretsManager] Error parsing secrets file ${SECRETS_FILE_PATH}. Using empty secrets.`, parseError);
                        this.secrets = {}; // File is corrupted, start fresh
                        // Optionally: Backup corrupted file
                        // await this.vault.adapter.write(SECRETS_FILE_PATH + '.corrupted', content);
                        await this.saveSecretsToFile(); // Overwrite corrupted file with empty object
                    }
                } else {
                    this.secrets = {}; // File exists but is empty
                     console.log(`[SecretsManager] Secrets file ${SECRETS_FILE_PATH} is empty. Initializing empty secrets.`);
                }
            } else {
                console.log(`[SecretsManager] Secrets file not found at ${SECRETS_FILE_PATH}. Initializing empty secrets.`);
                this.secrets = {};
                // Create the file with empty content if it doesn't exist
                await this.saveSecretsToFile();
            }
        } catch (error) {
            console.error(`[SecretsManager] Error loading secrets from ${SECRETS_FILE_PATH}:`, error);
            // Fallback to empty secrets if loading fails
            this.secrets = {};
        } finally {
            this.isLoaded = true;
            this.loadPromise = null; // Loading is complete
        }
    }

    /**
     * Ensures the '.secrets/nns' directory exists.
     */
    private async ensureDirectoryExists(): Promise<void> {
         try {
            // Check if the base '.secrets' directory exists
            const baseDirExists = await this.vault.adapter.exists(normalizePath('.secrets'));
            if (!baseDirExists) {
                console.log("[SecretsManager] Creating base directory '.secrets'");
                await this.vault.adapter.mkdir(normalizePath('.secrets'));
            }
             // Check if the specific 'nns' subdirectory exists
            const nnsDirExists = await this.vault.adapter.exists(SECRETS_DIR_PATH);
             if (!nnsDirExists) {
                console.log(`[SecretsManager] Creating secrets directory at ${SECRETS_DIR_PATH}`);
                await this.vault.adapter.mkdir(SECRETS_DIR_PATH);
            }
        } catch (error) {
            // Ignore errors if directory already exists, log others
             // Vault adapter throws if it exists, so we check the message
            if (!(error instanceof Error && /EEXIST|already exists/i.test(error.message))) {
                 console.error(`[SecretsManager] Error creating directory ${SECRETS_DIR_PATH}:`, error);
                 // Re-throw if it's not an 'already exists' error, as it might be permissions etc.
                 throw error;
            } else {
                 // Log if it already existed, for debugging clarity
                 // console.log(`[SecretsManager] Directory ${SECRETS_DIR_PATH} already exists.`);
            }
        }
    }

    /**
     * Saves the current in-memory secrets to the JSON file in the vault.
     */
    private async saveSecretsToFile(): Promise<void> {
        // No need to wait for loadPromise here, as saving should only happen
        // after initialization or user action, by which time loading is complete.
        // If save is called *during* initial load (unlikely), it might cause issues.
        // Consider adding a queue or lock if concurrent access becomes complex.
         try {
            await this.ensureDirectoryExists(); // Make sure directory exists before writing
            const data = JSON.stringify(this.secrets, null, 2); // Pretty-print JSON
            await this.vault.adapter.write(SECRETS_FILE_PATH, data);
            // console.log(`[SecretsManager] Secrets saved to ${SECRETS_FILE_PATH}`); // Reduce log noise
        } catch (error) {
            console.error(`[SecretsManager] Error saving secrets to ${SECRETS_FILE_PATH}:`, error);
            // Optionally notify the user
            // new Notice('Failed to save secrets. Check console for details.');
        }
    }

    /**
     * Sets (adds or updates) a secret.
     * @param key - The identifier for the secret (e.g., 'openai').
     * @param value - The secret value (e.g., the API key).
     */
    async setSecret(key: string, value: string): Promise<void> {
        if (!key || typeof value !== 'string') {
            console.error('[SecretsManager] Invalid key or value provided for setSecret.');
            return;
        }
        this.secrets[key] = value;
        await this.saveSecretsToFile();
    }

    /**
     * Retrieves a secret by its key.
     * Returns undefined if the key is not found.
     * Ensures secrets are loaded before returning.
     * @param key - The identifier for the secret.
     * @returns The secret value or undefined.
     */
    async getSecret(key: string): Promise<string | undefined> {
         // Ensure initial load is complete before trying to access secrets
         if (!this.isLoaded && this.loadPromise) {
             console.warn('[SecretsManager] Attempted to get secret before initial load completed. Waiting...');
             await this.loadPromise;
         }
        return this.secrets[key];
    }

    /**
     * Deletes a secret by its key.
     * Ensures secrets are loaded before deleting.
     * @param key - The identifier for the secret to delete.
     */
    async deleteSecret(key: string): Promise<void> {
         // Ensure initial load is complete
         if (!this.isLoaded && this.loadPromise) {
             console.warn('[SecretsManager] Attempted to delete secret before initial load completed. Waiting...');
            await this.loadPromise;
        }
        if (this.secrets.hasOwnProperty(key)) {
            delete this.secrets[key];
            await this.saveSecretsToFile();
        } else {
             console.log(`[SecretsManager] Attempted to delete non-existent secret key: ${key}`);
        }
    }

    /**
     * Lists the keys of all stored secrets.
     * Ensures secrets are loaded before listing.
     * @returns An array of secret keys.
     */
    async listSecrets(): Promise<string[]> {
         // Ensure initial load is complete
         if (!this.isLoaded && this.loadPromise) {
             console.warn('[SecretsManager] Attempted to list secrets before initial load completed. Waiting...');
            await this.loadPromise;
        }
        return Object.keys(this.secrets);
    }
}

===== src/adapters/image/OpenAIImageAdapter.ts =====

import { requestUrl } from 'obsidian';
import type { ImageRequest, ImageResponse } from '../../core/Adapter';

export class OpenAIImageAdapter {
  private apiKey: string;
  private defaultModel: string;

  constructor(apiKey: string, model: string = 'dall-e-3') {
    if (!apiKey) {
      throw new Error('[OpenAIImageAdapter] API key is required.');
    }
    this.apiKey = apiKey.trim();
    this.defaultModel = model;
    console.log(`[OpenAIImageAdapter] Initialized with model: ${model}`);
  }

  async generate(request: ImageRequest): Promise<ImageResponse> {
    const model = request.model || this.defaultModel;

    // Supported models and their constraints
    const supportedModels = ['dall-e-3', 'dall-e-2', 'gpt-image-1'];
    const supportedSizes: Record<string, string[]> = {
      'dall-e-3': ['1024x1024', '1792x1024', '1024x1792'],
      'dall-e-2': ['256x256', '512x512', '1024x1024'],
      'gpt-image-1': ['1024x1024', '1536x1024', '1024x1536'],
    };
    const maxN: Record<string, number> = {
      'dall-e-3': 1,
      'dall-e-2': 10,
      'gpt-image-1': 10,
    };
    const supportedQualities: Record<string, ("standard" | "hd" | "low" | "medium" | "high" | "auto")[]> = {
        'dall-e-3': ['standard', 'hd'],
        'dall-e-2': [], // No quality options
        'gpt-image-1': ['low', 'medium', 'high', 'auto'],
      };      
    const supportedOutputFormats: string[] = ['png', 'jpeg', 'webp'];

    // Validate model
    if (!supportedModels.includes(model)) {
      throw new Error(`[OpenAIImageAdapter] Unsupported model: ${model}. Supported models: ${supportedModels.join(', ')}`);
    }

    // Validate and set size
    const size = request.size && supportedSizes[model]?.includes(request.size)
      ? request.size
      : supportedSizes[model][0] || '1024x1024';

    // Validate and set n
    const n = Math.min(request.n || 1, maxN[model] || 1);
    if (request.n && request.n > maxN[model]) {
      console.warn(`[OpenAIImageAdapter] Requested n=${request.n} exceeds max for ${model} (${maxN[model]}). Using n=${n}.`);
    }

    // Validate and set quality
    let quality = request.quality || (model === 'dall-e-3' ? 'standard' : 'auto');
    if (supportedQualities[model].length > 0 && !supportedQualities[model].includes(quality)) {
      console.warn(`[OpenAIImageAdapter] Quality ${quality} not supported for model ${model}. Using default: ${supportedQualities[model][0]}.`);
      quality = supportedQualities[model][0];
    }

    // Validate output_format for gpt-image-1
    let output_format = request.output_format || 'png';
    if (model === 'gpt-image-1' && !supportedOutputFormats.includes(output_format)) {
      console.warn(`[OpenAIImageAdapter] Output format ${output_format} not supported for gpt-image-1. Using 'png'.`);
      output_format = 'png';
    }

    // Build request body
    const body: any = {
      prompt: request.prompt,
      model: model,
      n: n,
      size: size,
    };

    if (model === 'gpt-image-1') {
      body.output_format = output_format;
      if (quality !== 'auto') {
        body.quality = quality; // low, medium, high
      }
      // Add optional gpt-image-1 fields if provided
      if (request.background) body.background = request.background;
      if (request.moderation !== undefined) body.moderation = request.moderation;
      if (request.output_compression) body.output_compression = request.output_compression;
    } else {
      body.response_format = request.response_format || 'b64_json';
      if (model === 'dall-e-3' && quality) {
        body.quality = quality; // standard or hd
      }
    }

    // Add user if provided
    if (request.user) body.user = request.user;

    console.log('[OpenAIImageAdapter] Sending request:', body);

    try {
      const response = await requestUrl({
        url: 'https://api.openai.com/v1/images/generations',
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(body),
      });

      if (response.status >= 400) {
        let errorMessage = `OpenAI error ${response.status}`;
        try {
          const errorBody = response.json?.error || response.text || 'No additional details';
          console.error('[OpenAIImageAdapter] Detailed error response:', errorBody);
          errorMessage += `: ${errorBody.message || errorBody}`;
          if (response.status === 400 && model === 'gpt-image-1' && body.response_format) {
            errorMessage += '. gpt-image-1 does not support response_format. Use output_format (png, jpeg, webp).';
          } else if (response.status === 401) {
            errorMessage += '. Invalid API key. Verify at https://platform.openai.com/account/api-keys.';
          } else if (response.status === 400) {
            errorMessage += '. Check request parameters (e.g., size, quality, or model validity).';
          } else if (response.status === 429) {
            errorMessage += '. Rate limit exceeded. Check quota at https://platform.openai.com/account/usage.';
          } else if (response.status === 403) {
            errorMessage += '. Check API key permissions at https://platform.openai.com/account.';
          } else if (response.status >= 500) {
            errorMessage += '. Server error at OpenAI. Try again later.';
          }
        } catch (parseError) {
          errorMessage += ': Failed to parse error details';
        }
        throw new Error(errorMessage);
      }

      if (!response.json || !response.json.data) {
        throw new Error('[OpenAIImageAdapter] Invalid response format from OpenAI API');
      }

      const imageUrls = response.json.data.map((item: { url?: string; b64_json?: string }) => {
        if (item.b64_json) {
          return item.b64_json; // Return raw base64
        } else if (item.url) {
          return item.url;
        }
        throw new Error('[OpenAIImageAdapter] No valid image data in response');
      });

      return { imageUrls };
    } catch (error: any) {
      console.error('[OpenAIImageAdapter] Image generation failed:', error);
      throw new Error(`[OpenAIImageAdapter] Failed to generate image: ${error.message || 'Unknown error'}`);
    }
  }
}
===== src/adapters/text/GeminiTextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { GeminiBaseAdapter } from '../base/GeminiBaseAdapter';

export class GeminiTextAdapter extends GeminiBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'gemini-1.5-pro-latest';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[GeminiTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            contents: [
                ...(req.systemPrompt
                    ? [{ parts: [{ text: req.systemPrompt }], role: 'system' }]
                    : []),
                { parts: [{ text: req.prompt }], role: 'user' },
            ],
            generationConfig: {
                temperature: req.temperature ?? 0.7,
                maxOutputTokens: req.maxTokens ?? 1000,
            },
        };

        console.log('[GeminiTextAdapter] Sending request:', {
            endpoint: `models/${model}:generateContent`,
            body: {
                contents: body.contents.map(c => ({
                    ...c,
                    parts: c.parts.map(p => ({
                        text: p.text.length > 50 ? p.text.slice(0, 50) + '...' : p.text,
                    })),
                })),
                generationConfig: body.generationConfig,
            },
        });

        let lastError: Error | null = null;

        for (const apiVersion of this.apiVersions) {
            try {
                const data = await this.makeRequest(`models/${model}:generateContent`, body, 'POST', apiVersion);

                if (
                    !data.candidates ||
                    !Array.isArray(data.candidates) ||
                    !data.candidates[0]?.content?.parts?.[0]?.text
                ) {
                    console.error('[GeminiTextAdapter] Unexpected response format:', data);
                    throw new Error('Unexpected Gemini API response format');
                }

                const output = data.candidates[0].content.parts[0].text.trim();
                const tokensUsed = data.usageMetadata?.totalTokenCount || 0;

                console.log('[GeminiTextAdapter] Response received:', {
                    output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                    tokensUsed,
                    model,
                    apiVersion,
                });

                return {
                    output,
                    tokensUsed,
                };
            } catch (error) {
                console.error('[GeminiTextAdapter] Generation error for API version', apiVersion, ':', error);
                lastError = error;
                continue;
            }
        }

        throw lastError || new Error('All API versions failed to generate content');
    }
}
===== src/adapters/text/GrokTextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { GrokBaseAdapter } from '../base/GrokBaseAdapter';

export class GrokTextAdapter extends GrokBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'grok-1';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[GrokTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[GrokTextAdapter] Sending request:', {
            endpoint: 'chat/completions',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('chat/completions', body, 'POST');

            if (!data.choices || !Array.isArray(data.choices) || !data.choices[0]?.message?.content) {
                console.error('[GrokTextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected xAI API response format');
            }

            const output = data.choices[0].message.content.trim();
            const tokensUsed = data.usage?.total_tokens || 0;

            console.log('[GrokTextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[GrokTextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/text/OpenAITextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { OpenAIBaseAdapter } from '../base/OpenAIBaseAdapter';

export class OpenAITextAdapter extends OpenAIBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'gpt-3.5-turbo';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[OpenAITextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[OpenAITextAdapter] Sending request:', {
            endpoint: 'chat/completions',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('chat/completions', body, 'POST');

            if (!data.choices || !Array.isArray(data.choices) || !data.choices[0]?.message?.content) {
                console.error('[OpenAITextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected OpenAI API response format');
            }

            const output = data.choices[0].message.content.trim();
            const tokensUsed = data.usage?.total_tokens || 0;

            console.log('[OpenAITextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[OpenAITextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/text/OpenRouterTextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { OpenRouterBaseAdapter } from '../base/OpenRouterBaseAdapter';

export class OpenRouterTextAdapter extends OpenRouterBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'x-ai/grok-beta';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[OpenRouterTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[OpenRouterTextAdapter] Sending request:', {
            endpoint: 'chat/completions',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('chat/completions', body, 'POST');

            if (!data.choices || !Array.isArray(data.choices) || !data.choices[0]?.message?.content) {
                console.error('[OpenRouterTextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected OpenRouter API response format');
            }

            const output = data.choices[0].message.content.trim();
            const tokensUsed = data.usage?.total_tokens || 0;

            console.log('[OpenRouterTextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[OpenRouterTextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/text/AnthropicTextAdapter.ts =====

// src/adapters/text/AnthropicTextAdapter.ts
import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { AnthropicBaseAdapter } from '../base/AnthropicBaseAdapter';

export class AnthropicTextAdapter extends AnthropicBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'claude-3-5-sonnet-20241022';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[AnthropicTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[AnthropicTextAdapter] Sending request:', {
            endpoint: 'messages',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('messages', body, 'POST');

            if (!data.content || !Array.isArray(data.content) || !data.content[0]?.text) {
                console.error('[AnthropicTextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected Anthropic API response format');
            }

            const output = data.content[0].text.trim();
            const tokensUsed = (data.usage?.output_tokens || 0) + (data.usage?.input_tokens || 0);

            console.log('[AnthropicTextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[AnthropicTextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/text/GroqTextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { GroqBaseAdapter } from '../base/GroqBaseAdapter';

export class GroqTextAdapter extends GroqBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'llama3-8b-8192';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[GroqTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[GroqTextAdapter] Sending request:', {
            endpoint: 'chat/completions',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('chat/completions', body, 'POST');

            if (!data.choices || !Array.isArray(data.choices) || !data.choices[0]?.message?.content) {
                console.error('[GroqTextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected Groq API response format');
            }

            const output = data.choices[0].message.content.trim();
            const tokensUsed = data.usage?.total_tokens || 0;

            console.log('[GroqTextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[GroqTextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/base/OpenRouterBaseAdapter.ts =====

import { requestUrl } from 'obsidian';

export abstract class OpenRouterBaseAdapter {
    protected apiKey: string;
    public providerKey = 'openrouter';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://openrouter.ai/api/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your OpenRouter API key at https://openrouter.ai/keys.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your OpenRouter quota at https://openrouter.ai/account.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://openrouter.ai/account.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at OpenRouter. Try again later or contact OpenRouter support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await OpenRouterBaseAdapter.fetchModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }

    public static async fetchModels(apiKey: string): Promise<string[]> {
        try {
            if (!apiKey) {
                throw new Error(`[OpenRouterBaseAdapter] API key is required for fetching models.`);
            }
            const url = 'https://openrouter.ai/api/v1/models';
            console.log(`[OpenRouterBaseAdapter] Sending model fetch request:`, {
                url,
                headers: { Authorization: `Bearer ${apiKey.trim()}` }
            });

            const response = await requestUrl({
                url,
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${apiKey.trim()}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.status >= 400) {
                let errorMessage = `openrouter error: ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log(`[OpenRouterBaseAdapter] Error response body:`, errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your OpenRouter API key at https://openrouter.ai/keys.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://openrouter.ai/account.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const models = (response.json as { data: { id: string }[] }).data
                ?.map(m => m.id)
                .sort() ?? [];
            console.log(`[OpenRouterBaseAdapter] Fetched models:`, models);
            return models;
        } catch (error) {
            console.error(`[OpenRouterBaseAdapter] Model fetch error:`, error);
            throw error;
        }
    }
}
===== src/adapters/base/StabilityAIBaseAdapter.ts =====

import { requestUrl } from 'obsidian';

export abstract class StabilityAIBaseAdapter {
    protected apiKey: string;
    public providerKey = 'stabilityai';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://api.stability.ai/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your StabilityAI API key at https://platform.stability.ai/account/keys.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your StabilityAI quota at https://platform.stability.ai/account/credits.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://platform.stability.ai/account.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at StabilityAI. Try again later or contact StabilityAI support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await StabilityAIBaseAdapter.fetchModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }

    public static async fetchModels(apiKey: string): Promise<string[]> {
        try {
            if (!apiKey) {
                throw new Error(`[StabilityAIBaseAdapter] API key is required for fetching models.`);
            }
            const url = 'https://api.stability.ai/v1/engines/list';
            console.log(`[StabilityAIBaseAdapter] Sending model fetch request:`, {
                url,
                headers: { Authorization: `Bearer ${apiKey.trim()}` }
            });

            const response = await requestUrl({
                url,
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${apiKey.trim()}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.status >= 400) {
                let errorMessage = `stabilityai error: ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log(`[StabilityAIBaseAdapter] Error response body:`, errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your StabilityAI API key at https://platform.stability.ai/account/keys.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://platform.stability.ai/account.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const models = (response.json as { id: string }[])
                ?.map(m => m.id)
                .filter(id => id.includes('stable-diffusion'))
                .sort() ?? [];
            console.log(`[StabilityAIBaseAdapter] Fetched models:`, models);
            return models;
        } catch (error) {
            console.error(`[StabilityAIBaseAdapter] Model fetch error:`, error);
            throw error;
        }
    }
}
===== src/adapters/base/AnthropicBaseAdapter.ts =====

import { requestUrl } from 'obsidian';
import type { LLMRequest, LLMResponse } from '../../core/Adapter';

export abstract class AnthropicBaseAdapter {
    protected apiKey: string;
    protected apiVersion = '2023-06-01';
    public providerKey = 'anthropic';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://api.anthropic.com/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    'x-api-key': this.apiKey,
                    'Content-Type': 'application/json',
                    'anthropic-version': this.apiVersion,
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;
        try {
            const availableModels = await AnthropicBaseAdapter.fetchModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);
            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }

    public static async fetchModels(apiKey: string): Promise<string[]> {
        const models: string[] = [];
        let hasMore = true;
        let afterId: string | null = null;
        const limit = 100;
        const apiVersion = '2023-06-01';

        try {
            if (!apiKey) {
                throw new Error(`[AnthropicBaseAdapter] API key is required for fetching models.`);
            }

            while (hasMore) {
                const url = new URL('https://api.anthropic.com/v1/models');
                url.searchParams.append('limit', limit.toString());
                if (afterId) {
                    url.searchParams.append('after_id', afterId);
                }

                console.log(`[AnthropicBaseAdapter] Sending model fetch request:`, {
                    url: url.toString(),
                    headers: { 'x-api-key': '[REDACTED]', 'anthropic-version': apiVersion }
                });

                const response = await requestUrl({
                    url: url.toString(),
                    method: 'GET',
                    headers: {
                        'x-api-key': apiKey.trim(),
                        'anthropic-version': apiVersion
                    }
                });

                if (response.status >= 400) {
                    let errorMessage = `anthropic error: ${response.status}`;
                    try {
                        const errorBody = response.json?.error?.message || response.text || 'No additional details';
                        console.log(`[AnthropicBaseAdapter] Error response body:`, errorBody);
                        errorMessage += ` - ${errorBody}`;
                        if (response.status === 401) {
                            errorMessage += '. Invalid API key.';
                        }
                    } catch {
                        errorMessage += ' - Failed to parse error details';
                    }
                    throw new Error(errorMessage);
                }

                const data = response.json as { data: { id: string }[], has_more: boolean, last_id: string | null };
                
                if (!data.data || !Array.isArray(data.data)) {
                    console.error(`[AnthropicBaseAdapter] Unexpected response format:`, data);
                    throw new Error('Unexpected API response format');
                }
                
                const modelIds = data.data.map(m => m.id);
                models.push(...modelIds);
                
                hasMore = data.has_more;
                afterId = data.last_id;

                console.log(`[AnthropicBaseAdapter] Fetched models:`, modelIds, 'Has more:', hasMore);
                
                if (!hasMore || !afterId) break;
            }

            return models;
        } catch (error) {
            console.error(`[AnthropicBaseAdapter] Model fetch error:`, error);
            throw error;
        }
    }
}
===== src/adapters/base/GrokBaseAdapter.ts =====

import { requestUrl } from 'obsidian';

export abstract class GrokBaseAdapter {
    protected apiKey: string;
    public providerKey = 'grok';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://api.x.ai/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your xAI API key in settings at https://x.ai/api.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your xAI account at https://x.ai/api.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://x.ai/api.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at xAI. Try again later or contact xAI support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await GrokBaseAdapter.fetchModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }

    public static async fetchModels(apiKey: string): Promise<string[]> {
        try {
            if (!apiKey) {
                throw new Error(`[GrokBaseAdapter] API key is required for fetching models.`);
            }
            const url = 'https://api.x.ai/v1/models';
            console.log(`[GrokBaseAdapter] Sending model fetch request:`, {
                url,
                headers: { Authorization: `Bearer ${apiKey.trim()}` }
            });

            const response = await requestUrl({
                url,
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${apiKey.trim()}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.status >= 400) {
                let errorMessage = `grok error: ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log(`[GrokBaseAdapter] Error response body:`, errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 403) {
                        errorMessage += '. Check your API key, permissions, or account status at console.x.ai.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const models = (response.json as { data: { id: string }[] }).data?.map(m => m.id).sort() ?? [];
            console.log(`[GrokBaseAdapter] Fetched models:`, models);
            return models;
        } catch (error) {
            console.error(`[GrokBaseAdapter] Model fetch error:`, error);
            throw error;
        }
    }
}
===== src/adapters/base/GeminiBaseAdapter.ts =====

import { requestUrl } from 'obsidian';

export abstract class GeminiBaseAdapter {
    protected apiKey: string;
    protected apiVersions = ['v1', 'v1beta'];
    public providerKey = 'gemini';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST', apiVersion: string = 'v1'): Promise<any> {
        const url = `https://generativelanguage.googleapis.com/${apiVersion}/${endpoint}?key=${this.apiKey}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your Gemini API key in settings at https://aistudio.google.com/app/apikey.';
                    } else if (response.status === 404) {
                        errorMessage += `. Endpoint incorrect for API version ${apiVersion} (tried ${url}). Check available models or region restrictions at https://ai.google.dev/docs.`;
                    } else if (response.status === 400) {
                        errorMessage += '. Invalid request parameters. Check prompt or model configuration.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your Gemini API quota at https://aistudio.google.com/app/apikey.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://aistudio.google.com/app/apikey.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at Google. Try again later or contact Google AI support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await GeminiBaseAdapter.fetchModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            const normalizedModels = availableModels.map(m => m.replace(/^models\//, ''));
            if (normalizedModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (normalizedModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (normalizedModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, normalizedModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }

    public static async fetchModels(apiKey: string): Promise<string[]> {
        try {
            if (!apiKey) {
                throw new Error(`[GeminiBaseAdapter] API key is required for fetching models.`);
            }
            const apiVersions = ['v1', 'v1beta'];
            let lastError: Error | null = null;

            for (const apiVersion of apiVersions) {
                const url = `https://generativelanguage.googleapis.com/${apiVersion}/models?key=${apiKey.trim()}`;
                console.log(`[GeminiBaseAdapter] Fetching models with URL:`, url);

                try {
                    const resp = await requestUrl({
                        url,
                        method: 'GET',
                    });

                    if (resp.status !== 200) {
                        throw new Error(`Failed to fetch Gemini models: ${resp.status} - ${resp.text || 'No details'}`);
                    }

                    const data = resp.json as { models: { name: string }[] };
                    const models = data.models
                        .map(m => m.name.replace(/^models\//, ''))
                        .filter(m => m.startsWith('gemini')); // Only include Gemini models
                    console.log(`[GeminiBaseAdapter] Fetched models:`, models);
                    return models;
                } catch (error) {
                    console.error(`[GeminiBaseAdapter] Error for API version ${apiVersion}:`, error);
                    lastError = error;
                    continue;
                }
            }

            throw lastError || new Error('Failed to fetch models with all API versions');
        } catch (error) {
            console.error(`[GeminiBaseAdapter] Model fetch error:`, error);
            return ['gemini-1.5-pro-latest', 'gemini-1.5-flash-latest']; // Fallback models
        }
    }
}
===== src/adapters/base/OpenAIBaseAdapter.ts =====

import { requestUrl } from 'obsidian';

export abstract class OpenAIBaseAdapter {
    protected apiKey: string;
    public providerKey = 'openai';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://api.openai.com/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your OpenAI API key at https://platform.openai.com/account/api-keys.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your OpenAI quota at https://platform.openai.com/account/usage.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://platform.openai.com/account.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at OpenAI. Try again later or contact OpenAI support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await OpenAIBaseAdapter.fetchModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }

    public static async fetchModels(apiKey: string): Promise<string[]> {
        try {
            if (!apiKey) {
                throw new Error(`[OpenAIBaseAdapter] API key is required for fetching models.`);
            }
            const url = 'https://api.openai.com/v1/models';
            console.log(`[OpenAIBaseAdapter] Sending model fetch request:`, {
                url,
                headers: { Authorization: `Bearer ${apiKey.trim()}` }
            });

            const response = await requestUrl({
                url,
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${apiKey.trim()}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.status >= 400) {
                let errorMessage = `openai error: ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log(`[OpenAIBaseAdapter] Error response body:`, errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your OpenAI API key at https://platform.openai.com/account/api-keys.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://platform.openai.com/account.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const models = (response.json as { data: { id: string }[] }).data
                ?.map(m => m.id)
                .filter(id => id.startsWith('gpt-') || id.startsWith('chatgpt-'))
                .sort() ?? [];
            console.log(`[OpenAIBaseAdapter] Fetched models:`, models);
            return models;
        } catch (error) {
            console.error(`[OpenAIBaseAdapter] Model fetch error:`, error);
            throw error;
        }
    }
}
===== src/adapters/base/GroqBaseAdapter.ts =====

import { requestUrl } from 'obsidian';

export abstract class GroqBaseAdapter {
    protected apiKey: string;
    public providerKey = 'groq';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://api.groq.com/openai/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your Groq API key at https://console.groq.com/keys.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your Groq quota at https://console.groq.com.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://console.groq.com.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at Groq. Try again later or contact Groq support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await GroqBaseAdapter.fetchModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }

    public static async fetchModels(apiKey: string): Promise<string[]> {
        try {
            if (!apiKey) {
                throw new Error(`[GroqBaseAdapter] API key is required for fetching models.`);
            }
            const url = 'https://api.groq.com/openai/v1/models';
            console.log(`[GroqBaseAdapter] Sending model fetch request:`, {
                url,
                headers: { Authorization: `Bearer ${apiKey.trim()}` }
            });

            const response = await requestUrl({
                url,
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${apiKey.trim()}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.status >= 400) {
                let errorMessage = `groq error: ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log(`[GroqBaseAdapter] Error response body:`, errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your Groq API key at https://console.groq.com/keys.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://console.groq.com.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const models = (response.json as { data: { id: string }[] }).data?.map(m => m.id).sort() ?? [];
            console.log(`[GroqBaseAdapter] Fetched models:`, models);
            return models;
        } catch (error) {
            console.error(`[GroqBaseAdapter] Model fetch error:`, error);
            throw error;
        }
    }
}
===== src/gateways/ImageGateway.ts =====

// src/gateways/ImageGateway.ts
import type { SecretsManager } from '../utils/secrets';
import type { MyPluginSettings } from '../settings/types';
import { providerMetadata } from '../settings/providers/index';
import type { ImageAdapter, ImageRequest, ImageResponse } from '../core/Adapter';
import { OpenAIImageAdapter } from '../adapters/image/OpenAIImageAdapter';

export class ImageGateway {
  private adapters: Record<string, ImageAdapter> = {};

  private constructor(
    private defaultProvider: string,
    private backupProvider: string
  ) {}

  static async create(
    secrets: SecretsManager,
    settings: MyPluginSettings
  ): Promise<ImageGateway> {
    const gw = new ImageGateway(
      settings.categories.image.defaultProvider,
      settings.categories.image.backupProvider
    );

    for (const key of Object.keys(settings.providers)) {
      if (!['openai', 'stabilityai', 'grok'].includes(key)) {
        console.warn(`[ImageGateway] Skipping provider ${key}: Not an image-capable provider.`);
        continue;
      }

      if (!providerMetadata[key]) {
        console.warn(`[ImageGateway] Skipping provider ${key}: Not found in providerMetadata.`);
        continue;
      }

      const model = settings.providers[key].model;
      let apiKey: string | undefined;

      if (providerMetadata[key].requiresApiKey) {
        apiKey = await secrets.getSecret(key);
        if (!apiKey) {
          console.warn(`[ImageGateway] No API key found for ${key}. Skipping adapter.`);
          continue;
        }
      }

      let adapter: ImageAdapter;
      switch (key) {
        case 'openai':
          adapter = new OpenAIImageAdapter(apiKey!, model);
          break;
        default:
          console.warn(`[ImageGateway] Unsupported image provider: ${key}`);
          continue;
      }

      console.log(`[ImageGateway] Adapter created for ${key} with model: ${model}`);
      gw.adapters[key] = adapter;
    }

    console.log('[ImageGateway] Initialized adapters:', Object.keys(gw.adapters));
    return gw;
  }

  async generate(request: ImageRequest): Promise<ImageResponse> {
    const primary = this.adapters[this.defaultProvider];
    try {
      if (!primary) {
        throw new Error(`No adapter found for default provider: ${this.defaultProvider}`);
      }
      return await primary.generate(request);
    } catch (err) {
      if (this.backupProvider && this.adapters[this.backupProvider]) {
        console.log(`[ImageGateway] Falling back to backup provider: ${this.backupProvider}`);
        return await this.adapters[this.backupProvider].generate(request);
      }
      throw err;
    }
  }
}
===== src/gateways/TextGateway.ts =====

import type { SecretsManager } from '../utils/secrets';
import type { MyPluginSettings } from '../settings/types';
import { providerMetadata } from '../settings/providers/index';
import type { LLMAdapter, LLMRequest } from '../core/Adapter';
import { OpenAITextAdapter } from '../adapters/text/OpenAITextAdapter';
import { AnthropicTextAdapter } from '../adapters/text/AnthropicTextAdapter'; // Fixed import
import { GrokTextAdapter } from '../adapters/text/GrokTextAdapter';
import { OpenRouterTextAdapter } from '../adapters/text/OpenRouterTextAdapter';
import { GeminiTextAdapter } from '../adapters/text/GeminiTextAdapter';
import { GroqTextAdapter } from '../adapters/text/GroqTextAdapter';

export class TextGateway {
  private adapters: Record<string, LLMAdapter> = {};

  private constructor(
    private defaultProvider: string,
    private backupProvider: string
  ) {}

  /** Factory that reads your settings & secrets and instantiates one adapter per provider */
  static async create(
    secrets: SecretsManager,
    settings: MyPluginSettings
  ): Promise<TextGateway> {
    const gw = new TextGateway(
      settings.categories.text.defaultProvider,
      settings.categories.text.backupProvider
    );

    for (const key of Object.keys(settings.providers)) {
      const model = settings.providers[key].model;
      let apiKey: string | undefined;

      // Grab the key if needed
      if (providerMetadata[key].requiresApiKey) {
        apiKey = await secrets.getSecret(key);
        if (!apiKey) {
          console.warn(`[TextGateway] No API key found for ${key}. Skipping adapter.`);
          continue;
        }
      }

      // Instantiate the right adapter
      let adapter: LLMAdapter;
      switch (key) {
        case 'openai':
          adapter = new OpenAITextAdapter(apiKey!, model);
          break;
        case 'anthropic':
          adapter = new AnthropicTextAdapter(apiKey!, model);
          break;
        case 'grok':
          adapter = new GrokTextAdapter(apiKey!, model);
          break;
        case 'openrouter':
          adapter = new OpenRouterTextAdapter(apiKey!, model);
          break;
        case 'gemini':
          adapter = new GeminiTextAdapter(apiKey!, model);
          break;
        case 'groq':
          adapter = new GroqTextAdapter(apiKey!, model);
          break;
        default:
          console.warn(`[TextGateway] Unsupported provider: ${key}`);
          continue; // skip unsupported
      }

      console.log(`[TextGateway] Adapter created for ${key} with model: ${model}`);
      gw.adapters[key] = adapter;
    }

    console.log('[TextGateway] Initialized adapters:', Object.keys(gw.adapters));
    return gw;
  }

  /** Single entry point: try default, then fallback */
  async generate(request: LLMRequest): Promise<string> {
    const primary = this.adapters[this.defaultProvider];
    try {
      if (!primary) {
        throw new Error(`No adapter found for default provider: ${this.defaultProvider}`);
      }
      const res = await primary.generate(request);
      return res.output;
    } catch (err) {
      if (
        this.backupProvider &&
        this.adapters[this.backupProvider]
      ) {
        console.log(`[TextGateway] Falling back to backup provider: ${this.backupProvider}`);
        const fallback = await this.adapters[
          this.backupProvider
        ].generate(request);
        return fallback.output;
      }
      throw err;
    }
  }
}
===== src/gateways/VisionGateway.ts =====


===== src/gateways/VideoGateway.ts =====


===== src/gateways/SpeechGateway.ts =====


===== src/gateways/ThreeDGateway.ts =====


===== src/api/aiNNS.ts =====

import type { App } from 'obsidian';
import type { SecretsManager } from '../utils/secrets';
import type { MyPluginSettings } from '../settings/types';

import { TextGateway } from '../gateways/TextGateway';
//import { ImageGateway } from '../gateways/ImageGateway';
//import { SpeechGateway } from '../gateways/SpeechGateway';
//import { VideoGateway } from '../gateways/VideoGateway';
//import { VisionGateway } from '../gateways/VisionGateway';

/* ---------------------------------- *
 * Interfaces for Each AI Modality   *
 * ---------------------------------- */
export interface TextAPI {
  generate(
    prompt: string,
    opts?: {
      model?: string;
      temperature?: number;
      maxTokens?: number;
    }
  ): Promise<string>;
}

export interface ImageAPI {
  generate(
    prompt: string,
    opts?: {
      model?: string;
      width?: number;
      height?: number;
    }
  ): Promise<string>;
}

export interface SpeechAPI {
  synthesize(
    text: string,
    opts?: {
      voice?: string;
      format?: string;
    }
  ): Promise<string>;

  recognize(
    audioData: ArrayBuffer,
    opts?: {
      model?: string;
    }
  ): Promise<string>;
}

export interface VideoAPI {
  generate(
    prompt: string,
    opts?: {
      model?: string;
      durationSeconds?: number;
    }
  ): Promise<string>;

  caption(
    videoData: ArrayBuffer,
    opts?: {
      model?: string;
    }
  ): Promise<string>;
}

export interface VisionAPI {
  caption(
    imageData: ArrayBuffer,
    opts?: {
      model?: string;
    }
  ): Promise<string>;
}

/* ---------------------------------- *
 * Global Window Interface Extension *
 * ---------------------------------- */
declare global {
  interface Window {
    aiNNS?: {
      text: TextAPI;
      //image: ImageAPI;
      //speech: SpeechAPI;
     // video: VideoAPI;
      //vision: VisionAPI;
    };
  }
}

/* ---------------------------------- *
 * Register aiNNS on Global Scope    *
 * ---------------------------------- */
export async function registerAiNNS(
  app: App,
  secrets: SecretsManager,
  settings: MyPluginSettings
) {
  const textGw = await TextGateway.create(secrets, settings);
  //const imageGw = new ImageGateway(secrets, settings);
  //const speechGw = new SpeechGateway(secrets, settings);
  //const videoGw = new VideoGateway(secrets, settings);
  //const visionGw = new VisionGateway(secrets, settings);

  window.aiNNS = {
    text: {
      generate: (prompt, opts) =>
        textGw.generate({ prompt, ...opts }),
    },/*
    image: {
      generate: (prompt, opts) =>
        imageGw.generate({ prompt, ...opts }),
    },
    speech: {
      synthesize: (text, opts) =>
        speechGw.synthesize({ text, ...opts }),
      recognize: (audioData, opts) =>
        speechGw.recognize({ audioData, ...opts }),
    },
    video: {
      generate: (prompt, opts) =>
        videoGw.generate({ prompt, ...opts }),
      caption: (videoData, opts) =>
        videoGw.caption({ videoData, ...opts }),
    },
    vision: {
      caption: (imageData, opts) =>
        visionGw.caption({ imageData, ...opts }),
    },*/
  };
}

/* ---------------------------------- *
 * Cleanup aiNNS on Plugin Unload    *
 * ---------------------------------- */
export function unregisterAiNNS() {
  delete window.aiNNS;
}
