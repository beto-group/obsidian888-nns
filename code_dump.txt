
===== main.ts =====

import {
    App,
    Editor,
    MarkdownView,
    Modal,
    Notice,
    Plugin
} from 'obsidian';

import { SampleSettingTab } from './src/settings/settings';
import { DEFAULT_SETTINGS } from './src/settings/defaults';
import { MyPluginSettings } from './src/settings/types';
import { SecretsManager } from './src/utils/secrets';
import { AiConsoleModal } from './src/ui/console/AiConsoleModal';
import { registerAiNNS, unregisterAiNNS } from './src/api/aiNNS';

/**
 * Main Plugin Class
 */
export default class MyPlugin extends Plugin {
    settings: MyPluginSettings;
    secrets: SecretsManager;

    /**
     * Plugin entry point
     */
    async onload() {
        console.log('[MyPlugin] Loading plugin...');

        // Initialize SecretsManager and wait for it to load secrets from file
        this.secrets = new SecretsManager(this.app);
        await this.secrets.initialize();

        // Log stored secrets for debugging
        try {
            const storedSecrets = await this.secrets.listSecrets();
            console.log('[MyPlugin] Stored secret keys on load:', storedSecrets);
        } catch (error) {
            console.error("[MyPlugin] Error listing secrets on load:", error);
        }

        // Load plugin settings
        await this.loadSettings();

        // Example usage: Try to get a secret
        try {
            const openai = await this.secrets.getSecret("openai");
            if (openai) {
                console.log("[MyPlugin] Found OpenAI Secret on load (length):", openai.length);
            }
        } catch (error) {
            console.error("[MyPlugin] Error getting OpenAI secret on load:", error);
        }

        // Register aiNNS API on global scope
        try {
            await registerAiNNS(this.app, this.secrets, this.settings);
            console.log('[MyPlugin] aiNNS API registered successfully.');
        } catch (error) {
            console.error('[MyPlugin] Error registering aiNNS API:', error);
        }

        // --- UI and Commands ---

        // Add ribbon icon (opens AI Console)
        const ribbonIconEl = this.addRibbonIcon('rocket', 'Open AI Console', (evt: MouseEvent) => {
            try {
                new AiConsoleModal(this.app, this.settings, this.secrets).open();
            } catch (error) {
                console.error('[MyPlugin] Error opening AiConsoleModal from ribbon:', error);
                new Notice('Failed to open AI Console Modal.');
            }
        });
        ribbonIconEl.addClass('my-plugin-ribbon-class');

        // Add status bar item
        const statusBarItemEl = this.addStatusBarItem();
        statusBarItemEl.setText('Status Bar Text');

        // Simple modal command
        this.addCommand({
            id: 'open-sample-modal-simple',
            name: 'Open sample modal (simple)',
            callback: () => {
                new SampleModal(this.app).open();
            }
        });

        // Editor command
        this.addCommand({
            id: 'sample-editor-command',
            name: 'Sample editor command',
            editorCallback: (editor: Editor, view: MarkdownView) => {
                console.log('[MyPlugin] Selected Text:', editor.getSelection());
                editor.replaceSelection('Sample Editor Command');
            }
        });

        // Complex checkable command
        this.addCommand({
            id: 'open-sample-modal-complex',
            name: 'Open sample modal (complex)',
            checkCallback: (checking: boolean) => {
                const markdownView = this.app.workspace.getActiveViewOfType(MarkdownView);
                if (markdownView) {
                    if (!checking) {
                        new SampleModal(this.app).open();
                    }
                    return true;
                }
                return false;
            }
        });

        // Add command to open AiConsoleModal
        this.addCommand({
            id: 'open-ai-console-modal',
            name: 'Open AI Console Modal',
            callback: () => {
                try {
                    new AiConsoleModal(this.app, this.settings, this.secrets).open();
                } catch (error) {
                    console.error('[MyPlugin] Error opening AiConsoleModal:', error);
                    new Notice('Failed to open AI Console Modal.');
                }
            }
        });

        // Add settings tab
        this.addSettingTab(new SampleSettingTab(this.app, this, this.secrets));

        // Register global DOM event
        this.registerDomEvent(document, 'click', (evt: MouseEvent) => {
            // console.log('[MyPlugin] DOM click', evt);
        });

        // Register interval task
        this.registerInterval(window.setInterval(() => {
            // console.log('[MyPlugin] Interval running');
        }, 5 * 60 * 1000));

        console.log('[MyPlugin] Plugin loaded successfully.');
    }

    /**
     * Called when plugin is unloaded
     */
    onunload() {
        console.log('[MyPlugin] Unloaded');
        // Unregister aiNNS API to clean up global scope
        unregisterAiNNS();
    }

    /**
     * Load plugin settings
     */
    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    /**
     * Save plugin settings
     */
    async saveSettings() {
        await this.saveData(this.settings);
    }
}

/**
 * Basic modal class
 */
class SampleModal extends Modal {
    constructor(app: App) {
        super(app);
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.setText('Woah!');
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

===== src/types.ts =====


===== src/ui/components/TabComponent.ts =====

import { App, setIcon } from 'obsidian';
import { consoleCSS } from '../console/styles/consoleStyles';

/**
 * Interface for a tab in the TabComponent.
 */
export interface Tab {
  id: string;
  name: string;
  render(container: HTMLElement): void;
  cleanup(): void;
}

/**
 * Configuration for a tab, including its icon.
 */
export interface TabConfig {
  tab: Tab;
  icon: string;
}

/**
 * Reusable TabComponent for managing and rendering tabs.
 */
export class TabComponent {
  private activeTabId: string;
  private container: HTMLElement | null = null;
  private tabContentContainer: HTMLElement | null = null;
  private styleElement: HTMLStyleElement | null = null;

  constructor(
    private app: App,
    private tabs: TabConfig[],
    initialTabId: string
  ) {
    this.activeTabId = tabs.some(t => t.tab.id === initialTabId) ? initialTabId : tabs[0]?.tab.id;
  }

  /**
   * Renders the tab selector and content area into the provided container.
   */
  render(container: HTMLElement): void {
    this.container = container;

    // Inject CSS styles
    this.styleElement = document.createElement('style');
    this.styleElement.textContent = consoleCSS;
    document.head.appendChild(this.styleElement);

    // Create tab selector
    const tabSelector = this.container.createEl('div', { cls: 'ai-console-tab-selector' });

    // Render tab buttons
    this.tabs.forEach(({ tab, icon }) => {
      const isActive = tab.id === this.activeTabId;
      const tabButton = tabSelector.createEl('button', {
        cls: `ai-console-tab-button${isActive ? ' active' : ''}`,
      });
    
      // Use the icon from TabConfig
      const iconEl = tabButton.createEl('span', { cls: 'ai-console-tab-icon' });
      setIcon(iconEl, icon);
    
      // Add label with proper spacing
      tabButton.createSpan({ cls: 'ai-console-tab-label', text: tab.name.split(' ')[0] });
    
      // Handle click
      tabButton.addEventListener('click', () => this.switchTab(tab.id));
    });

    // Create content container
    this.tabContentContainer = this.container.createEl('div', { cls: 'ai-console-tab-content' });

    // Render initial active tab
    this.renderActiveTab();
  }

  /**
Interp   * Switches to the specified tab and re-renders the content.
   */
  private switchTab(tabId: string): void {
    if (tabId === this.activeTabId) return;
    this.activeTabId = tabId;
    this.renderActiveTab();
  }

  /**
   * Renders the content of the active tab and updates button states.
   */
  private renderActiveTab(): void {
    if (!this.container || !this.tabContentContainer) return;

    // Update button states
    const buttons = this.container.querySelectorAll('.ai-console-tab-button');
    const activeTabName = this.tabs.find(t => t.tab.id === this.activeTabId)?.tab.name.split(' ')[0] || '';

    buttons.forEach(button => {
      const buttonLabel = button.querySelector('.ai-console-tab-label')?.textContent || '';
      const isActive = buttonLabel === activeTabName;
      button.classList.toggle('active', isActive);
    });

    // Clear and render active tab content
    this.tabContentContainer.empty();
    const activeTab = this.tabs.find(t => t.tab.id === this.activeTabId)?.tab;
    if (activeTab) {
      activeTab.render(this.tabContentContainer);
    }
  }

  /**
   * Cleans up the component, including styles and tab content.
   */
  cleanup(): void {
    this.tabs.forEach(({ tab }) => tab.cleanup());
    if (this.container) {
      this.container.empty();
    }
    if (this.styleElement && this.styleElement.parentNode) {
      this.styleElement.parentNode.removeChild(this.styleElement);
    }
    this.container = null;
    this.tabContentContainer = null;
    this.styleElement = null;
  }

  /**
   * Gets the ID of the currently active tab.
   */
  getActiveTabId(): string {
    return this.activeTabId;
  }
}
===== src/ui/console/AiConsoleModal.ts =====

import { App, Modal, Notice } from 'obsidian';
import type { MyPluginSettings } from '../../settings/types';
import type { SecretsManager } from '../../utils/secrets';
import { TextConsoleTab } from './tabs/TextConsoleTab';
import { ImageConsoleTab } from './tabs/ImageConsoleTab';
import { VideoConsoleTab } from './tabs/VideoConsoleTab';
import { AudioConsoleTab } from './tabs/AudioConsoleTab';
import { OcrConsoleTab } from './tabs/OcrConsoleTab';
import { ThreeDConsoleTab } from './tabs/ThreeDConsoleTab';
import { TabComponent, TabConfig } from '../components/TabComponent';

interface PromptHistoryEntry {
  provider: string;
  model: string;
  prompt: string;
  output: string;
  timestamp: string;
}

interface ConsoleTab {
  id: string;
  name: string;
  icon: string;
  render(container: HTMLElement): void;
  cleanup(): void;
  renderHistory?(history: PromptHistoryEntry[]): void;
}

export class AiConsoleModal extends Modal {
  private settings: MyPluginSettings;
  private secrets: SecretsManager;
  private tabs: ConsoleTab[] = [];
  private tabComponent: TabComponent;
  private history: PromptHistoryEntry[] = [];
  private maxHistoryEntries = 10;

  constructor(app: App, settings: MyPluginSettings, secrets: SecretsManager) {
    super(app);
    this.settings = settings;
    this.secrets = secrets;
    this.initializeTabs();
    const tabConfigs: TabConfig[] = this.tabs.map(tab => ({
      tab,
      icon: tab.icon
    }));
    this.tabComponent = new TabComponent(this.app, tabConfigs, 'text');
  }

  private initializeTabs() {
    this.tabs = [
      new TextConsoleTab(this.app, this.settings, this.secrets, this.addToHistory.bind(this), this.renderHistory.bind(this)),
      new ImageConsoleTab(this.app, this.settings, this.secrets),
      new VideoConsoleTab(this.app, this.settings, this.secrets),
      new AudioConsoleTab(this.app, this.settings, this.secrets),
      new OcrConsoleTab(this.app, this.settings, this.secrets),
      new ThreeDConsoleTab(this.app, this.settings, this.secrets)
    ];
  }

  onOpen() {
    console.log('[AiConsoleModal] Opening modal...');
    this.titleEl.setText('AI Console Playground');
    this.contentEl.empty();
    const container = this.contentEl.createEl('div', { cls: 'ai-console-container' });
    this.tabComponent.render(container);
  }

  private addToHistory(entry: PromptHistoryEntry) {
    this.history.unshift(entry);
    if (this.history.length > this.maxHistoryEntries) {
      this.history.pop();
    }
    this.renderHistory();
  }

  public renderHistory() {
    const activeTab = this.tabs.find(tab => tab.id === this.tabComponent.getActiveTabId());
    if (activeTab && activeTab.renderHistory) {
      activeTab.renderHistory(this.history);
    }
  }

  onClose() {
    this.tabComponent.cleanup();
    console.log('[AiConsoleModal] Modal closed.');
  }
}
===== src/ui/console/tabs/ImageConsoleTab.ts =====

// src/ui/console/tabs/ImageConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';

export class ImageConsoleTab {
  id = 'image';
  name = 'Image Playground';
  icon = 'image';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'Image Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/ThreeDConsoleTab.ts =====

import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';

export class ThreeDConsoleTab {
  id = '3d';
  name = '3D Playground';
  icon = 'cube';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: '3D Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/VideoConsoleTab.ts =====

// src/ui/console/tabs/VideoConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';

export class VideoConsoleTab {
  id = 'video';
  name = 'Video Playground';
  icon = 'film';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'Video Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/TextConsoleTab.ts =====

// src/ui/console/tabs/TextConsoleTab.ts
import { App, Notice, Setting, SliderComponent, TextComponent } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';
import { TextGateway } from '../../../gateways/TextGateway';
import type { LLMRequest, LLMResponse } from '../../../core/Adapter';
import { ProviderSelector } from '../sections/ProviderSelector';
import { ParameterControls } from '../sections/ParameterControls';
import { PromptInput } from '../sections/PromptInput';
import { OutputViewer } from '../sections/OutputViewer';
import { PromptHistory } from '../sections/PromptHistory';

interface PromptHistoryEntry {
  provider: string;
  model: string;
  prompt: string;
  output: string;
  timestamp: string;
}

export class TextConsoleTab {
  id = 'text';
  name = 'Text Playground';
  icon = 'file-text';
  private textGateway?: TextGateway;
  private providerSelector: ProviderSelector;
  private parameterControls: ParameterControls;
  private promptInput: PromptInput;
  private outputViewer: OutputViewer;
  private promptHistory: PromptHistory;

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager,
    private addToHistory: (entry: PromptHistoryEntry) => void,
    renderHistory: () => void
  ) {
    this.providerSelector = new ProviderSelector(app, settings, secrets);
    this.parameterControls = new ParameterControls();
    this.promptInput = new PromptInput();
    this.outputViewer = new OutputViewer();
    this.promptHistory = new PromptHistory();
  }

  async render(container: HTMLElement) {
    console.log('[TextConsoleTab] Rendering...');
    try {
      this.textGateway = await TextGateway.create(this.secrets, this.settings);
      console.log('[TextConsoleTab] TextGateway initialized successfully.');
    } catch (error: any) {
      console.error('[TextConsoleTab] Failed to initialize TextGateway:', error);
      new Notice('Failed to initialize Text Console. Some features may be limited.');
      container.createEl('p', { text: 'Error initializing Text Console.' });
    }

    // Render sections
    this.providerSelector.render(container, this.textGateway);
    this.parameterControls.render(container);
    this.promptInput.render(container, this.runPrompt.bind(this));
    this.outputViewer.render(container);
    this.promptHistory.render(container, this.historyClickHandler.bind(this));
  }

  private async runPrompt() {
    console.log('[TextConsoleTab] Run button clicked.');
    const provider = this.providerSelector.getSelectedProvider();
    const model = this.providerSelector.getSelectedModel() || this.settings.providers[provider]?.model || '';
    const prompt = this.promptInput.getPrompt().trim();
    const temperature = this.parameterControls.getTemperature();
    const maxTokens = this.parameterControls.getMaxTokens();

    this.outputViewer.clear();

    if (!prompt) {
      new Notice('Please enter a prompt.');
      return;
    }
    if (!provider) {
      new Notice('Please select a provider.');
      return;
    }
    if (!this.textGateway) {
      new Notice('TextGateway not initialized. Cannot generate response.');
      this.outputViewer.setOutput('Error: TextGateway not initialized.');
      return;
    }

    const request: LLMRequest = { prompt, model, temperature, maxTokens };
    const adapter = (this.textGateway as any).adapters[provider];
    if (!adapter) {
      new Notice(`No adapter found for provider: ${provider}. Please check configuration.`);
      this.outputViewer.setOutput(`Error: No adapter for ${provider}.`);
      console.error('[TextConsoleTab] No adapter found for provider:', provider);
      return;
    }

    try {
      this.outputViewer.setOutput('Generating...');
      console.log('[TextConsoleTab] Testing provider:', provider, 'with request:', {
        prompt: prompt.length > 50 ? prompt.slice(0, 50) + '...' : prompt,
        model,
        temperature,
        maxTokens,
      });

      const result: LLMResponse = await adapter.generate(request);
      let output = '[No result returned]';
      let tokensUsed = 0;

      if (result && typeof result.output === 'string') {
        output = result.output.trim();
        tokensUsed = result.tokensUsed || 0;
      } else {
        console.warn('[TextConsoleTab] Unexpected response format from provider:', provider, result);
        output = '[Unexpected response format]';
      }

      this.outputViewer.setOutput(output);
      this.outputViewer.setCode(`await window.aiNNS.text.generate("${prompt.replace(/"/g, '\\"')}", { model: "${model}", temperature: ${temperature}, maxTokens: ${maxTokens} });`);
      this.addToHistory({ provider, model, prompt, output, timestamp: new Date().toLocaleString() });
      console.log('[TextConsoleTab] Response received for', provider, ':', {
        output: output.length > 50 ? output.slice(0, 50) + '...' : output,
        tokensUsed,
      });
    } catch (error: any) {
      console.error('[TextConsoleTab] Generation error for', provider, ':', error);
      let errorMessage = `Error: ${error.message || 'Unknown error'}`;
      this.outputViewer.setOutput(errorMessage);
      new Notice(`Failed to generate with ${provider}: ${error.message || 'Unknown error'}`);
    }
  }

  private historyClickHandler(entry: PromptHistoryEntry) {
    this.providerSelector.setProvider(entry.provider, entry.model);
    this.promptInput.setPrompt(entry.prompt);
  }

  cleanup() {
    this.providerSelector.cleanup();
    this.parameterControls.cleanup();
    this.promptInput.cleanup();
    this.outputViewer.cleanup();
    this.promptHistory.cleanup();
  }

  renderHistory(history: PromptHistoryEntry[]) {
    this.promptHistory.updateHistory(history, this.historyClickHandler.bind(this));
  }
}
===== src/ui/console/tabs/OcrConsoleTab.ts =====

// src/ui/console/tabs/OcrConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';

export class OcrConsoleTab {
  id = 'ocr';
  name = 'OCR Playground';
  icon = 'scan';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'OCR Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/AudioConsoleTab.ts =====

// src/ui/console/tabs/AudioConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/types';
import type { SecretsManager } from '../../../utils/secrets';

export class AudioConsoleTab {
  id = 'audio';
  name = 'Audio Playground';
  icon = 'volume-2';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'Audio Console (Coming Soon)' });
  }

  cleanup() {}
}

===== src/ui/console/sections/ParameterControls.ts =====

// src/ui/console/sections/ParameterControls.ts
import { Setting, SliderComponent, TextComponent, Notice } from 'obsidian';

export class ParameterControls {
  private temperatureSlider?: SliderComponent;
  private maxTokensInput?: TextComponent;

  render(container: HTMLElement) {
    const paramsContainer = container.createEl('div', { cls: 'ai-console-params' });
    paramsContainer.createEl('h4', { text: 'Parameters' });

    try {
      new Setting(paramsContainer)
        .setName('Temperature')
        .setDesc('Controls randomness (0.0 to 1.0).')
        .addSlider(slider => {
          this.temperatureSlider = slider.setLimits(0, 1, 0.1).setValue(0.7).setDynamicTooltip();
        });
    } catch (error) {
      console.error('[ParameterControls] Error creating temperature slider:', error);
      paramsContainer.createEl('p', { text: 'Error loading temperature slider.' });
    }

    try {
      new Setting(paramsContainer)
        .setName('Max Tokens')
        .setDesc('Maximum number of tokens to generate.')
        .addText(text => {
          this.maxTokensInput = text
            .setPlaceholder('1000')
            .setValue('1000')
            .onChange(value => {
              if (isNaN(parseInt(value)) && value !== '') {
                new Notice('Max Tokens must be a number.');
                text.setValue('1000');
              }
            });
        });
    } catch (error) {
      console.error('[ParameterControls] Error creating max tokens input:', error);
      paramsContainer.createEl('p', { text: 'Error loading max tokens input.' });
    }
  }

  getTemperature(): number {
    try {
      return parseFloat(this.temperatureSlider!.getValue().toString()) || 0.7;
    } catch (error) {
      console.error('[ParameterControls] Error getting temperature:', error);
      return 0.7;
    }
  }

  getMaxTokens(): number {
    try {
      return parseInt(this.maxTokensInput!.getValue()) || 1000;
    } catch (error) {
      console.error('[ParameterControls] Error getting max tokens:', error);
      return 1000;
    }
  }

  cleanup() {
    // No cleanup needed for sliders and inputs
  }
}
===== src/ui/console/sections/ProviderSelector.ts =====

// src/ui/console/sections/ProviderSelector.ts
import { App, Setting, Notice } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/settings';
import type { SecretsManager } from '../../../utils/secrets';
import { providerMetadata, providerFetchers } from '../../../settings/providers/index';
import type { TextGateway } from '../../../gateways/TextGateway';

export class ProviderSelector {
  private providerSelectEl: HTMLSelectElement;
  private modelSelectEl: HTMLSelectElement;
  private providers: string[] = [];

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  async render(container: HTMLElement, textGateway?: TextGateway) {
    const controlsSection = container.createEl('div', { cls: 'ai-console-controls' });
    controlsSection.createEl('h3', { text: 'Settings' });

    this.providers = [];

    try {
      for (const key of Object.keys(this.settings.providers)) {
        const meta = providerMetadata[key];
        if (meta.requiresApiKey) {
          const apiKey = await this.secrets.getSecret(key);
          if (apiKey) this.providers.push(key);
        } else {
          this.providers.push(key);
        }
      }
      console.log('[ProviderSelector] Providers loaded:', this.providers);
    } catch (error) {
      console.error('[ProviderSelector] Error gathering providers:', error);
      new Notice('Failed to load providers. Using fallback options.');
    }

    new Setting(controlsSection)
      .setName('Provider')
      .setDesc('Select the AI provider to use.')
      .addDropdown(dropdown => {
        this.providerSelectEl = dropdown.selectEl;
        if (this.providers.length === 0) {
          dropdown.addOption('', 'No providers available');
        } else {
          this.providers.forEach(p => dropdown.addOption(p, p));
          const initial = this.settings.defaultProvider && this.providers.includes(this.settings.defaultProvider)
            ? this.settings.defaultProvider
            : this.providers[0];
          dropdown.setValue(initial);
          dropdown.onChange(async value => {
            console.log('[ProviderSelector] Provider changed to:', value);
            await this.updateModelDropdown(value);
          });
        }
      });

      const modelSetting = new Setting(controlsSection)
      .setName('Model')
      .setDesc('Select the model for the selected provider.');
    
    modelSetting.controlEl.style.flexDirection = 'column';
    modelSetting.controlEl.style.alignItems = 'stretch';
    
    modelSetting.addDropdown(dropdown => {
      this.modelSelectEl = dropdown.selectEl;
      this.modelSelectEl.style.width = '100%'; // ⬅️ make dropdown full width
      dropdown.setDisabled(this.providers.length === 0);
    });

    if (this.providers.length > 0) {
      try {
        await this.updateModelDropdown(this.providerSelectEl.value);
      } catch (error) {
        console.error('[ProviderSelector] Error populating models:', error);
      }
    }
  }

  private async updateModelDropdown(provider: string) {
    console.log('[ProviderSelector] Updating model dropdown for provider:', provider);
    this.modelSelectEl.innerHTML = '';
    this.modelSelectEl.disabled = true;

    if (!provider || !this.settings.providers[provider]) {
      this.modelSelectEl.add(new Option('No models available', ''));
      return;
    }

    try {
      let models: string[] = [];
      if (providerMetadata[provider].requiresApiKey) {
        const apiKey = await this.secrets.getSecret(provider);
        if (apiKey) {
          models = await providerFetchers[provider](apiKey, this.app);
        }
      } else {
        models = await providerFetchers[provider]('', this.app);
      }

      if (!models.length) {
        this.modelSelectEl.add(new Option('No models available', ''));
        return;
      }

      models.forEach(m => this.modelSelectEl.add(new Option(m, m)));
      const current = this.settings.providers[provider].model;
      this.modelSelectEl.value = models.includes(current) ? current : models[0];
      this.modelSelectEl.disabled = false;
      console.log('[ProviderSelector] Models loaded:', models);
    } catch (error) {
      console.error('[ProviderSelector] Error fetching models:', error);
      this.modelSelectEl.add(new Option('Error fetching models', ''));
    }
  }

  getSelectedProvider(): string {
    return this.providerSelectEl.value;
  }

  getSelectedModel(): string {
    return this.modelSelectEl.value;
  }

  setProvider(provider: string, model: string) {
    if (this.providers.includes(provider)) {
      this.providerSelectEl.value = provider;
      this.updateModelDropdown(provider).then(() => {
        if (this.modelSelectEl.options.length > 0) {
          this.modelSelectEl.value = model;
        }
      });
    }
  }

  cleanup() {
    // No cleanup needed for dropdowns
  }
}
===== src/ui/console/sections/OutputViewer.ts =====

// src/ui/console/sections/OutputViewer.ts
export class OutputViewer {
    private outputArea: HTMLElement;
    private codeBlock: HTMLElement;
  
    render(container: HTMLElement) {
      const outputSection = container.createEl('div', { cls: 'ai-console-output-section' });
      outputSection.createEl('h4', { text: 'Output' });
      this.outputArea = outputSection.createEl('div', { cls: 'ai-console-output' });
      this.codeBlock = outputSection.createEl('pre', { cls: 'ai-console-code' });
    }
  
    setOutput(output: string) {
      this.outputArea.setText(output);
    }
  
    setCode(code: string) {
      this.codeBlock.setText(code);
    }
  
    clear() {
      this.outputArea.empty();
      this.codeBlock.empty();
    }
  
    cleanup() {
      // No cleanup needed for output elements
    }
  }
===== src/ui/console/sections/PromptHistory.ts =====

// src/ui/console/sections/PromptHistory.ts
interface PromptHistoryEntry {
    provider: string;
    model: string;
    prompt: string;
    output: string;
    timestamp: string;
  }
  
  export class PromptHistory {
    private historyContainer: HTMLElement;
    private historyList: HTMLElement;
    private isHistoryVisible: boolean = true;
  
    render(container: HTMLElement, onClick: (entry: PromptHistoryEntry) => void) {
      this.historyContainer = container.createEl('div', { cls: 'ai-console-history' });
      const historyHeader = this.historyContainer.createEl('h4', { text: 'Recent Prompts ▼' });
      this.historyList = this.historyContainer.createEl('ul', { cls: 'ai-console-history-list' });
  
      historyHeader.addEventListener('click', () => {
        this.isHistoryVisible = !this.isHistoryVisible;
        this.historyList.style.display = this.isHistoryVisible ? 'block' : 'none';
        historyHeader.textContent = `Recent Prompts ${this.isHistoryVisible ? '▼' : '▲'}`;
      });
    }
  
    updateHistory(history: PromptHistoryEntry[], onClick: (entry: PromptHistoryEntry) => void) {
      this.historyList.empty();
      history.forEach(entry => {
        const li = this.historyList.createEl('li');
        li.createEl('strong', { text: `[${entry.timestamp}] ${entry.provider} (${entry.model})` });
        li.createEl('br');
        li.createEl('span', { text: `Prompt: ${entry.prompt}${entry.prompt.length > 50 ? '...' : ''}` });
        li.addEventListener('click', () => onClick(entry));
      });
    }
  
    cleanup() {
      this.historyContainer.empty();
    }
  }
===== src/ui/console/sections/PromptInput.ts =====

// src/ui/console/sections/PromptInput.ts
import { Notice } from 'obsidian';

export class PromptInput {
  private promptInput: HTMLTextAreaElement;

  render(container: HTMLElement, onRun: () => void) {
    const promptSection = container.createEl('div', { cls: 'ai-console-prompt-section' });
    this.promptInput = promptSection.createEl('textarea', {
      attr: { placeholder: 'Enter your prompt here...' },
      cls: 'ai-console-prompt'
    }) as HTMLTextAreaElement;

    const runBtn = promptSection.createEl('button', { text: 'Run', cls: 'ai-console-run-btn' });
    runBtn.addEventListener('click', onRun);
  }

  getPrompt(): string {
    return this.promptInput.value;
  }

  setPrompt(prompt: string) {
    this.promptInput.value = prompt;
  }

  cleanup() {
    // No cleanup needed for textarea
  }
}

===== src/ui/console/styles/consoleStyles.ts =====

export const consoleCSS = `
.ai-console-container {
  padding: 20px;
  max-width: 900px;
  margin: auto;
  background: var(--background-primary);
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.ai-console-tab-selector {
  display: flex;
  gap: 0;
  margin-bottom: 0;
  background: #2F2F2F;
  padding: 0;
  border-bottom: 1px solid var(--background-modifier-border);
  flex-wrap: nowrap; /* Prevent wrapping to ensure all tabs are visible */
  overflow-x: auto; /* Allow horizontal scrolling if tabs overflow */
  -webkit-overflow-scrolling: touch; /* Smooth scrolling on touch devices */
}

/* Custom Scrollbar Styling */
.ai-console-tab-selector::-webkit-scrollbar {
  height: 4px; /* Slimmer scrollbar */
}

.ai-console-tab-selector::-webkit-scrollbar-track {
  background: #2F2F2F; /* Match the background of the tab selector */
}

.ai-console-tab-selector::-webkit-scrollbar-thumb {
  background: var(--background-modifier-border); /* Subtle thumb color */
  border-radius: 2px;
}

.ai-console-tab-selector::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted); /* Slightly lighter on hover */
}

.ai-console-tab-button {
  display: flex;
  align-items: center;
  gap: 8px; /* Gap between icon and label */
  padding: 8px 14px; /* Increased padding for better spacing */
  border: none;
  border-right: 1px solid var(--background-modifier-border);
  background: #2F2F2F;
  color: var(--text-faint);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  text-align: center;
  justify-content: center;
  opacity: 0.4;
  min-width: 70px; /* Slightly increased min-width for better spacing */
  white-space: nowrap; /* Prevent text wrapping */
  flex-shrink: 0; /* Prevent the button from shrinking too much */
}

.ai-console-tab-button:last-child {
  border-right: none;
}

.ai-console-tab-button:hover:not(.active) {
  background: #3A3A3A;
  color: var(--text-muted);
  opacity: 0.6;
}

.ai-console-tab-button.active {
  background: var(--background-primary);
  color: var(--text-normal);
  border-top-left-radius: 6px;
  border-top-right-radius: 6px;
  border-bottom: none;
  position: relative;
  z-index: 1;
  opacity: 1;
}

.ai-console-tab-icon {
  width: 16px;
  height: 16px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0; /* Prevent icon from shrinking */
}

.ai-console-tab-icon svg {
  fill: currentColor;
  stroke: currentColor;
  opacity: inherit;
}

.ai-console-tab-label {
  display: inline-block;
  flex-shrink: 0; /* Prevent label from shrinking */
}

.ai-console-tab-content {
  padding: 16px;
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border);
  border-top: none;
  border-radius: 0 0 6px 6px;
}

.ai-console-controls {
  margin-bottom: 20px;
  padding: 15px;
  background: var(--background-secondary);
  border-radius: 6px;
  border: 1px solid var(--background-modifier-border);
}

.ai-console-controls h3 {
  margin: 0 0 15px 0;
  font-size: 18px;
  color: var(--text-normal);
}

.ai-console-params {
  margin-top: 15px;
  padding-top: 10px;
  border-top: 1px solid var(--background-modifier-border);
}

.ai-console-params h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--text-normal);
}

.ai-console-prompt-section {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  align-items: flex-end;
}

.ai-console-prompt {
  flex: 1;
  width: 100%;
  height: 120px;
  padding: 10px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 6px;
  background: var(--background-primary-alt);
  color: var(--text-normal);
  font-size: 14px;
  resize: vertical;
  transition: border-color 0.2s ease;
}

.ai-console-prompt:focus {
  border-color: var(--interactive-accent);
  outline: none;
}

.ai-console-run-btn {
  padding: 10px 20px;
  background: var(--interactive-accent);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  transition: background 0.2s ease;
}

.ai-console-run-btn:hover {
  background: var(--interactive-accent-hover);
}

.ai-console-output-section {
  margin-bottom: 20px;
}

.ai-console-output-section h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--text-normal);
}

.ai-console-output {
  padding: 15px;
  background: var(--background-secondary);
  border-radius: 6px;
  min-height: 120px;
  white-space: pre-wrap;
  border: 1px solid var(--background-modifier-border);
  font-size: 14px;
  color: var(--text-normal);
}

.ai-console-code {
  margin-top: 10px;
  padding: 15px;
  background: var(--code-block-background);
  border-radius: 6px;
  overflow-x: auto;
  font-size: 13px;
  color: var(--text-muted);
  border: 1px solid var(--background-modifier-border);
}

.ai-console-history {
  margin-top: 20px;
  padding: 15px;
  background: var(--background-secondary);
  border-radius: 6px;
  border: 1px solid var(--background-modifier-border);
}

.ai-console-history h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--text-normal);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
}

.ai-console-history-list {
  list-style: none;
  padding: 0;
  max-height: 200px;
  overflow-y: auto;
}

.ai-console-history-list li {
  padding: 10px;
  border-bottom: 1px solid var(--background-modifier-border);
  cursor: pointer;
  font-size: 14px;
  color: var(--text-normal);
  transition: background 0.2s ease;
}

.ai-console-history-list li:hover {
  background: var(--background-modifier-hover);
}

.ai-console-history-list li:last-child {
  border-bottom: none;
}

.ai-console-history-list strong {
  color: var(--text-accent);
}

.ai-console-history-list span {
  color: var(--text-muted);
}
`;
===== src/settings/validation.ts =====

import { Notice } from 'obsidian'; // Added import for Notice
import { SampleSettingTab } from './settings';
import { providerFetchers, providerMetadata } from './providers/index';
import { ensureProviderConfigExists } from './utils'; // Fixed import

export async function validateAllStoredSecrets(tab: SampleSettingTab): Promise<void> {
    if (tab.isValidating) return;
    tab.isValidating = true;
    console.log("[Settings] Starting initial validation of all stored secrets...");

    tab.workingProviders.clear();
    tab.availableModels = {};

    let storedKeys: string[] = [];
    try {
        storedKeys = await tab.secrets.listSecrets();
        console.log("[Settings] Stored secret keys found:", storedKeys);
    } catch (error) {
        console.error("[Settings] Failed to list secrets during validation:", error);
        tab.isValidating = false;
        return;
    }

    let settingsChanged = false;

    const validationPromises = Object.keys(providerMetadata).map(async (providerKey) => {
        const meta = providerMetadata[providerKey];
        const requiresApiKey = meta.requiresApiKey;
        const hasStoredSecret = storedKeys.includes(providerKey);

        ensureProviderConfigExists(tab, providerKey);

        if (!requiresApiKey) {
            tab.workingProviders.add(providerKey);
            console.log(`[Settings] Added non-API-key provider: ${providerKey}`);
            try {
                const models = await fetchAvailableModels(tab, providerKey, undefined);
                tab.availableModels[providerKey] = models;
                if (models.length > 0) {
                    const currentModel = tab.plugin.settings.providers[providerKey]?.model;
                    if (!currentModel || !models.includes(currentModel)) {
                        console.log(`[Settings] Resetting model for ${providerKey} to ${models[0]}`);
                        tab.plugin.settings.providers[providerKey].model = models[0];
                        settingsChanged = true;
                    }
                } else {
                    console.warn(`[Settings] No models found for non-API-key provider: ${providerKey}`);
                }
            } catch (error) {
                console.error(`[Settings] Error fetching models for non-API-key provider ${providerKey}:`, error);
                tab.availableModels[providerKey] = [];
            }
            return;
        }

        if (hasStoredSecret) {
            let apiKey: string | undefined;
            try {
                apiKey = await tab.secrets.getSecret(providerKey);
            } catch (error) {
                console.error(`[Settings] Failed to get secret for ${providerKey}:`, error);
                return;
            }

            if (apiKey) {
                console.log(`[Settings] Auto-validating stored secret for: ${providerKey}`);
                try {
                    const models = await fetchAvailableModels(tab, providerKey, apiKey);
                    tab.availableModels[providerKey] = models;

                    if (models.length > 0) {
                        tab.workingProviders.add(providerKey);
                        const currentModel = tab.plugin.settings.providers[providerKey]?.model;
                        if (!currentModel || !models.includes(currentModel)) {
                            console.log(`[Settings] Resetting model for ${providerKey} to ${models[0]}`);
                            tab.plugin.settings.providers[providerKey].model = models[0];
                            settingsChanged = true;
                        }
                        console.log(`[Settings] Auto-validation successful for: ${providerKey}`);
                    } else {
                        console.log(`[Settings] Auto-validation failed for stored secret: ${providerKey}. Needs manual re-validation.`);
                    }
                } catch (error) {
                    console.error(`[Settings] Auto-validation model fetch error for ${providerKey}:`, error);
                    tab.availableModels[providerKey] = [];
                }
            } else {
                console.warn(`[Settings] Secret listed for ${providerKey} but getSecret returned undefined.`);
                tab.availableModels[providerKey] = [];
            }
        } else {
            console.log(`[Settings] No stored secret found for API key provider: ${providerKey}`);
            tab.availableModels[providerKey] = [];
        }
    });

    await Promise.all(validationPromises);

    if (settingsChanged) {
        await tab.plugin.saveSettings();
    }

    tab.isValidating = false;
    tab.hasDoneInitialValidation = true;
    console.log("[Settings] Finished initial validation. Working providers:", Array.from(tab.workingProviders));

    tab.display();
}

export async function fetchAvailableModels(
    tab: SampleSettingTab,
    providerKey: string,
    apiKey: string | undefined
): Promise<string[]> {
    const fetcher = providerFetchers[providerKey];
    const meta = providerMetadata[providerKey];

    if (!meta) {
        console.error(`[Settings] No metadata found for provider: ${providerKey}`);
        return [];
    }
    if (meta.requiresApiKey && !apiKey) {
        console.warn(`[Settings] fetchAvailableModels called for ${providerKey} which requires an API key, but none was provided.`);
        return [];
    }
    if (!fetcher) {
        new Notice(`Model fetching not implemented for provider: ${providerKey}`);
        console.warn(`Model fetching not implemented for provider: ${providerKey}`);
        return [];
    }

    try {
        const models = await fetcher(apiKey || '', tab.plugin.app);
        return Array.isArray(models) ? models : [];
    } catch (err) {
        console.error(`[${providerKey}] Model fetch error during fetchAvailableModels:`, err);
        throw err;
    }
}
===== src/settings/defaults.ts =====

import { Category, ProviderConfig, MyPluginSettings } from './types';
import { providerMetadata } from './providers/index';

// Define supported providers per category
export const categoryProviders: Record<Category, string[]> = {
    text: ['openai', 'anthropic', 'groq', 'gemini', 'openrouter', 'grok', 'local'],
    image: ['openai', 'stabilityai', 'grok'],
    video: [], // No providers yet; placeholder for future
    audio: [], // No providers yet
    ocr: [], // No providers yet
    '3D': ['stabilityai'] // Added 3D category with stabilityai as a provider
};

// Dynamically generate DEFAULT_SETTINGS
export const DEFAULT_SETTINGS: MyPluginSettings = {
    categories: {
        text: { defaultProvider: 'openai', backupProvider: '' },
        image: { defaultProvider: 'openai', backupProvider: '' },
        video: { defaultProvider: '', backupProvider: '' },
        audio: { defaultProvider: '', backupProvider: '' },
        ocr: { defaultProvider: '', backupProvider: '' },
        '3D': { defaultProvider: '', backupProvider: '' }
    },
    providers: Object.keys(providerMetadata).reduce((acc, key) => {
        acc[key] = {
            model: providerMetadata[key].defaultModel
        };
        return acc;
    }, {} as Record<string, ProviderConfig>)
};

===== src/settings/settings.ts =====

import { App, PluginSettingTab } from 'obsidian';
import type MyPlugin from '../../main';
import { SecretsManager } from '../utils/secrets';
import { validateAllStoredSecrets } from './validation';
import { renderCategoryTabs } from './components/CategoryTabs';
import { renderProviderSelector } from './components/ProviderSelector';
import { renderProviderConfig } from './components/ProviderConfig';
import { ensureProviderConfigExists } from './utils';
import { providerMetadata } from './providers/index';
import { DEFAULT_SETTINGS } from './defaults';

export class SampleSettingTab extends PluginSettingTab {
    plugin: MyPlugin;
    secrets: SecretsManager;
    selectedProviderKey: string;
    availableModels: Record<string, string[]> = {};
    workingProviders: Set<string> = new Set();
    isValidating: boolean = false;
    hasDoneInitialValidation: boolean = false;

    constructor(app: App, plugin: MyPlugin, secretsManager: SecretsManager) {
        super(app, plugin);
        this.plugin = plugin;
        this.secrets = secretsManager;

        // Initialize selected provider
        const firstCategory = 'text';
        const defaultProvider = this.plugin.settings.categories[firstCategory].defaultProvider;
        if (defaultProvider && providerMetadata[defaultProvider]) {
            this.selectedProviderKey = defaultProvider;
        } else if (Object.keys(providerMetadata).length > 0) {
            this.selectedProviderKey = Object.keys(providerMetadata)[0];
        } else {
            this.selectedProviderKey = '';
        }

        if (this.selectedProviderKey) {
            ensureProviderConfigExists(this, this.selectedProviderKey);
        }
    }

    async display(): Promise<void> {
        if (!this.hasDoneInitialValidation && !this.isValidating) {
            setTimeout(() => validateAllStoredSecrets(this), 0);
        }

        const { containerEl } = this;
        containerEl.empty();

        containerEl.createEl('h2', { text: 'LLM Provider Settings' });

        // Render category tabs
        renderCategoryTabs(this, containerEl);

        containerEl.createEl('h3', { text: 'Configure Providers' });

        // Render provider selection dropdown
        renderProviderSelector(this, containerEl);

        // Render configuration for selected provider
        if (this.selectedProviderKey && providerMetadata[this.selectedProviderKey]) {
            renderProviderConfig(this, containerEl);
        } else {
            containerEl.createEl('p', { text: 'Please select a provider to configure.' });
        }
    }
}
===== src/settings/utils.ts =====

import { SampleSettingTab } from './settings';
import { providerMetadata } from './providers/index';
import { ProviderConfig } from './types';

export function ensureProviderConfigExists(tab: SampleSettingTab, providerKey: string): ProviderConfig | undefined {
    if (!providerKey) return undefined;

    const meta = providerMetadata[providerKey];
    if (!meta) {
        console.error(`[Settings] No metadata found for provider key: ${providerKey}`);
        return undefined;
    }

    if (!tab.plugin.settings.providers[providerKey]) {
        tab.plugin.settings.providers[providerKey] = {
            model: meta.defaultModel
        };
        console.log(`[Settings] Added missing provider configuration for: ${providerKey}`);
    }
    return tab.plugin.settings.providers[providerKey];
}

export function getTabIcon(category: string): string {
    const tabIcons: Record<string, string> = {
        text: 'text',
        image: 'image',
        video: 'video',
        audio: 'volume-2',
        ocr: 'scan',
        '3D': 'cube'
    };
    return tabIcons[category] || 'circle';
}
===== src/settings/types.ts =====

export type Category = 'text' | 'image' | 'video' | 'audio' | 'ocr' | '3D';

export interface ProviderConfig {
    model: string;
}

export interface CategorySettings {
    defaultProvider: string;
    backupProvider: string;
}

export interface MyPluginSettings {
    categories: Record<Category, CategorySettings>;
    providers: Record<string, ProviderConfig>;
}
===== src/settings/providers/anthropic.ts =====

import { requestUrl } from 'obsidian';

// Define response types based on Anthropic API documentation
interface AnthropicModel {
    id: string;
    created_at: string;
    display_name: string;
    type: string;
}

interface AnthropicAPIResponse {
    data: AnthropicModel[];
    first_id: string | null;
    last_id: string | null;
    has_more: boolean;
}

export async function fetchAnthropicModels(apiKey: string): Promise<string[]> {
    const models: string[] = [];
    let hasMore = true;
    let afterId: string | null = null;
    const apiVersion = '2023-06-01'; // Set to a stable, supported version
    const limit = 100; // Increase limit to get more models in one request

    try {
        while (hasMore) {
            const url = new URL('https://api.anthropic.com/v1/models');
            url.searchParams.append('limit', limit.toString());
            if (afterId) {
                url.searchParams.append('after_id', afterId);
            }

            console.log('[Anthropic] Sending request:', {
                url: url.toString(),
                headers: { 'x-api-key': '[REDACTED]', 'anthropic-version': apiVersion }
            });

            const response = await requestUrl({
                url: url.toString(),
                method: 'GET',
                headers: {
                    'x-api-key': apiKey.trim(),
                    'anthropic-version': apiVersion
                }
            });

            if (response.status >= 400) {
                let errorMessage = `Anthropic error: ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log('[Anthropic] Error response body:', errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const data = response.json as AnthropicAPIResponse;
            
            if (!data.data || !Array.isArray(data.data)) {
                console.error('[Anthropic] Unexpected response format:', data);
                throw new Error('Unexpected API response format');
            }
            
            const modelIds = data.data.map(m => m.id);
            models.push(...modelIds);
            
            hasMore = data.has_more;
            afterId = data.last_id;

            console.log('[Anthropic] Fetched models:', modelIds, 'Has more:', hasMore);
            
            if (!hasMore || !afterId) break;
        }

        return models;
    } catch (error) {
        console.error('[Anthropic] Model fetch error:', error);
        throw error;
    }
}
===== src/settings/providers/openai.ts =====

import { requestUrl } from 'obsidian';

export async function fetchOpenAIModels(apiKey: string): Promise<string[]> {
	try {
		const url = 'https://api.openai.com/v1/models';
		const response = await requestUrl({
			url,
			method: 'GET',
			headers: { Authorization: `Bearer ${apiKey}` }
		});

		if (response.status >= 400) {
			throw new Error(`OpenAI error: ${response.status} ${response.text}`);
		}
		return response.json.data?.map((m: any) => m.id).sort() ?? [];
	} catch (err) {
		console.error('[OpenAI] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/stabilityai.ts =====

import { requestUrl } from 'obsidian';

interface StabilityAIEngine {
    id: string;
    name: string;
    description: string;
    type: string;
}

interface ModelInfo {
    id: string;
    languages: string[];
}

interface CategorizedModels {
    Media: ModelInfo[];
    Language: ModelInfo[];
    '3D': ModelInfo[];
    Audio: ModelInfo[];
}

// Fallback list of models with categories and languages, based on the provided table
const fallbackModels: CategorizedModels = {
    Media: [
        { id: 'stable-diffusion-3-5-medium', languages: ['English'] },
        { id: 'stable-diffusion-3-5-large', languages: ['English'] },
        { id: 'stable-diffusion-3-5-large-turbo', languages: ['English'] },
        { id: 'stable-diffusion-3-medium', languages: ['English'] },
        { id: 'stable-diffusion-xl-turbo', languages: ['English'] },
        { id: 'stable-diffusion-turbo', languages: ['English'] },
        { id: 'stable-video-diffusion-14-frame', languages: ['English'] },
        { id: 'stable-video-diffusion-25-frame', languages: ['English'] },
        { id: 'stable-video-diffusion-1-1', languages: ['English'] },
        { id: 'japanese-sdxl', languages: ['Japanese'] },
        { id: 'japanese-stable-clip', languages: ['Japanese'] },
        // Include V1 models seen in previous API response
        { id: 'stable-diffusion-v1-6', languages: ['English'] },
        { id: 'stable-diffusion-xl-1024-v1-0', languages: ['English'] }
    ],
    Language: [
        { id: 'stable-lm-2-12b', languages: ['English', 'Spanish', 'German', 'Italian', 'French', 'Portuguese', 'Dutch'] },
        { id: 'stable-lm-2-1-6b', languages: ['English', 'Spanish', 'German', 'Italian', 'French', 'Portuguese', 'Dutch'] },
        { id: 'stable-lm-zephyr-3b', languages: ['English'] },
        { id: 'japanese-stable-lm-2-1-6b', languages: ['Japanese'] },
        { id: 'japanese-stable-vlm', languages: ['Japanese'] },
        { id: 'stable-code-instruct-3b', languages: ['English', 'Code'] },
        { id: 'stable-code-3b', languages: ['English', 'Code'] }
    ],
    '3D': [
        { id: 'stable-point-aware-3d', languages: ['English'] },
        { id: 'stable-fast-3d', languages: ['English'] },
        { id: 'stable-zero123c', languages: ['English'] },
        { id: 'stable-video-3d', languages: ['English'] }
    ],
    Audio: [
        { id: 'stable-audio-open-1-0', languages: ['English'] }
    ]
};

// Function to map API engine types to plugin categories
function mapEngineTypeToCategory(engineType: string, engineId: string): keyof CategorizedModels {
    // Map based on engine type and ID patterns
    if (engineType === 'PICTURE' || engineType === 'VIDEO' || engineId.includes('video-diffusion') || engineId.includes('sdxl') || engineId.includes('stable-diffusion')) {
        return 'Media';
    } else if (engineType === 'AUDIO' || engineId.includes('audio')) {
        return 'Audio';
    } else if (engineType === '3D' || engineId.includes('3d')) {
        return '3D';
    } else if (engineType === 'TEXT' || engineId.includes('lm') || engineId.includes('code')) {
        return 'Language';
    }
    // Default to Media for unknown types, as most Stability AI models are image-related
    return 'Media';
}

// Helper to merge fetched models with fallback models, avoiding duplicates
function mergeModels(fetched: CategorizedModels, fallback: CategorizedModels): CategorizedModels {
    const result: CategorizedModels = { Media: [], Language: [], '3D': [], Audio: [] };
    const categories: (keyof CategorizedModels)[] = ['Media', 'Language', '3D', 'Audio'];

    for (const category of categories) {
        const fetchedIds = new Set(fetched[category].map(model => model.id));
        const merged = [...fetched[category]];

        // Add fallback models that weren't fetched
        for (const fallbackModel of fallback[category]) {
            if (!fetchedIds.has(fallbackModel.id)) {
                merged.push(fallbackModel);
            }
        }

        // Sort models by ID for consistency
        result[category] = merged.sort((a, b) => a.id.localeCompare(b.id));
    }

    return result;
}

export async function fetchStabilityAIModels(apiKey: string): Promise<string[]> {
    const categorizedModels: CategorizedModels = {
        Media: [],
        Language: [],
        '3D': [],
        Audio: []
    };
    let lastError: Error | null = null;

    // Try multiple API versions to fetch models
    const apiVersions = ['v1', 'v1beta'];
    for (const apiVersion of apiVersions) {
        const url = `https://api.stability.ai/${apiVersion}/engines/list`;
        console.log('[StabilityAI] Sending request:', {
            url,
            headers: {
                Authorization: '[REDACTED]',
                'Stability-Client-ID': 'obsidian-ai-plugin',
                'Stability-Client-Version': '1.0.0'
            }
        });

        try {
            const response = await requestUrl({
                url,
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${apiKey.trim()}`,
                    'Content-Type': 'application/json',
                    'Stability-Client-ID': 'obsidian-ai-plugin',
                    'Stability-Client-Version': '1.0.0'
                    // Uncomment and set the Organization header if needed
                    // 'Organization': 'org-123456'
                }
            });

            if (response.status >= 400) {
                let errorMessage = `Stability AI error (${apiVersion}): ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log('[StabilityAI] Error response body:', errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key.';
                    } else if (response.status === 500) {
                        errorMessage += '. Server error occurred.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const data = response.json as StabilityAIEngine[];
            if (!Array.isArray(data)) {
                console.error('[StabilityAI] Unexpected response format:', data);
                throw new Error('Unexpected API response format');
            }

            // Categorize fetched models
            for (const engine of data) {
                const category = mapEngineTypeToCategory(engine.type, engine.id);
                // Assume English as the default language unless specified in fallback
                const modelInfo: ModelInfo = { id: engine.id, languages: ['English'] };
                // Update languages if the model is in the fallback list
                for (const cat of Object.keys(fallbackModels) as (keyof CategorizedModels)[]) {
                    const fallbackModel = fallbackModels[cat].find(m => m.id === engine.id);
                    if (fallbackModel) {
                        modelInfo.languages = fallbackModel.languages;
                        break;
                    }
                }
                categorizedModels[category].push(modelInfo);
            }

            console.log(`[StabilityAI] Fetched models from ${apiVersion}:`, categorizedModels);
        } catch (err) {
            console.error(`[StabilityAI] Error for API version ${apiVersion}:`, err);
            lastError = err;
            continue;
        }
    }

    // Merge with fallback models to ensure all models from the table are included
    const finalModels = mergeModels(categorizedModels, fallbackModels);

    // Log the final categorized models
    console.log('[StabilityAI] Final categorized model list:', finalModels);

    // For compatibility with the current plugin, return a flat list of all model IDs
    // The settings redesign can use the categorized structure directly
    const flatModelList = [
        ...finalModels.Media,
        ...finalModels.Language,
        ...finalModels['3D'],
        ...finalModels.Audio
    ].map(model => model.id).sort();

    if (flatModelList.length === 0) {
        throw lastError || new Error('Failed to fetch models with all API versions and no fallback available');
    }

    return flatModelList;
}

// Export the categorized models for use in the settings redesign
export function getCategorizedStabilityAIModels(): CategorizedModels {
    // This assumes fetchStabilityAIModels has been called and cached the results
    // For now, return the fallback models; in a real implementation, you'd cache the fetched results
    return fallbackModels;
}
===== src/settings/providers/groq.ts =====

import { requestUrl } from 'obsidian';

export async function fetchGroqModels(apiKey: string): Promise<string[]> {
	try {
		const url = 'https://api.groq.com/openai/v1/models';
		const response = await requestUrl({
			url,
			method: 'GET',
			headers: { Authorization: `Bearer ${apiKey}` }
		});

		if (response.status >= 400) {
			throw new Error(`Groq error: ${response.status} ${response.text}`);
		}
		return response.json.data?.map((m: any) => m.id).sort() ?? [];
	} catch (err) {
		console.error('[Groq] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/gemini.ts =====

import { requestUrl } from 'obsidian';

/**
 * Interface representing the structure of a single model object
 * returned by the Gemini API's models.list method.
 */
interface GeminiModel {
  name: string; // e.g., "models/gemini-1.5-flash-001"
  baseModelId?: string; // e.g., "gemini-1.5-flash"
  version?: string; // e.g., "001"
  displayName?: string; // e.g., "Gemini 1.5 Flash"
  description?: string;
  inputTokenLimit?: number;
  outputTokenLimit?: number;
  supportedGenerationMethods?: string[];
  temperature?: number;
  topP?: number;
  topK?: number;
}

/**
 * Interface representing the overall response structure
 * from the Gemini API's models.list method.
 */
interface GeminiListModelsResponse {
  models?: GeminiModel[];
  nextPageToken?: string; // For handling pagination if needed
}

/**
 * Fetches the list of available models from the Google Gemini API.
 *
 * @param apiKey - The API key for authenticating with the Google Generative Language API.
 * @returns A promise that resolves to an array of model names (e.g., "models/gemini-pro").
 * @throws An error if the API request fails or returns an error status.
 */
/**
 * Fetches available models from the Gemini API.
 * Ensures model names are correctly formatted for use in generateContent endpoint.
 */
export async function fetchGeminiModels(apiKey: string): Promise<string[]> {
	try {
	  // Try v1 first, then fallback to v1beta
	  const apiVersions = ['v1', 'v1beta'];
	  let lastError: Error | null = null;
  
	  for (const apiVersion of apiVersions) {
		const url = `https://generativelanguage.googleapis.com/${apiVersion}/models?key=${apiKey}`;
		console.log('[fetchGeminiModels] Fetching models with URL:', url);
  
		try {
		  const resp = await requestUrl({
			url,
			method: 'GET',
		  });
  
		  if (resp.status !== 200) {
			throw new Error(`Failed to fetch Gemini models: ${resp.status} - ${resp.text || 'No details'}`);
		  }
  
		  const data = resp.json as { models: { name: string }[] };
		  // Normalize model names by removing 'models/' prefix
		  const models = data.models
			.map(m => m.name.replace(/^models\//, ''))
			.filter(m => m.startsWith('gemini')); // Only include Gemini models
		  console.log('[fetchGeminiModels] Fetched models:', models);
		  return models;
		} catch (error) {
		  console.error('[fetchGeminiModels] Error for API version', apiVersion, ':', error);
		  lastError = error;
		  continue;
		}
	  }
  
	  throw lastError || new Error('Failed to fetch models with all API versions');
	} catch (error) {
	  console.error('[fetchGeminiModels] Error:', error);
	  return ['gemini-1.5-pro-latest', 'gemini-1.5-flash-latest']; // Fallback models
	}
  }
===== src/settings/providers/grok.ts =====

import { requestUrl } from 'obsidian';

interface XAIModel {
    id: string;
    created: number;
    object: string;
    owned_by: string;
}

interface XAIAPIResponse {
    data: XAIModel[];
}

export async function fetchGrokModels(apiKey: string): Promise<string[]> {
    try {
        const url = 'https://api.x.ai/v1/models';
        console.log('[Grok] Sending request:', {
            url,
            headers: { Authorization: `Bearer ${apiKey.trim()}` }
        });

        const response = await requestUrl({
            url,
            method: 'GET',
            headers: {
                Authorization: `Bearer ${apiKey.trim()}`,
                'Content-Type': 'application/json' // Added for compatibility
            }
        });

        if (response.status >= 400) {
            let errorMessage = `xAI error: ${response.status}`;
            try {
                const errorBody = response.json?.error?.message || response.text || 'No additional details';
                console.log('[Grok] Error response body:', errorBody);
                errorMessage += ` - ${errorBody}`;
                if (response.status === 403) {
                    errorMessage += '. Check your API key, permissions, or account status at console.x.ai.';
                }
            } catch {
                errorMessage += ' - Failed to parse error details';
            }
            throw new Error(errorMessage);
        }

        const models = (response.json as XAIAPIResponse).data?.map(m => m.id).sort() ?? [];
        console.log('[Grok] Fetched models:', models);
        return models;
    } catch (err) {
        console.error('[Grok] Model fetch error:', err);
        throw err;
    }
}
===== src/settings/providers/local.ts =====

import { requestUrl } from 'obsidian';

export async function fetchLocalModels(): Promise<string[]> {
	try {
		// Check if Ollama is running
		await requestUrl({ url: 'http://localhost:11434', method: 'GET' });
		const response = await requestUrl({ url: 'http://localhost:11434/api/tags', method: 'GET' });
		return response.json.models?.map((m: any) => m.name).sort() ?? [];
	} catch (err) {
		console.error('[Local] Model fetch error:', err);
		throw new Error("Unable to connect to Ollama at http://localhost:11434");
	}
}
===== src/settings/providers/openrouter.ts =====

import { requestUrl } from 'obsidian';

export async function fetchOpenRouterModels(apiKey: string): Promise<string[]> {
	try {
		const url = 'https://openrouter.ai/api/v1/models';
		const response = await requestUrl({
			url,
			method: 'GET',
			headers: { Authorization: `Bearer ${apiKey}` }
		});

		if (response.status >= 400) {
			throw new Error(`OpenRouter error: ${response.status} ${response.text}`);
		}
		return response.json.data?.map((m: any) => m.id).sort() ?? [];
	} catch (err) {
		console.error('[OpenRouter] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/index.ts =====

import { App } from 'obsidian';
import { fetchOpenAIModels } from './openai';
import { fetchLocalModels } from './local';
import { fetchAnthropicModels } from './anthropic';
import { fetchGroqModels } from './groq';
import { fetchGeminiModels } from './gemini';
import { fetchOpenRouterModels } from './openrouter';
import { fetchGrokModels } from './grok';
import { fetchStabilityAIModels } from './stabilityai'; // Added Stability AI fetcher

export interface ProviderMetadata {
    key: string;
    defaultModel: string;
    requiresApiKey: boolean;
}

export const providerMetadata: Record<string, ProviderMetadata> = {
    openai: { key: 'openai', defaultModel: 'gpt-3.5-turbo', requiresApiKey: true },
    local: { key: 'local', defaultModel: 'llama2', requiresApiKey: false }, // Ollama
    anthropic: { key: 'anthropic', defaultModel: 'claude-3-opus-20240229', requiresApiKey: true },
    groq: { key: 'groq', defaultModel: 'mixtral-8x7b-32768', requiresApiKey: true }, // GroqCloud
    gemini: { key: 'gemini', defaultModel: 'models/gemini-pro', requiresApiKey: true }, // Google Gemini
    openrouter: { key: 'openrouter', defaultModel: 'openrouter/google/gemma-7b-it', requiresApiKey: true },
    grok: { key: 'grok', defaultModel: 'grok-1', requiresApiKey: true }, // x.ai Grok
    stabilityai: { key: 'stabilityai', defaultModel: 'stable-diffusion-xl-v1', requiresApiKey: true } // Stability AI
};

// Updated FetchFunction type to accept optional apiKey and app
type FetchFunction = (apiKey: string, app?: App) => Promise<string[]>;

export const providerFetchers: Record<string, FetchFunction> = {
    openai: fetchOpenAIModels,
    local: fetchLocalModels,
    anthropic: fetchAnthropicModels,
    groq: fetchGroqModels,
    gemini: fetchGeminiModels,
    openrouter: fetchOpenRouterModels,
    grok: fetchGrokModels,
    stabilityai: fetchStabilityAIModels // Added Stability AI fetcher
};
===== src/settings/components/ProviderSelector.ts =====

import { SampleSettingTab } from '../settings';
import { providerMetadata } from '../providers/index';
import { ensureProviderConfigExists } from '../utils';
import { Setting } from 'obsidian';

export function renderProviderSelector(tab: SampleSettingTab, containerEl: HTMLElement): void {
    new Setting(containerEl)
        .setName('Select Provider to Configure')
        .setDesc('Choose a provider to set its API key (if required) and model.')
        .addDropdown(dropdown => {
            Object.keys(providerMetadata).forEach(providerKey =>
                dropdown.addOption(providerKey, providerKey)
            );

            if (!providerMetadata[tab.selectedProviderKey]) {
                tab.selectedProviderKey = Object.keys(providerMetadata)[0] || '';
            }

            dropdown.setValue(tab.selectedProviderKey);

            dropdown.onChange(value => {
                tab.selectedProviderKey = value;
                ensureProviderConfigExists(tab, tab.selectedProviderKey);
                tab.display();
            });
        });
}
===== src/settings/components/CategoryTabs.ts =====

import { SampleSettingTab } from '../settings';
import { categoryProviders } from '../defaults';
import { TabComponent, TabConfig } from '../../ui/components/TabComponent';
import { getTabIcon } from '../utils';
import { Setting, Notice } from 'obsidian';
import { Category } from '../types';

export function renderCategoryTabs(tab: SampleSettingTab, containerEl: HTMLElement): void {
    const tabs: TabConfig[] = Object.keys(categoryProviders).map(category => ({
        tab: {
            id: category,
            name: category.charAt(0).toUpperCase() + category.slice(1),
            render: (tabContainer: HTMLElement) => renderCategoryTab(tab, tabContainer, category as Category),
            cleanup: () => {} // No cleanup needed for static settings
        },
        icon: getTabIcon(category)
    }));

    const tabComponent = new TabComponent(tab.app, tabs, 'text');
    const tabContainer = containerEl.createEl('div', { cls: 'category-tabs' });
    tabComponent.render(tabContainer);
}

function renderCategoryTab(tab: SampleSettingTab, container: HTMLElement, category: Category) {
    const catSettings = tab.plugin.settings.categories[category] || {
        defaultProvider: '',
        backupProvider: ''
    };

    // Create settings for default and backup providers
    const createProviderDropdown = (setting: Setting, settingKey: 'defaultProvider' | 'backupProvider') => {
        setting.addDropdown(dropdown => {
            const validProviders = categoryProviders[category]
                .filter(id => tab.workingProviders.has(id));

            dropdown.addOption('', '--- Select ---');

            if (validProviders.length === 0) {
                dropdown.addOption('', 'No validated providers available');
                dropdown.setDisabled(true);
            } else {
                validProviders.forEach(id => dropdown.addOption(id, id));
                dropdown.setDisabled(false);
            }

            const currentValue = catSettings[settingKey];
            dropdown.setValue(validProviders.includes(currentValue) ? currentValue : '');

            dropdown.onChange(async value => {
                const settingName = settingKey === 'defaultProvider' ? 'Default' : 'Backup';
                if (value === '') {
                    new Notice(`Cleared ${settingName} Provider for ${category}.`);
                } else {
                    new Notice(`${settingName} provider for ${category} set to ${value}`);
                }
                catSettings[settingKey] = value;
                await tab.plugin.saveSettings();
            });
        });
    };

    const defaultProviderSetting = new Setting(container)
        .setName(`Default Provider for ${category}`)
        .setDesc(`Primary provider for ${category} (must be validated).`);
    createProviderDropdown(defaultProviderSetting, 'defaultProvider');

    const backupProviderSetting = new Setting(container)
        .setName(`Backup Provider for ${category}`)
        .setDesc(`Used if the default provider for ${category} fails (must be validated).`);
    createProviderDropdown(backupProviderSetting, 'backupProvider');
}
===== src/settings/components/ProviderConfig.ts =====

import { SampleSettingTab } from '../settings';
import { providerMetadata, providerFetchers } from '../providers/index';
import { ensureProviderConfigExists } from '../utils';
import { fetchAvailableModels } from '../validation'; // Fixed import
import { Setting, Notice } from 'obsidian';
import { renderRemoveKeyButton } from './RemoveKeyButton';

export function renderProviderConfig(tab: SampleSettingTab, containerEl: HTMLElement): void {
    const selectedMeta = providerMetadata[tab.selectedProviderKey];
    const currentConfig = ensureProviderConfigExists(tab, tab.selectedProviderKey);
    if (!currentConfig) {
        containerEl.createEl('p', { text: `Error: Configuration could not be created for ${tab.selectedProviderKey}.` });
        return;
    }

    containerEl.createEl('h4', { text: `Configure: ${selectedMeta.key}` });

    // --- API Key Input + Validation Button ---
    const apiKeySetting = new Setting(containerEl);
    const requiresApiKey = selectedMeta.requiresApiKey;

    apiKeySetting.setName(`${selectedMeta.key} API Key`)
        .setDesc(requiresApiKey
            ? `Enter/update key and click Validate.`
            : `This provider does not require an API key.`);

    let apiKeyInput: HTMLInputElement | null = null;

    if (requiresApiKey) {
        apiKeySetting.addText(text => {
            apiKeyInput = text.inputEl;
            text.setPlaceholder('Enter API key here')
                .setValue('')
                .onChange(async value => {});
            text.inputEl.type = 'password';
            text.inputEl.style.width = '300px';
        });
    }

    apiKeySetting.addExtraButton(btn => {
        btn.setIcon('refresh-ccw')
            .setTooltip(requiresApiKey
                ? `Validate ${selectedMeta.key} key & fetch models`
                : 'Fetch available models (no API key needed)')
            .onClick(async () => {
                let apiKeyToValidate: string | undefined = undefined;
                const currentProvider = tab.selectedProviderKey;

                if (requiresApiKey) {
                    if (!apiKeyInput) return;
                    apiKeyToValidate = apiKeyInput.value.trim();
                    if (!apiKeyToValidate) {
                        apiKeyToValidate = await tab.secrets.getSecret(currentProvider);
                        if (!apiKeyToValidate) {
                            new Notice(`API Key required for ${currentProvider}. Enter one or check storage.`, 5000);
                            return;
                        }
                        new Notice(`Re-validating stored key for ${currentProvider}...`);
                    } else {
                        new Notice(`Validating new key for ${currentProvider}...`);
                        await tab.secrets.setSecret(currentProvider, apiKeyToValidate);
                        console.log(`[Settings] Saved new API key for ${currentProvider} before validation.`);
                    }
                } else {
                    new Notice(`Fetching models for ${currentProvider}...`);
                }

                btn.setDisabled(true);
                tab.workingProviders.delete(currentProvider);

                try {
                    const models = await fetchAvailableModels(tab, currentProvider, apiKeyToValidate);
                    tab.availableModels[currentProvider] = models;

                    if (models.length > 0) {
                        tab.workingProviders.add(currentProvider);
                        new Notice(`${currentProvider}: ${models.length} model(s) found. ${requiresApiKey ? 'Key validated!' : 'Models fetched!'}`, 5000);

                        const config = ensureProviderConfigExists(tab, currentProvider);
                        if (config && (!models.includes(config.model))) {
                            config.model = models[0];
                            new Notice(`Model reset to ${models[0]} as previous was unavailable.`, 3000);
                            await tab.plugin.saveSettings();
                        }
                    } else {
                        new Notice(`${currentProvider}: Validation failed. No models found${requiresApiKey ? ' or invalid API key' : ''}. Check console.`, 5000);
                    }
                } catch (error) {
                    console.error(`[Settings] Manual validation error for ${currentProvider}:`, error);
                    tab.availableModels[currentProvider] = [];
                    new Notice(`${currentProvider}: Validation failed. ${error.message}`, 7000);
                } finally {
                    btn.setDisabled(false);
                    tab.display();
                }
            });

        const statusContainer = btn.extraSettingsEl.createSpan({ cls: "setting-item-description" });
        statusContainer.style.marginLeft = "10px";

        if (tab.workingProviders.has(tab.selectedProviderKey)) {
            statusContainer.setText("✅ Valid");
            statusContainer.style.color = "green";
        } else if (requiresApiKey) {
            tab.secrets.getSecret(tab.selectedProviderKey).then(storedKey => {
                if (tab.selectedProviderKey === selectedMeta.key) {
                    if (storedKey) {
                        statusContainer.setText("❓ Validation Needed / Failed");
                        statusContainer.style.color = "orange";
                    } else {
                        statusContainer.setText("❌ No Key Set");
                        statusContainer.style.color = "red";
                    }
                }
            }).catch(err => {
                console.error("Error checking secret for status:", err);
                statusContainer.setText("⚠️ Error checking key");
                statusContainer.style.color = "red";
            });
        } else {
            if (tab.availableModels[tab.selectedProviderKey]?.length > 0) {
                statusContainer.setText("✅ Models Fetched");
                statusContainer.style.color = "green";
            } else {
                statusContainer.setText("❓ Fetch Models");
                statusContainer.style.color = "orange";
            }
        }
    });

    // --- Model Selection Dropdown ---
    const modelSetting = new Setting(containerEl)
        .setName(`${selectedMeta.key} Model`)
        .setDesc(`Select the model for ${selectedMeta.key}. (List updated after validation)`);

    modelSetting.addDropdown(dropdown => {
        const modelOptions = tab.availableModels[tab.selectedProviderKey] ?? [];
        const defaultModel = selectedMeta.defaultModel;
        let optionsToShow = [...modelOptions];

        const currentSelectedModel = currentConfig.model;
        if (currentSelectedModel && !optionsToShow.includes(currentSelectedModel)) {
            optionsToShow.push(currentSelectedModel);
        }
        if (optionsToShow.length === 0 && defaultModel) {
            optionsToShow.push(defaultModel);
        }

        optionsToShow.sort();

        if (optionsToShow.length === 0) {
            dropdown.addOption('', 'No models available (Validate key/Fetch first)');
            dropdown.setDisabled(true);
        } else {
            optionsToShow.forEach(m => dropdown.addOption(m, m));
            dropdown.setDisabled(false);
        }

        dropdown.setValue(optionsToShow.includes(currentSelectedModel) ? currentSelectedModel : optionsToShow[0] || '');

        dropdown.onChange(async value => {
            currentConfig.model = value;
            await tab.plugin.saveSettings();
            new Notice(`${selectedMeta.key} model set to ${value}`);
        });
    });

    // --- Display Fetched Models ---
    const currentModels = tab.availableModels[tab.selectedProviderKey] ?? [];
    if (currentModels.length > 0) {
        const detailsEl = containerEl.createEl('details');
        detailsEl.createEl('summary', { text: `View ${currentModels.length} Available Models` });
        const listEl = detailsEl.createEl('ul', { cls: 'provider-model-list' });
        const modelsToShow = currentModels.slice(0, 25);
        modelsToShow.forEach(model => {
            listEl.createEl('li', { text: model });
        });
        if (currentModels.length > 25) {
            listEl.createEl('li', { text: `... and ${currentModels.length - 25} more.` });
        }
    }

    // --- Remove Configuration Button ---
    renderRemoveKeyButton(tab, containerEl);
}
===== src/settings/components/RemoveKeyButton.ts =====

import { SampleSettingTab } from '../settings';
import { providerMetadata } from '../providers/index';
import { Setting, Notice } from 'obsidian';
import { Category } from '../types';

export function renderRemoveKeyButton(tab: SampleSettingTab, containerEl: HTMLElement): void {
    tab.secrets.getSecret(tab.selectedProviderKey).then(storedKey => {
        const selectedMeta = providerMetadata[tab.selectedProviderKey];
        if (tab.selectedProviderKey === selectedMeta.key && storedKey) {
            new Setting(containerEl)
                .setName(`Remove ${selectedMeta.key} API Key`)
                .setDesc(`Removes the stored API key for ${selectedMeta.key}. The model selection will be kept.`)
                .addButton(btn => {
                    btn.setButtonText('Remove Key')
                        .setIcon('trash')
                        .setWarning()
                        .onClick(async () => {
                            const providerToDelete = tab.selectedProviderKey;
                            new Notice(`Removing API key for ${providerToDelete}...`);

                            await tab.secrets.deleteSecret(providerToDelete);

                            tab.workingProviders.delete(providerToDelete);
                            tab.availableModels[providerToDelete] = [];

                            // Reset default/backup providers for affected categories
                            Object.keys(tab.plugin.settings.categories).forEach(category => {
                                const catSettings = tab.plugin.settings.categories[category as Category];
                                if (catSettings.defaultProvider === providerToDelete) {
                                    catSettings.defaultProvider = '';
                                    new Notice(`Default provider for ${category} cleared as its key was removed.`, 3000);
                                }
                                if (catSettings.backupProvider === providerToDelete) {
                                    catSettings.backupProvider = '';
                                    new Notice(`Backup provider for ${category} cleared as its key was removed.`, 3000);
                                }
                            });

                            await tab.plugin.saveSettings();
                            new Notice(`${providerToDelete} API key removed.`);

                            tab.display();
                        });
                });
        }
    }).catch(err => console.error("Error checking secret for remove button:", err));
}
===== src/core/Adapter.ts =====

// src/core/Adapter.ts
export interface LLMRequest {
    prompt: string;
    model?: string;
    systemPrompt?: string;
    temperature?: number;
    maxTokens?: number;
  }
  
  export interface LLMResponse {
    output: string;
    tokensUsed?: number;
  }
  
  export interface LLMAdapter {
    /** e.g. 'openai', 'anthropic' */
    providerKey: string;
    generate(request: LLMRequest): Promise<LLMResponse>;
  }
  
===== src/core/Gateway.ts =====


===== src/utils/secrets.ts =====

import { App, Vault, normalizePath } from 'obsidian';

// Define the path for the secrets directory and file
const SECRETS_DIR_PATH = '.secrets/nns';
const SECRETS_FILE_PATH = normalizePath(`${SECRETS_DIR_PATH}/secrets.json`);

/**
 * Manages storing and retrieving secrets (like API keys) securely
 * within the Obsidian vault in a dedicated file.
 */
export class SecretsManager {
    private app: App;
    private vault: Vault;
    // In-memory cache of the secrets
    private secrets: Record<string, string> = {};
    // Flag to indicate if secrets have been loaded from the file
    private isLoaded: boolean = false;
    // Promise to ensure loading completes before other operations if needed
    private loadPromise: Promise<void> | null = null;

    /**
     * Creates an instance of SecretsManager.
     * @param app - The Obsidian App instance.
     */
    constructor(app: App) {
        this.app = app;
        this.vault = app.vault;
        // Start loading secrets immediately but don't block constructor
        this.loadPromise = this.loadSecretsFromFile();
    }

    /**
     * Ensures that the initial loading of secrets from the file is complete.
     * Should be called after instantiation and before relying on secrets being present.
     */
    async initialize(): Promise<void> {
        if (!this.loadPromise) {
             // Should not happen with current constructor, but safeguard
            this.loadPromise = this.loadSecretsFromFile();
        }
        // Ensure the promise is awaited only once
        if (this.loadPromise) {
            await this.loadPromise;
        }
        console.log('[SecretsManager] Initialized and secrets loaded.');
    }

    /**
     * Loads secrets from the JSON file in the vault.
     * Creates the directory and file if they don't exist.
     */
    private async loadSecretsFromFile(): Promise<void> {
        try {
            // Ensure directory exists before trying to read the file
            await this.ensureDirectoryExists();

            if (await this.vault.adapter.exists(SECRETS_FILE_PATH)) {
                const content = await this.vault.adapter.read(SECRETS_FILE_PATH);
                if (content) {
                    try {
                        this.secrets = JSON.parse(content);
                        console.log(`[SecretsManager] Secrets loaded from ${SECRETS_FILE_PATH}`);
                    } catch (parseError) {
                        console.error(`[SecretsManager] Error parsing secrets file ${SECRETS_FILE_PATH}. Using empty secrets.`, parseError);
                        this.secrets = {}; // File is corrupted, start fresh
                        // Optionally: Backup corrupted file
                        // await this.vault.adapter.write(SECRETS_FILE_PATH + '.corrupted', content);
                        await this.saveSecretsToFile(); // Overwrite corrupted file with empty object
                    }
                } else {
                    this.secrets = {}; // File exists but is empty
                     console.log(`[SecretsManager] Secrets file ${SECRETS_FILE_PATH} is empty. Initializing empty secrets.`);
                }
            } else {
                console.log(`[SecretsManager] Secrets file not found at ${SECRETS_FILE_PATH}. Initializing empty secrets.`);
                this.secrets = {};
                // Create the file with empty content if it doesn't exist
                await this.saveSecretsToFile();
            }
        } catch (error) {
            console.error(`[SecretsManager] Error loading secrets from ${SECRETS_FILE_PATH}:`, error);
            // Fallback to empty secrets if loading fails
            this.secrets = {};
        } finally {
            this.isLoaded = true;
            this.loadPromise = null; // Loading is complete
        }
    }

    /**
     * Ensures the '.secrets/nns' directory exists.
     */
    private async ensureDirectoryExists(): Promise<void> {
         try {
            // Check if the base '.secrets' directory exists
            const baseDirExists = await this.vault.adapter.exists(normalizePath('.secrets'));
            if (!baseDirExists) {
                console.log("[SecretsManager] Creating base directory '.secrets'");
                await this.vault.adapter.mkdir(normalizePath('.secrets'));
            }
             // Check if the specific 'nns' subdirectory exists
            const nnsDirExists = await this.vault.adapter.exists(SECRETS_DIR_PATH);
             if (!nnsDirExists) {
                console.log(`[SecretsManager] Creating secrets directory at ${SECRETS_DIR_PATH}`);
                await this.vault.adapter.mkdir(SECRETS_DIR_PATH);
            }
        } catch (error) {
            // Ignore errors if directory already exists, log others
             // Vault adapter throws if it exists, so we check the message
            if (!(error instanceof Error && /EEXIST|already exists/i.test(error.message))) {
                 console.error(`[SecretsManager] Error creating directory ${SECRETS_DIR_PATH}:`, error);
                 // Re-throw if it's not an 'already exists' error, as it might be permissions etc.
                 throw error;
            } else {
                 // Log if it already existed, for debugging clarity
                 // console.log(`[SecretsManager] Directory ${SECRETS_DIR_PATH} already exists.`);
            }
        }
    }

    /**
     * Saves the current in-memory secrets to the JSON file in the vault.
     */
    private async saveSecretsToFile(): Promise<void> {
        // No need to wait for loadPromise here, as saving should only happen
        // after initialization or user action, by which time loading is complete.
        // If save is called *during* initial load (unlikely), it might cause issues.
        // Consider adding a queue or lock if concurrent access becomes complex.
         try {
            await this.ensureDirectoryExists(); // Make sure directory exists before writing
            const data = JSON.stringify(this.secrets, null, 2); // Pretty-print JSON
            await this.vault.adapter.write(SECRETS_FILE_PATH, data);
            // console.log(`[SecretsManager] Secrets saved to ${SECRETS_FILE_PATH}`); // Reduce log noise
        } catch (error) {
            console.error(`[SecretsManager] Error saving secrets to ${SECRETS_FILE_PATH}:`, error);
            // Optionally notify the user
            // new Notice('Failed to save secrets. Check console for details.');
        }
    }

    /**
     * Sets (adds or updates) a secret.
     * @param key - The identifier for the secret (e.g., 'openai').
     * @param value - The secret value (e.g., the API key).
     */
    async setSecret(key: string, value: string): Promise<void> {
        if (!key || typeof value !== 'string') {
            console.error('[SecretsManager] Invalid key or value provided for setSecret.');
            return;
        }
        this.secrets[key] = value;
        await this.saveSecretsToFile();
    }

    /**
     * Retrieves a secret by its key.
     * Returns undefined if the key is not found.
     * Ensures secrets are loaded before returning.
     * @param key - The identifier for the secret.
     * @returns The secret value or undefined.
     */
    async getSecret(key: string): Promise<string | undefined> {
         // Ensure initial load is complete before trying to access secrets
         if (!this.isLoaded && this.loadPromise) {
             console.warn('[SecretsManager] Attempted to get secret before initial load completed. Waiting...');
             await this.loadPromise;
         }
        return this.secrets[key];
    }

    /**
     * Deletes a secret by its key.
     * Ensures secrets are loaded before deleting.
     * @param key - The identifier for the secret to delete.
     */
    async deleteSecret(key: string): Promise<void> {
         // Ensure initial load is complete
         if (!this.isLoaded && this.loadPromise) {
             console.warn('[SecretsManager] Attempted to delete secret before initial load completed. Waiting...');
            await this.loadPromise;
        }
        if (this.secrets.hasOwnProperty(key)) {
            delete this.secrets[key];
            await this.saveSecretsToFile();
        } else {
             console.log(`[SecretsManager] Attempted to delete non-existent secret key: ${key}`);
        }
    }

    /**
     * Lists the keys of all stored secrets.
     * Ensures secrets are loaded before listing.
     * @returns An array of secret keys.
     */
    async listSecrets(): Promise<string[]> {
         // Ensure initial load is complete
         if (!this.isLoaded && this.loadPromise) {
             console.warn('[SecretsManager] Attempted to list secrets before initial load completed. Waiting...');
            await this.loadPromise;
        }
        return Object.keys(this.secrets);
    }
}

===== src/adapters/text/GeminiTextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { GeminiBaseAdapter } from '../base/GeminiBaseAdapter';

export class GeminiTextAdapter extends GeminiBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'gemini-1.5-pro-latest';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[GeminiTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            contents: [
                ...(req.systemPrompt
                    ? [{ parts: [{ text: req.systemPrompt }], role: 'system' }]
                    : []),
                { parts: [{ text: req.prompt }], role: 'user' },
            ],
            generationConfig: {
                temperature: req.temperature ?? 0.7,
                maxOutputTokens: req.maxTokens ?? 1000,
            },
        };

        console.log('[GeminiTextAdapter] Sending request:', {
            endpoint: `models/${model}:generateContent`,
            body: {
                contents: body.contents.map(c => ({
                    ...c,
                    parts: c.parts.map(p => ({
                        text: p.text.length > 50 ? p.text.slice(0, 50) + '...' : p.text,
                    })),
                })),
                generationConfig: body.generationConfig,
            },
        });

        let lastError: Error | null = null;

        for (const apiVersion of this.apiVersions) {
            try {
                const data = await this.makeRequest(`models/${model}:generateContent`, body, 'POST', apiVersion);

                if (
                    !data.candidates ||
                    !Array.isArray(data.candidates) ||
                    !data.candidates[0]?.content?.parts?.[0]?.text
                ) {
                    console.error('[GeminiTextAdapter] Unexpected response format:', data);
                    throw new Error('Unexpected Gemini API response format');
                }

                const output = data.candidates[0].content.parts[0].text.trim();
                const tokensUsed = data.usageMetadata?.totalTokenCount || 0;

                console.log('[GeminiTextAdapter] Response received:', {
                    output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                    tokensUsed,
                    model,
                    apiVersion,
                });

                return {
                    output,
                    tokensUsed,
                };
            } catch (error) {
                console.error('[GeminiTextAdapter] Generation error for API version', apiVersion, ':', error);
                lastError = error;
                continue;
            }
        }

        throw lastError || new Error('All API versions failed to generate content');
    }
}
===== src/adapters/text/GrokTextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { GrokBaseAdapter } from '../base/GrokBaseAdapter';

export class GrokTextAdapter extends GrokBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'grok-1';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[GrokTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[GrokTextAdapter] Sending request:', {
            endpoint: 'chat/completions',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('chat/completions', body, 'POST');

            if (!data.choices || !Array.isArray(data.choices) || !data.choices[0]?.message?.content) {
                console.error('[GrokTextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected xAI API response format');
            }

            const output = data.choices[0].message.content.trim();
            const tokensUsed = data.usage?.total_tokens || 0;

            console.log('[GrokTextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[GrokTextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/text/OpenAITextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { OpenAIBaseAdapter } from '../base/OpenAIBaseAdapter';

export class OpenAITextAdapter extends OpenAIBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'gpt-3.5-turbo';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[OpenAITextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[OpenAITextAdapter] Sending request:', {
            endpoint: 'chat/completions',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('chat/completions', body, 'POST');

            if (!data.choices || !Array.isArray(data.choices) || !data.choices[0]?.message?.content) {
                console.error('[OpenAITextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected OpenAI API response format');
            }

            const output = data.choices[0].message.content.trim();
            const tokensUsed = data.usage?.total_tokens || 0;

            console.log('[OpenAITextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[OpenAITextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/text/OpenRouterTextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { OpenRouterBaseAdapter } from '../base/OpenRouterBaseAdapter';

export class OpenRouterTextAdapter extends OpenRouterBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'x-ai/grok-beta';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[OpenRouterTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[OpenRouterTextAdapter] Sending request:', {
            endpoint: 'chat/completions',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('chat/completions', body, 'POST');

            if (!data.choices || !Array.isArray(data.choices) || !data.choices[0]?.message?.content) {
                console.error('[OpenRouterTextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected OpenRouter API response format');
            }

            const output = data.choices[0].message.content.trim();
            const tokensUsed = data.usage?.total_tokens || 0;

            console.log('[OpenRouterTextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[OpenRouterTextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/text/AnthropicTextAdapter.ts =====

// src/adapters/text/AnthropicTextAdapter.ts
import { requestUrl } from 'obsidian';
import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { fetchAnthropicModels } from '../../settings/providers/anthropic';
import { AnthropicBaseAdapter } from '../base/AnthropicBaseAdapter';

export class AnthropicTextAdapter extends AnthropicBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'claude-3-5-sonnet-20241022';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[AnthropicTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[AnthropicTextAdapter] Sending request:', {
            endpoint: 'messages',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('messages', body, 'POST');

            if (!data.content || !Array.isArray(data.content) || !data.content[0]?.text) {
                console.error('[AnthropicTextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected Anthropic API response format');
            }

            const output = data.content[0].text.trim();
            const tokensUsed = (data.usage?.output_tokens || 0) + (data.usage?.input_tokens || 0);

            console.log('[AnthropicTextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[AnthropicTextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/text/GroqTextAdapter.ts =====

import type { LLMAdapter, LLMRequest, LLMResponse } from '../../core/Adapter';
import { GroqBaseAdapter } from '../base/GroqBaseAdapter';

export class GroqTextAdapter extends GroqBaseAdapter implements LLMAdapter {
    private defaultModel: string;
    private fallbackModel = 'llama3-8b-8192';

    constructor(apiKey: string, defaultModel: string) {
        super(apiKey);
        this.defaultModel = defaultModel;
        console.log('[GroqTextAdapter] Initialized with default model:', defaultModel);
    }

    async generate(req: LLMRequest): Promise<LLMResponse> {
        const model = await this.validateModelInternal(req.model, this.defaultModel, this.fallbackModel);

        const body = {
            model,
            messages: [
                ...(req.systemPrompt ? [{ role: 'system', content: req.systemPrompt }] : []),
                { role: 'user', content: req.prompt },
            ],
            temperature: req.temperature ?? 0.7,
            max_tokens: req.maxTokens ?? 1000,
        };

        console.log('[GroqTextAdapter] Sending request:', {
            endpoint: 'chat/completions',
            body: {
                ...body,
                messages: body.messages.map(msg => ({
                    ...msg,
                    content: msg.content.length > 50 ? msg.content.slice(0, 50) + '...' : msg.content,
                })),
            },
        });

        try {
            const data = await this.makeRequest('chat/completions', body, 'POST');

            if (!data.choices || !Array.isArray(data.choices) || !data.choices[0]?.message?.content) {
                console.error('[GroqTextAdapter] Unexpected response format:', data);
                throw new Error('Unexpected Groq API response format');
            }

            const output = data.choices[0].message.content.trim();
            const tokensUsed = data.usage?.total_tokens || 0;

            console.log('[GroqTextAdapter] Response received:', {
                output: output.length > 50 ? output.slice(0, 50) + '...' : output,
                tokensUsed,
                model,
            });

            return {
                output,
                tokensUsed,
            };
        } catch (error) {
            console.error('[GroqTextAdapter] Generation error:', error);
            throw error;
        }
    }
}
===== src/adapters/base/OpenRouterBaseAdapter.ts =====


import { requestUrl } from 'obsidian';
import { fetchOpenRouterModels } from '../../settings/providers/openrouter';

export abstract class OpenRouterBaseAdapter {
    protected apiKey: string;
    public providerKey = 'openrouter';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://openrouter.ai/api/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your OpenRouter API key in settings at https://openrouter.ai/keys.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your OpenRouter account at https://openrouter.ai/keys.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://openrouter.ai/keys.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at OpenRouter. Try again later or contact OpenRouter support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await fetchOpenRouterModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }
}
===== src/adapters/base/AnthropicBaseAdapter.ts =====

// src/adapters/base/AnthropicBaseAdapter.ts
import { requestUrl } from 'obsidian';
import { fetchAnthropicModels } from '../../settings/providers/anthropic';

export abstract class AnthropicBaseAdapter {
    protected apiKey: string;
    protected apiVersion = '2023-06-01';
    public providerKey = 'anthropic'; // Changed from protected to public

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://api.anthropic.com/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    'x-api-key': this.apiKey,
                    'Content-Type': 'application/json',
                    'anthropic-version': this.apiVersion,
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;
        try {
            const availableModels = await fetchAnthropicModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);
            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }
}

import type { LLMRequest, LLMResponse } from '../../core/Adapter';
===== src/adapters/base/GrokBaseAdapter.ts =====

import { requestUrl } from 'obsidian';
import { fetchGrokModels } from '../../settings/providers/grok';

export abstract class GrokBaseAdapter {
    protected apiKey: string;
    public providerKey = 'grok';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://api.x.ai/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your xAI API key in settings at https://x.ai/api.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your xAI account at https://x.ai/api.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://x.ai/api.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at xAI. Try again later or contact xAI support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await fetchGrokModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }
}
===== src/adapters/base/GeminiBaseAdapter.ts =====

import { requestUrl } from 'obsidian';
import { fetchGeminiModels } from '../../settings/providers/gemini';

export abstract class GeminiBaseAdapter {
    protected apiKey: string;
    protected apiVersions = ['v1', 'v1beta'];
    public providerKey = 'gemini';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST', apiVersion: string = 'v1'): Promise<any> {
        const url = `https://generativelanguage.googleapis.com/${apiVersion}/${endpoint}?key=${this.apiKey}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your Gemini API key in settings at https://aistudio.google.com/app/apikey.';
                    } else if (response.status === 404) {
                        errorMessage += `. Endpoint incorrect for API version ${apiVersion} (tried ${url}). Check available models or region restrictions at https://ai.google.dev/docs.`;
                    } else if (response.status === 400) {
                        errorMessage += '. Invalid request parameters. Check prompt or model configuration.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your Gemini API quota at https://aistudio.google.com/app/apikey.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://aistudio.google.com/app/apikey.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at Google. Try again later or contact Google AI support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await fetchGeminiModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            const normalizedModels = availableModels.map(m => m.replace(/^models\//, ''));
            if (normalizedModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (normalizedModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (normalizedModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, normalizedModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }
}
===== src/adapters/base/OpenAIBaseAdapter.ts =====

import { requestUrl } from 'obsidian';
import { fetchOpenAIModels } from '../../settings/providers/openai';

export abstract class OpenAIBaseAdapter {
    protected apiKey: string;
    public providerKey = 'openai';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://api.openai.com/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Verify your OpenAI API key in settings at https://platform.openai.com/account/api-keys.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your OpenAI account at https://platform.openai.com/account/billing.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key permissions or account status at https://platform.openai.com/account/api-keys.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at OpenAI. Try again later or contact OpenAI support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await fetchOpenAIModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }
}
===== src/adapters/base/GroqBaseAdapter.ts =====

import { requestUrl } from 'obsidian';
import { fetchGroqModels } from '../../settings/providers/groq';

export abstract class GroqBaseAdapter {
    protected apiKey: string;
    public providerKey = 'groq';

    constructor(apiKey: string) {
        if (!apiKey) {
            throw new Error(`[${this.constructor.name}] API key is required.`);
        }
        this.apiKey = apiKey.trim();
        console.log(`[${this.constructor.name}] Initialized for provider: ${this.providerKey}`);
        console.log(`[${this.constructor.name}] API key provided: [REDACTED]`);
    }

    protected async makeRequest(endpoint: string, body: any, method: 'POST' | 'GET' = 'POST'): Promise<any> {
        const url = `https://api.groq.com/openai/v1/${endpoint}`;
        console.log(`[${this.constructor.name}] Sending ${method} request to ${url}`);

        try {
            const response = await requestUrl({
                url,
                method,
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: method === 'POST' ? JSON.stringify(body) : undefined,
            });

            if (response.status >= 400) {
                let errorMessage = `${this.providerKey} error ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.error(`[${this.constructor.name}] Error response body:`, errorBody);
                    errorMessage += `: ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key. Please verify your Groq API key in settings.';
                    } else if (response.status === 400) {
                        errorMessage += '. Check request parameters or model validity.';
                    } else if (response.status === 403) {
                        errorMessage += '. Check your API key, permissions, or account status at console.groq.com.';
                    } else if (response.status === 429) {
                        errorMessage += '. Rate limit exceeded. Try again later or check your Groq account.';
                    } else if (response.status >= 500) {
                        errorMessage += '. Server error at Groq. Try again later or contact Groq support.';
                    }
                } catch (parseError) {
                    errorMessage += ': Failed to parse error details';
                }
                throw new Error(errorMessage);
            }
            return response.json;
        } catch (error) {
            console.error(`[${this.constructor.name}] API request failed:`, error);
            throw error;
        }
    }

    protected async validateModelInternal(
        model: string | undefined,
        defaultModel: string,
        fallbackModel: string
    ): Promise<string> {
        console.log(`[${this.constructor.name}] Validating model: ${model || 'undefined'} (default: ${defaultModel}, fallback: ${fallbackModel})`);
        const candidateModel = model || defaultModel;

        try {
            const availableModels = await fetchGroqModels(this.apiKey);
            console.log(`[${this.constructor.name}] Available models:`, availableModels);

            if (availableModels.includes(candidateModel)) {
                console.log(`[${this.constructor.name}] Model validated:`, candidateModel);
                return candidateModel;
            }
            if (availableModels.includes(defaultModel)) {
                console.warn(`[${this.constructor.name}] Invalid model '${candidateModel}', falling back to default '${defaultModel}'`);
                return defaultModel;
            }
            if (availableModels.includes(fallbackModel)) {
                console.warn(`[${this.constructor.name}] Invalid models '${candidateModel}' and '${defaultModel}', falling back to known '${fallbackModel}'`);
                return fallbackModel;
            }
            console.error(`[${this.constructor.name}] No valid models available from list:`, availableModels);
            throw new Error(`No valid ${this.providerKey} models available.`);
        } catch (error) {
            console.error(`[${this.constructor.name}] Error fetching/validating models:`, error);
            const finalFallback = defaultModel || fallbackModel;
            console.warn(`[${this.constructor.name}] Using fallback model due to error:`, finalFallback);
            return finalFallback;
        }
    }
}
===== src/gateways/ImageGateway.ts =====


===== src/gateways/TextGateway.ts =====

import type { SecretsManager } from '../utils/secrets';
import type { MyPluginSettings } from '../settings/types';
import { providerMetadata } from '../settings/providers/index';
import type { LLMAdapter, LLMRequest } from '../core/Adapter';
import { OpenAITextAdapter } from '../adapters/text/OpenAITextAdapter';
import { AnthropicTextAdapter } from '../adapters/text/AnthropicTextAdapter'; // Fixed import
import { GrokTextAdapter } from '../adapters/text/GrokTextAdapter';
import { OpenRouterTextAdapter } from '../adapters/text/OpenRouterTextAdapter';
import { GeminiTextAdapter } from '../adapters/text/GeminiTextAdapter';
import { GroqTextAdapter } from '../adapters/text/GroqTextAdapter';

export class TextGateway {
  private adapters: Record<string, LLMAdapter> = {};

  private constructor(
    private defaultProvider: string,
    private backupProvider: string
  ) {}

  /** Factory that reads your settings & secrets and instantiates one adapter per provider */
  static async create(
    secrets: SecretsManager,
    settings: MyPluginSettings
  ): Promise<TextGateway> {
    const gw = new TextGateway(
      settings.categories.text.defaultProvider,
      settings.categories.text.backupProvider
    );

    for (const key of Object.keys(settings.providers)) {
      const model = settings.providers[key].model;
      let apiKey: string | undefined;

      // Grab the key if needed
      if (providerMetadata[key].requiresApiKey) {
        apiKey = await secrets.getSecret(key);
        if (!apiKey) {
          console.warn(`[TextGateway] No API key found for ${key}. Skipping adapter.`);
          continue;
        }
      }

      // Instantiate the right adapter
      let adapter: LLMAdapter;
      switch (key) {
        case 'openai':
          adapter = new OpenAITextAdapter(apiKey!, model);
          break;
        case 'anthropic':
          adapter = new AnthropicTextAdapter(apiKey!, model);
          break;
        case 'grok':
          adapter = new GrokTextAdapter(apiKey!, model);
          break;
        case 'openrouter':
          adapter = new OpenRouterTextAdapter(apiKey!, model);
          break;
        case 'gemini':
          adapter = new GeminiTextAdapter(apiKey!, model);
          break;
        case 'groq':
          adapter = new GroqTextAdapter(apiKey!, model);
          break;
        default:
          console.warn(`[TextGateway] Unsupported provider: ${key}`);
          continue; // skip unsupported
      }

      console.log(`[TextGateway] Adapter created for ${key} with model: ${model}`);
      gw.adapters[key] = adapter;
    }

    console.log('[TextGateway] Initialized adapters:', Object.keys(gw.adapters));
    return gw;
  }

  /** Single entry point: try default, then fallback */
  async generate(request: LLMRequest): Promise<string> {
    const primary = this.adapters[this.defaultProvider];
    try {
      if (!primary) {
        throw new Error(`No adapter found for default provider: ${this.defaultProvider}`);
      }
      const res = await primary.generate(request);
      return res.output;
    } catch (err) {
      if (
        this.backupProvider &&
        this.adapters[this.backupProvider]
      ) {
        console.log(`[TextGateway] Falling back to backup provider: ${this.backupProvider}`);
        const fallback = await this.adapters[
          this.backupProvider
        ].generate(request);
        return fallback.output;
      }
      throw err;
    }
  }
}
===== src/gateways/VisionGateway.ts =====


===== src/gateways/VideoGateway.ts =====


===== src/gateways/SpeechGateway.ts =====


===== src/gateways/ThreeDGateway.ts =====


===== src/api/aiNNS.ts =====

import type { App } from 'obsidian';
import type { SecretsManager } from '../utils/secrets';
import type { MyPluginSettings } from '../settings/settings';

import { TextGateway } from '../gateways/TextGateway';
//import { ImageGateway } from '../gateways/ImageGateway';
//import { SpeechGateway } from '../gateways/SpeechGateway';
//import { VideoGateway } from '../gateways/VideoGateway';
//import { VisionGateway } from '../gateways/VisionGateway';

/* ---------------------------------- *
 * Interfaces for Each AI Modality   *
 * ---------------------------------- */
export interface TextAPI {
  generate(
    prompt: string,
    opts?: {
      model?: string;
      temperature?: number;
      maxTokens?: number;
    }
  ): Promise<string>;
}

export interface ImageAPI {
  generate(
    prompt: string,
    opts?: {
      model?: string;
      width?: number;
      height?: number;
    }
  ): Promise<string>;
}

export interface SpeechAPI {
  synthesize(
    text: string,
    opts?: {
      voice?: string;
      format?: string;
    }
  ): Promise<string>;

  recognize(
    audioData: ArrayBuffer,
    opts?: {
      model?: string;
    }
  ): Promise<string>;
}

export interface VideoAPI {
  generate(
    prompt: string,
    opts?: {
      model?: string;
      durationSeconds?: number;
    }
  ): Promise<string>;

  caption(
    videoData: ArrayBuffer,
    opts?: {
      model?: string;
    }
  ): Promise<string>;
}

export interface VisionAPI {
  caption(
    imageData: ArrayBuffer,
    opts?: {
      model?: string;
    }
  ): Promise<string>;
}

/* ---------------------------------- *
 * Global Window Interface Extension *
 * ---------------------------------- */
declare global {
  interface Window {
    aiNNS?: {
      text: TextAPI;
      //image: ImageAPI;
      //speech: SpeechAPI;
     // video: VideoAPI;
      //vision: VisionAPI;
    };
  }
}

/* ---------------------------------- *
 * Register aiNNS on Global Scope    *
 * ---------------------------------- */
export async function registerAiNNS(
  app: App,
  secrets: SecretsManager,
  settings: MyPluginSettings
) {
  const textGw = await TextGateway.create(secrets, settings);
  //const imageGw = new ImageGateway(secrets, settings);
  //const speechGw = new SpeechGateway(secrets, settings);
  //const videoGw = new VideoGateway(secrets, settings);
  //const visionGw = new VisionGateway(secrets, settings);

  window.aiNNS = {
    text: {
      generate: (prompt, opts) =>
        textGw.generate({ prompt, ...opts }),
    },/*
    image: {
      generate: (prompt, opts) =>
        imageGw.generate({ prompt, ...opts }),
    },
    speech: {
      synthesize: (text, opts) =>
        speechGw.synthesize({ text, ...opts }),
      recognize: (audioData, opts) =>
        speechGw.recognize({ audioData, ...opts }),
    },
    video: {
      generate: (prompt, opts) =>
        videoGw.generate({ prompt, ...opts }),
      caption: (videoData, opts) =>
        videoGw.caption({ videoData, ...opts }),
    },
    vision: {
      caption: (imageData, opts) =>
        visionGw.caption({ imageData, ...opts }),
    },*/
  };
}

/* ---------------------------------- *
 * Cleanup aiNNS on Plugin Unload    *
 * ---------------------------------- */
export function unregisterAiNNS() {
  delete window.aiNNS;
}
