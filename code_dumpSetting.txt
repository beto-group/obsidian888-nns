
===== src/settings/settings.ts =====

import { App, PluginSettingTab, Setting, Notice } from 'obsidian';
import type MyPlugin from '../../main';
import { providerFetchers, providerMetadata } from './providers/index';
import { SecretsManager } from '../utils/secrets';
import { TabComponent, TabConfig, Tab } from '../ui/components/TabComponent';

// Define categories for provider selection
export type Category = 'text' | 'image' | 'video' | 'audio' | 'ocr';

// Define supported providers per category
const categoryProviders: Record<Category, string[]> = {
    text: ['openai', 'anthropic', 'groq', 'gemini', 'openrouter', 'grok', 'local'],
    image: ['openai', 'stabilityai'], // Added stabilityai for image generation
    video: [], // No providers yet; placeholder for future
    audio: [], // No providers yet
    ocr: [] // No providers yet
};

export interface ProviderConfig {
    model: string;
}

export interface CategorySettings {
    defaultProvider: string;
    backupProvider: string;
}

export interface MyPluginSettings {
    categories: Record<Category, CategorySettings>;
    providers: Record<string, ProviderConfig>;
}

// Dynamically generate DEFAULT_SETTINGS
export const DEFAULT_SETTINGS: MyPluginSettings = {
    categories: {
        text: { defaultProvider: 'openai', backupProvider: '' },
        image: { defaultProvider: 'openai', backupProvider: '' },
        video: { defaultProvider: '', backupProvider: '' },
        audio: { defaultProvider: '', backupProvider: '' },
        ocr: { defaultProvider: '', backupProvider: '' }
    },
    providers: Object.keys(providerMetadata).reduce((acc, key) => {
        acc[key] = {
            model: providerMetadata[key].defaultModel
        };
        return acc;
    }, {} as Record<string, ProviderConfig>)
};

export class SampleSettingTab extends PluginSettingTab {
    plugin: MyPlugin;
    secrets: SecretsManager;
    selectedProviderKey: string;
    availableModels: Record<string, string[]> = {};
    workingProviders: Set<string> = new Set();
    isValidating: boolean = false;
    hasDoneInitialValidation: boolean = false;
    tabComponent: TabComponent | null = null;

    constructor(app: App, plugin: MyPlugin, secretsManager: SecretsManager) {
        super(app, plugin);
        this.plugin = plugin;
        this.secrets = secretsManager;

        // Initialize selected provider
        const firstCategory = 'text';
        const defaultProvider = this.plugin.settings.categories[firstCategory].defaultProvider;
        if (defaultProvider && providerMetadata[defaultProvider]) {
            this.selectedProviderKey = defaultProvider;
        } else if (Object.keys(providerMetadata).length > 0) {
            this.selectedProviderKey = Object.keys(providerMetadata)[0];
        } else {
            this.selectedProviderKey = '';
        }

        if (this.selectedProviderKey) {
            this.ensureProviderConfigExists(this.selectedProviderKey);
        }
    }

    private async validateAllStoredSecrets(): Promise<void> {
        if (this.isValidating) return;
        this.isValidating = true;
        console.log("[Settings] Starting initial validation of all stored secrets...");

        this.workingProviders.clear();
        this.availableModels = {};

        let storedKeys: string[] = [];
        try {
            storedKeys = await this.secrets.listSecrets();
            console.log("[Settings] Stored secret keys found:", storedKeys);
        } catch (error) {
            console.error("[Settings] Failed to list secrets during validation:", error);
            this.isValidating = false;
            return;
        }

        let settingsChanged = false;

        const validationPromises = Object.keys(providerMetadata).map(async (providerKey) => {
            const meta = providerMetadata[providerKey];
            const requiresApiKey = meta.requiresApiKey;
            const hasStoredSecret = storedKeys.includes(providerKey);

            this.ensureProviderConfigExists(providerKey);

            if (!requiresApiKey) {
                this.workingProviders.add(providerKey);
                console.log(`[Settings] Added non-API-key provider: ${providerKey}`);
                try {
                    const models = await this.fetchAvailableModels(providerKey, undefined);
                    this.availableModels[providerKey] = models;
                    if (models.length > 0) {
                        const currentModel = this.plugin.settings.providers[providerKey]?.model;
                        if (!currentModel || !models.includes(currentModel)) {
                            console.log(`[Settings] Resetting model for ${providerKey} to ${models[0]}`);
                            this.plugin.settings.providers[providerKey].model = models[0];
                            settingsChanged = true;
                        }
                    } else {
                        console.warn(`[Settings] No models found for non-API-key provider: ${providerKey}`);
                    }
                } catch (error) {
                    console.error(`[Settings] Error fetching models for non-API-key provider ${providerKey}:`, error);
                    this.availableModels[providerKey] = [];
                }
                return;
            }

            if (hasStoredSecret) {
                let apiKey: string | undefined;
                try {
                    apiKey = await this.secrets.getSecret(providerKey);
                } catch (error) {
                    console.error(`[Settings] Failed to get secret for ${providerKey}:`, error);
                    return;
                }

                if (apiKey) {
                    console.log(`[Settings] Auto-validating stored secret for: ${providerKey}`);
                    try {
                        const models = await this.fetchAvailableModels(providerKey, apiKey);
                        this.availableModels[providerKey] = models;

                        if (models.length > 0) {
                            this.workingProviders.add(providerKey);
                            const currentModel = this.plugin.settings.providers[providerKey]?.model;
                            if (!currentModel || !models.includes(currentModel)) {
                                console.log(`[Settings] Resetting model for ${providerKey} to ${models[0]}`);
                                this.plugin.settings.providers[providerKey].model = models[0];
                                settingsChanged = true;
                            }
                            console.log(`[Settings] Auto-validation successful for: ${providerKey}`);
                        } else {
                            console.log(`[Settings] Auto-validation failed for stored secret: ${providerKey}. Needs manual re-validation.`);
                        }
                    } catch (error) {
                        console.error(`[Settings] Auto-validation model fetch error for ${providerKey}:`, error);
                        this.availableModels[providerKey] = [];
                    }
                } else {
                    console.warn(`[Settings] Secret listed for ${providerKey} but getSecret returned undefined.`);
                    this.availableModels[providerKey] = [];
                }
            } else {
                console.log(`[Settings] No stored secret found for API key provider: ${providerKey}`);
                this.availableModels[providerKey] = [];
            }
        });

        await Promise.all(validationPromises);

        if (settingsChanged) {
            await this.plugin.saveSettings();
        }

        this.isValidating = false;
        this.hasDoneInitialValidation = true;
        console.log("[Settings] Finished initial validation. Working providers:", Array.from(this.workingProviders));

        this.display();
    }

    ensureProviderConfigExists(providerKey: string): ProviderConfig | undefined {
        if (!providerKey) return undefined;

        const meta = providerMetadata[providerKey];
        if (!meta) {
            console.error(`[Settings] No metadata found for provider key: ${providerKey}`);
            return undefined;
        }

        if (!this.plugin.settings.providers[providerKey]) {
            this.plugin.settings.providers[providerKey] = {
                model: meta.defaultModel
            };
            console.log(`[Settings] Added missing provider configuration for: ${providerKey}`);
        }
        return this.plugin.settings.providers[providerKey];
    }

    async display(): Promise<void> {
        if (!this.hasDoneInitialValidation && !this.isValidating) {
            setTimeout(() => this.validateAllStoredSecrets(), 0);
        }

        const { containerEl } = this;
        containerEl.empty();

        containerEl.createEl('h2', { text: 'LLM Provider Settings' });

        // --- Category-based Provider Selection with Tabs ---
        const tabs: TabConfig[] = Object.keys(categoryProviders).map(category => ({
            tab: {
                id: category,
                name: category.charAt(0).toUpperCase() + category.slice(1),
                render: (tabContainer: HTMLElement) => this.renderCategoryTab(tabContainer, category as Category),
                cleanup: () => {} // No cleanup needed for static settings
            },
            icon: this.getTabIcon(category)
        }));

        this.tabComponent = new TabComponent(this.app, tabs, 'text');
        const tabContainer = containerEl.createEl('div', { cls: 'category-tabs' });
        this.tabComponent.render(tabContainer);

        containerEl.createEl('h3', { text: 'Configure Providers' });

        // --- Provider Selection Dropdown ---
        new Setting(containerEl)
            .setName('Select Provider to Configure')
            .setDesc('Choose a provider to set its API key (if required) and model.')
            .addDropdown(dropdown => {
                Object.keys(providerMetadata).forEach(providerKey =>
                    dropdown.addOption(providerKey, providerKey)
                );

                if (!providerMetadata[this.selectedProviderKey]) {
                    this.selectedProviderKey = Object.keys(providerMetadata)[0] || '';
                }

                dropdown.setValue(this.selectedProviderKey);

                dropdown.onChange(value => {
                    this.selectedProviderKey = value;
                    this.ensureProviderConfigExists(this.selectedProviderKey);
                    this.display();
                });
            });

        // --- Configuration Section for Selected Provider ---
        if (!this.selectedProviderKey || !providerMetadata[this.selectedProviderKey]) {
            containerEl.createEl('p', { text: 'Please select a provider to configure.' });
            return;
        }

        const selectedMeta = providerMetadata[this.selectedProviderKey];
        const currentConfig = this.ensureProviderConfigExists(this.selectedProviderKey);
        if (!currentConfig) {
            containerEl.createEl('p', { text: `Error: Configuration could not be created for ${this.selectedProviderKey}.` });
            return;
        }

        containerEl.createEl('h4', { text: `Configure: ${selectedMeta.key}` });

        // --- API Key Input + Validation Button ---
        const apiKeySetting = new Setting(containerEl);
        const requiresApiKey = selectedMeta.requiresApiKey;

        apiKeySetting.setName(`${selectedMeta.key} API Key`)
            .setDesc(requiresApiKey
                ? `Enter/update key and click Validate.`
                : `This provider does not require an API key.`);

        let apiKeyInput: HTMLInputElement | null = null;

        if (requiresApiKey) {
            apiKeySetting.addText(text => {
                apiKeyInput = text.inputEl;
                text.setPlaceholder('Enter API key here')
                    .setValue('')
                    .onChange(async value => {});
                text.inputEl.type = 'password';
                text.inputEl.style.width = '300px';
            });
        }

        apiKeySetting.addExtraButton(btn => {
            btn.setIcon('refresh-ccw')
                .setTooltip(requiresApiKey
                    ? `Validate ${selectedMeta.key} key & fetch models`
                    : 'Fetch available models (no API key needed)')
                .onClick(async () => {
                    let apiKeyToValidate: string | undefined = undefined;
                    const currentProvider = this.selectedProviderKey;

                    if (requiresApiKey) {
                        if (!apiKeyInput) return;
                        apiKeyToValidate = apiKeyInput.value.trim();
                        if (!apiKeyToValidate) {
                            apiKeyToValidate = await this.secrets.getSecret(currentProvider);
                            if (!apiKeyToValidate) {
                                new Notice(`API Key required for ${currentProvider}. Enter one or check storage.`, 5000);
                                return;
                            }
                            new Notice(`Re-validating stored key for ${currentProvider}...`);
                        } else {
                            new Notice(`Validating new key for ${currentProvider}...`);
                            await this.secrets.setSecret(currentProvider, apiKeyToValidate);
                            console.log(`[Settings] Saved new API key for ${currentProvider} before validation.`);
                        }
                    } else {
                        new Notice(`Fetching models for ${currentProvider}...`);
                    }

                    btn.setDisabled(true);
                    this.workingProviders.delete(currentProvider);

                    try {
                        const models = await this.fetchAvailableModels(currentProvider, apiKeyToValidate);
                        this.availableModels[currentProvider] = models;

                        if (models.length > 0) {
                            this.workingProviders.add(currentProvider);
                            new Notice(`${currentProvider}: ${models.length} model(s) found. ${requiresApiKey ? 'Key validated!' : 'Models fetched!'}`, 5000);

                            const config = this.ensureProviderConfigExists(currentProvider);
                            if (config && (!models.includes(config.model))) {
                                config.model = models[0];
                                new Notice(`Model reset to ${models[0]} as previous was unavailable.`, 3000);
                                await this.plugin.saveSettings();
                            }
                        } else {
                            new Notice(`${currentProvider}: Validation failed. No models found${requiresApiKey ? ' or invalid API key' : ''}. Check console.`, 5000);
                        }
                    } catch (error) {
                        console.error(`[Settings] Manual validation error for ${currentProvider}:`, error);
                        this.availableModels[currentProvider] = [];
                        new Notice(`${currentProvider}: Validation failed. ${error.message}`, 7000);
                    } finally {
                        btn.setDisabled(false);
                        this.display();
                    }
                });

            const statusContainer = btn.extraSettingsEl.createSpan({ cls: "setting-item-description" });
            statusContainer.style.marginLeft = "10px";

            if (this.workingProviders.has(this.selectedProviderKey)) {
                statusContainer.setText("✅ Valid");
                statusContainer.style.color = "green";
            } else if (requiresApiKey) {
                this.secrets.getSecret(this.selectedProviderKey).then(storedKey => {
                    if (this.selectedProviderKey === selectedMeta.key) {
                        if (storedKey) {
                            statusContainer.setText("❓ Validation Needed / Failed");
                            statusContainer.style.color = "orange";
                        } else {
                            statusContainer.setText("❌ No Key Set");
                            statusContainer.style.color = "red";
                        }
                    }
                }).catch(err => {
                    console.error("Error checking secret for status:", err);
                    statusContainer.setText("⚠️ Error checking key");
                    statusContainer.style.color = "red";
                });
            } else {
                if (this.availableModels[this.selectedProviderKey]?.length > 0) {
                    statusContainer.setText("✅ Models Fetched");
                    statusContainer.style.color = "green";
                } else {
                    statusContainer.setText("❓ Fetch Models");
                    statusContainer.style.color = "orange";
                }
            }
        });

        // --- Model Selection Dropdown ---
        const modelSetting = new Setting(containerEl)
            .setName(`${selectedMeta.key} Model`)
            .setDesc(`Select the model for ${selectedMeta.key}. (List updated after validation)`);

        modelSetting.addDropdown(dropdown => {
            const modelOptions = this.availableModels[this.selectedProviderKey] ?? [];
            const defaultModel = selectedMeta.defaultModel;
            let optionsToShow = [...modelOptions];

            const currentSelectedModel = currentConfig.model;
            if (currentSelectedModel && !optionsToShow.includes(currentSelectedModel)) {
                optionsToShow.push(currentSelectedModel);
            }
            if (optionsToShow.length === 0 && defaultModel) {
                optionsToShow.push(defaultModel);
            }

            optionsToShow.sort();

            if (optionsToShow.length === 0) {
                dropdown.addOption('', 'No models available (Validate key/Fetch first)');
                dropdown.setDisabled(true);
            } else {
                optionsToShow.forEach(m => dropdown.addOption(m, m));
                dropdown.setDisabled(false);
            }

            dropdown.setValue(optionsToShow.includes(currentSelectedModel) ? currentSelectedModel : optionsToShow[0] || '');

            dropdown.onChange(async value => {
                currentConfig.model = value;
                await this.plugin.saveSettings();
                new Notice(`${selectedMeta.key} model set to ${value}`);
            });
        });

        // --- Display Fetched Models ---
        const currentModels = this.availableModels[this.selectedProviderKey] ?? [];
        if (currentModels.length > 0) {
            const detailsEl = containerEl.createEl('details');
            detailsEl.createEl('summary', { text: `View ${currentModels.length} Available Models` });
            const listEl = detailsEl.createEl('ul', { cls: 'provider-model-list' });
            const modelsToShow = currentModels.slice(0, 25);
            modelsToShow.forEach(model => {
                listEl.createEl('li', { text: model });
            });
            if (currentModels.length > 25) {
                listEl.createEl('li', { text: `... and ${currentModels.length - 25} more.` });
            }
        }

        // --- Remove Configuration Button ---
        this.secrets.getSecret(this.selectedProviderKey).then(storedKey => {
            if (this.selectedProviderKey === selectedMeta.key && storedKey) {
                new Setting(containerEl)
                    .setName(`Remove ${selectedMeta.key} API Key`)
                    .setDesc(`Removes the stored API key for ${selectedMeta.key}. The model selection will be kept.`)
                    .addButton(btn => {
                        btn.setButtonText('Remove Key')
                            .setIcon('trash')
                            .setWarning()
                            .onClick(async () => {
                                const providerToDelete = this.selectedProviderKey;
                                new Notice(`Removing API key for ${providerToDelete}...`);

                                await this.secrets.deleteSecret(providerToDelete);

                                this.workingProviders.delete(providerToDelete);
                                this.availableModels[providerToDelete] = [];

                                // Reset default/backup providers for affected categories
                                Object.keys(this.plugin.settings.categories).forEach(category => {
                                    const catSettings = this.plugin.settings.categories[category as Category];
                                    if (catSettings.defaultProvider === providerToDelete) {
                                        catSettings.defaultProvider = '';
                                        new Notice(`Default provider for ${category} cleared as its key was removed.`, 3000);
                                    }
                                    if (catSettings.backupProvider === providerToDelete) {
                                        catSettings.backupProvider = '';
                                        new Notice(`Backup provider for ${category} cleared as its key was removed.`, 3000);
                                    }
                                });

                                await this.plugin.saveSettings();
                                new Notice(`${providerToDelete} API key removed.`);

                                this.display();
                            });
                    });
            }
        }).catch(err => console.error("Error checking secret for remove button:", err));
    }

    private renderCategoryTab(container: HTMLElement, category: Category) {
        const catSettings = this.plugin.settings.categories[category] || {
            defaultProvider: '',
            backupProvider: ''
        };

        // Create settings for default and backup providers
        const createProviderDropdown = (setting: Setting, settingKey: 'defaultProvider' | 'backupProvider') => {
            setting.addDropdown(dropdown => {
                const validProviders = categoryProviders[category]
                    .filter(id => this.workingProviders.has(id));

                dropdown.addOption('', '--- Select ---');

                if (validProviders.length === 0) {
                    dropdown.addOption('', 'No validated providers available');
                    dropdown.setDisabled(true);
                } else {
                    validProviders.forEach(id => dropdown.addOption(id, id));
                    dropdown.setDisabled(false);
                }

                const currentValue = catSettings[settingKey];
                dropdown.setValue(validProviders.includes(currentValue) ? currentValue : '');

                dropdown.onChange(async value => {
                    const settingName = settingKey === 'defaultProvider' ? 'Default' : 'Backup';
                    if (value === '') {
                        new Notice(`Cleared ${settingName} Provider for ${category}.`);
                    } else {
                        new Notice(`${settingName} provider for ${category} set to ${value}`);
                    }
                    catSettings[settingKey] = value;
                    await this.plugin.saveSettings();
                });
            });
        };

        const defaultProviderSetting = new Setting(container)
            .setName(`Default Provider for ${category}`)
            .setDesc(`Primary provider for ${category} (must be validated).`);
        createProviderDropdown(defaultProviderSetting, 'defaultProvider');

        const backupProviderSetting = new Setting(container)
            .setName(`Backup Provider for ${category}`)
            .setDesc(`Used if the default provider for ${category} fails (must be validated).`);
        createProviderDropdown(backupProviderSetting, 'backupProvider');
    }

    private getTabIcon(category: string): string {
        const tabIcons: Record<string, string> = {
            text: 'text',
            image: 'image',
            video: 'video',
            audio: 'volume-2',
            ocr: 'scan'
        };
        return tabIcons[category] || 'circle';
    }

    async fetchAvailableModels(providerKey: string, apiKey: string | undefined): Promise<string[]> {
        const fetcher = providerFetchers[providerKey];
        const meta = providerMetadata[providerKey];

        if (!meta) {
            console.error(`[Settings] No metadata found for provider: ${providerKey}`);
            return [];
        }
        if (meta.requiresApiKey && !apiKey) {
            console.warn(`[Settings] fetchAvailableModels called for ${providerKey} which requires an API key, but none was provided.`);
            return [];
        }
        if (!fetcher) {
            new Notice(`Model fetching not implemented for provider: ${providerKey}`);
            console.warn(`Model fetching not implemented for provider: ${providerKey}`);
            return [];
        }

        try {
            const models = await fetcher(apiKey || '', this.plugin.app);
            return Array.isArray(models) ? models : [];
        } catch (err) {
            console.error(`[${providerKey}] Model fetch error during fetchAvailableModels:`, err);
            throw err;
        }
    }
}
===== src/settings/providers/anthropic.ts =====

import { requestUrl } from 'obsidian';

// Define response types based on Anthropic API documentation
interface AnthropicModel {
    id: string;
    created_at: string;
    display_name: string;
    type: string;
}

interface AnthropicAPIResponse {
    data: AnthropicModel[];
    first_id: string | null;
    last_id: string | null;
    has_more: boolean;
}

export async function fetchAnthropicModels(apiKey: string): Promise<string[]> {
    const models: string[] = [];
    let hasMore = true;
    let afterId: string | null = null;
    const apiVersion = '2023-06-01'; // Set to a stable, supported version
    const limit = 100; // Increase limit to get more models in one request

    try {
        while (hasMore) {
            const url = new URL('https://api.anthropic.com/v1/models');
            url.searchParams.append('limit', limit.toString());
            if (afterId) {
                url.searchParams.append('after_id', afterId);
            }

            console.log('[Anthropic] Sending request:', {
                url: url.toString(),
                headers: { 'x-api-key': '[REDACTED]', 'anthropic-version': apiVersion }
            });

            const response = await requestUrl({
                url: url.toString(),
                method: 'GET',
                headers: {
                    'x-api-key': apiKey.trim(),
                    'anthropic-version': apiVersion
                }
            });

            if (response.status >= 400) {
                let errorMessage = `Anthropic error: ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log('[Anthropic] Error response body:', errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const data = response.json as AnthropicAPIResponse;
            
            if (!data.data || !Array.isArray(data.data)) {
                console.error('[Anthropic] Unexpected response format:', data);
                throw new Error('Unexpected API response format');
            }
            
            const modelIds = data.data.map(m => m.id);
            models.push(...modelIds);
            
            hasMore = data.has_more;
            afterId = data.last_id;

            console.log('[Anthropic] Fetched models:', modelIds, 'Has more:', hasMore);
            
            if (!hasMore || !afterId) break;
        }

        return models;
    } catch (error) {
        console.error('[Anthropic] Model fetch error:', error);
        throw error;
    }
}
===== src/settings/providers/openai.ts =====

import { requestUrl } from 'obsidian';

export async function fetchOpenAIModels(apiKey: string): Promise<string[]> {
	try {
		const url = 'https://api.openai.com/v1/models';
		const response = await requestUrl({
			url,
			method: 'GET',
			headers: { Authorization: `Bearer ${apiKey}` }
		});

		if (response.status >= 400) {
			throw new Error(`OpenAI error: ${response.status} ${response.text}`);
		}
		return response.json.data?.map((m: any) => m.id).sort() ?? [];
	} catch (err) {
		console.error('[OpenAI] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/stabilityai.ts =====

import { requestUrl } from 'obsidian';

interface StabilityAIEngine {
    id: string;
    name: string;
    description: string;
    type: string;
}

interface ModelInfo {
    id: string;
    languages: string[];
}

interface CategorizedModels {
    Media: ModelInfo[];
    Language: ModelInfo[];
    '3D': ModelInfo[];
    Audio: ModelInfo[];
}

// Fallback list of models with categories and languages, based on the provided table
const fallbackModels: CategorizedModels = {
    Media: [
        { id: 'stable-diffusion-3-5-medium', languages: ['English'] },
        { id: 'stable-diffusion-3-5-large', languages: ['English'] },
        { id: 'stable-diffusion-3-5-large-turbo', languages: ['English'] },
        { id: 'stable-diffusion-3-medium', languages: ['English'] },
        { id: 'stable-diffusion-xl-turbo', languages: ['English'] },
        { id: 'stable-diffusion-turbo', languages: ['English'] },
        { id: 'stable-video-diffusion-14-frame', languages: ['English'] },
        { id: 'stable-video-diffusion-25-frame', languages: ['English'] },
        { id: 'stable-video-diffusion-1-1', languages: ['English'] },
        { id: 'japanese-sdxl', languages: ['Japanese'] },
        { id: 'japanese-stable-clip', languages: ['Japanese'] },
        // Include V1 models seen in previous API response
        { id: 'stable-diffusion-v1-6', languages: ['English'] },
        { id: 'stable-diffusion-xl-1024-v1-0', languages: ['English'] }
    ],
    Language: [
        { id: 'stable-lm-2-12b', languages: ['English', 'Spanish', 'German', 'Italian', 'French', 'Portuguese', 'Dutch'] },
        { id: 'stable-lm-2-1-6b', languages: ['English', 'Spanish', 'German', 'Italian', 'French', 'Portuguese', 'Dutch'] },
        { id: 'stable-lm-zephyr-3b', languages: ['English'] },
        { id: 'japanese-stable-lm-2-1-6b', languages: ['Japanese'] },
        { id: 'japanese-stable-vlm', languages: ['Japanese'] },
        { id: 'stable-code-instruct-3b', languages: ['English', 'Code'] },
        { id: 'stable-code-3b', languages: ['English', 'Code'] }
    ],
    '3D': [
        { id: 'stable-point-aware-3d', languages: ['English'] },
        { id: 'stable-fast-3d', languages: ['English'] },
        { id: 'stable-zero123c', languages: ['English'] },
        { id: 'stable-video-3d', languages: ['English'] }
    ],
    Audio: [
        { id: 'stable-audio-open-1-0', languages: ['English'] }
    ]
};

// Function to map API engine types to plugin categories
function mapEngineTypeToCategory(engineType: string, engineId: string): keyof CategorizedModels {
    // Map based on engine type and ID patterns
    if (engineType === 'PICTURE' || engineType === 'VIDEO' || engineId.includes('video-diffusion') || engineId.includes('sdxl') || engineId.includes('stable-diffusion')) {
        return 'Media';
    } else if (engineType === 'AUDIO' || engineId.includes('audio')) {
        return 'Audio';
    } else if (engineType === '3D' || engineId.includes('3d')) {
        return '3D';
    } else if (engineType === 'TEXT' || engineId.includes('lm') || engineId.includes('code')) {
        return 'Language';
    }
    // Default to Media for unknown types, as most Stability AI models are image-related
    return 'Media';
}

// Helper to merge fetched models with fallback models, avoiding duplicates
function mergeModels(fetched: CategorizedModels, fallback: CategorizedModels): CategorizedModels {
    const result: CategorizedModels = { Media: [], Language: [], '3D': [], Audio: [] };
    const categories: (keyof CategorizedModels)[] = ['Media', 'Language', '3D', 'Audio'];

    for (const category of categories) {
        const fetchedIds = new Set(fetched[category].map(model => model.id));
        const merged = [...fetched[category]];

        // Add fallback models that weren't fetched
        for (const fallbackModel of fallback[category]) {
            if (!fetchedIds.has(fallbackModel.id)) {
                merged.push(fallbackModel);
            }
        }

        // Sort models by ID for consistency
        result[category] = merged.sort((a, b) => a.id.localeCompare(b.id));
    }

    return result;
}

export async function fetchStabilityAIModels(apiKey: string): Promise<string[]> {
    const categorizedModels: CategorizedModels = {
        Media: [],
        Language: [],
        '3D': [],
        Audio: []
    };
    let lastError: Error | null = null;

    // Try multiple API versions to fetch models
    const apiVersions = ['v1', 'v1beta'];
    for (const apiVersion of apiVersions) {
        const url = `https://api.stability.ai/${apiVersion}/engines/list`;
        console.log('[StabilityAI] Sending request:', {
            url,
            headers: {
                Authorization: '[REDACTED]',
                'Stability-Client-ID': 'obsidian-ai-plugin',
                'Stability-Client-Version': '1.0.0'
            }
        });

        try {
            const response = await requestUrl({
                url,
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${apiKey.trim()}`,
                    'Content-Type': 'application/json',
                    'Stability-Client-ID': 'obsidian-ai-plugin',
                    'Stability-Client-Version': '1.0.0'
                    // Uncomment and set the Organization header if needed
                    // 'Organization': 'org-123456'
                }
            });

            if (response.status >= 400) {
                let errorMessage = `Stability AI error (${apiVersion}): ${response.status}`;
                try {
                    const errorBody = response.json?.error?.message || response.text || 'No additional details';
                    console.log('[StabilityAI] Error response body:', errorBody);
                    errorMessage += ` - ${errorBody}`;
                    if (response.status === 401) {
                        errorMessage += '. Invalid API key.';
                    } else if (response.status === 500) {
                        errorMessage += '. Server error occurred.';
                    }
                } catch {
                    errorMessage += ' - Failed to parse error details';
                }
                throw new Error(errorMessage);
            }

            const data = response.json as StabilityAIEngine[];
            if (!Array.isArray(data)) {
                console.error('[StabilityAI] Unexpected response format:', data);
                throw new Error('Unexpected API response format');
            }

            // Categorize fetched models
            for (const engine of data) {
                const category = mapEngineTypeToCategory(engine.type, engine.id);
                // Assume English as the default language unless specified in fallback
                const modelInfo: ModelInfo = { id: engine.id, languages: ['English'] };
                // Update languages if the model is in the fallback list
                for (const cat of Object.keys(fallbackModels) as (keyof CategorizedModels)[]) {
                    const fallbackModel = fallbackModels[cat].find(m => m.id === engine.id);
                    if (fallbackModel) {
                        modelInfo.languages = fallbackModel.languages;
                        break;
                    }
                }
                categorizedModels[category].push(modelInfo);
            }

            console.log(`[StabilityAI] Fetched models from ${apiVersion}:`, categorizedModels);
        } catch (err) {
            console.error(`[StabilityAI] Error for API version ${apiVersion}:`, err);
            lastError = err;
            continue;
        }
    }

    // Merge with fallback models to ensure all models from the table are included
    const finalModels = mergeModels(categorizedModels, fallbackModels);

    // Log the final categorized models
    console.log('[StabilityAI] Final categorized model list:', finalModels);

    // For compatibility with the current plugin, return a flat list of all model IDs
    // The settings redesign can use the categorized structure directly
    const flatModelList = [
        ...finalModels.Media,
        ...finalModels.Language,
        ...finalModels['3D'],
        ...finalModels.Audio
    ].map(model => model.id).sort();

    if (flatModelList.length === 0) {
        throw lastError || new Error('Failed to fetch models with all API versions and no fallback available');
    }

    return flatModelList;
}

// Export the categorized models for use in the settings redesign
export function getCategorizedStabilityAIModels(): CategorizedModels {
    // This assumes fetchStabilityAIModels has been called and cached the results
    // For now, return the fallback models; in a real implementation, you'd cache the fetched results
    return fallbackModels;
}
===== src/settings/providers/groq.ts =====

import { requestUrl } from 'obsidian';

export async function fetchGroqModels(apiKey: string): Promise<string[]> {
	try {
		const url = 'https://api.groq.com/openai/v1/models';
		const response = await requestUrl({
			url,
			method: 'GET',
			headers: { Authorization: `Bearer ${apiKey}` }
		});

		if (response.status >= 400) {
			throw new Error(`Groq error: ${response.status} ${response.text}`);
		}
		return response.json.data?.map((m: any) => m.id).sort() ?? [];
	} catch (err) {
		console.error('[Groq] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/gemini.ts =====

import { requestUrl } from 'obsidian';

/**
 * Interface representing the structure of a single model object
 * returned by the Gemini API's models.list method.
 */
interface GeminiModel {
  name: string; // e.g., "models/gemini-1.5-flash-001"
  baseModelId?: string; // e.g., "gemini-1.5-flash"
  version?: string; // e.g., "001"
  displayName?: string; // e.g., "Gemini 1.5 Flash"
  description?: string;
  inputTokenLimit?: number;
  outputTokenLimit?: number;
  supportedGenerationMethods?: string[];
  temperature?: number;
  topP?: number;
  topK?: number;
}

/**
 * Interface representing the overall response structure
 * from the Gemini API's models.list method.
 */
interface GeminiListModelsResponse {
  models?: GeminiModel[];
  nextPageToken?: string; // For handling pagination if needed
}

/**
 * Fetches the list of available models from the Google Gemini API.
 *
 * @param apiKey - The API key for authenticating with the Google Generative Language API.
 * @returns A promise that resolves to an array of model names (e.g., "models/gemini-pro").
 * @throws An error if the API request fails or returns an error status.
 */
/**
 * Fetches available models from the Gemini API.
 * Ensures model names are correctly formatted for use in generateContent endpoint.
 */
export async function fetchGeminiModels(apiKey: string): Promise<string[]> {
	try {
	  // Try v1 first, then fallback to v1beta
	  const apiVersions = ['v1', 'v1beta'];
	  let lastError: Error | null = null;
  
	  for (const apiVersion of apiVersions) {
		const url = `https://generativelanguage.googleapis.com/${apiVersion}/models?key=${apiKey}`;
		console.log('[fetchGeminiModels] Fetching models with URL:', url);
  
		try {
		  const resp = await requestUrl({
			url,
			method: 'GET',
		  });
  
		  if (resp.status !== 200) {
			throw new Error(`Failed to fetch Gemini models: ${resp.status} - ${resp.text || 'No details'}`);
		  }
  
		  const data = resp.json as { models: { name: string }[] };
		  // Normalize model names by removing 'models/' prefix
		  const models = data.models
			.map(m => m.name.replace(/^models\//, ''))
			.filter(m => m.startsWith('gemini')); // Only include Gemini models
		  console.log('[fetchGeminiModels] Fetched models:', models);
		  return models;
		} catch (error) {
		  console.error('[fetchGeminiModels] Error for API version', apiVersion, ':', error);
		  lastError = error;
		  continue;
		}
	  }
  
	  throw lastError || new Error('Failed to fetch models with all API versions');
	} catch (error) {
	  console.error('[fetchGeminiModels] Error:', error);
	  return ['gemini-1.5-pro-latest', 'gemini-1.5-flash-latest']; // Fallback models
	}
  }
===== src/settings/providers/grok.ts =====

import { requestUrl } from 'obsidian';

interface XAIModel {
    id: string;
    created: number;
    object: string;
    owned_by: string;
}

interface XAIAPIResponse {
    data: XAIModel[];
}

export async function fetchGrokModels(apiKey: string): Promise<string[]> {
    try {
        const url = 'https://api.x.ai/v1/models';
        console.log('[Grok] Sending request:', {
            url,
            headers: { Authorization: `Bearer ${apiKey.trim()}` }
        });

        const response = await requestUrl({
            url,
            method: 'GET',
            headers: {
                Authorization: `Bearer ${apiKey.trim()}`,
                'Content-Type': 'application/json' // Added for compatibility
            }
        });

        if (response.status >= 400) {
            let errorMessage = `xAI error: ${response.status}`;
            try {
                const errorBody = response.json?.error?.message || response.text || 'No additional details';
                console.log('[Grok] Error response body:', errorBody);
                errorMessage += ` - ${errorBody}`;
                if (response.status === 403) {
                    errorMessage += '. Check your API key, permissions, or account status at console.x.ai.';
                }
            } catch {
                errorMessage += ' - Failed to parse error details';
            }
            throw new Error(errorMessage);
        }

        const models = (response.json as XAIAPIResponse).data?.map(m => m.id).sort() ?? [];
        console.log('[Grok] Fetched models:', models);
        return models;
    } catch (err) {
        console.error('[Grok] Model fetch error:', err);
        throw err;
    }
}
===== src/settings/providers/local.ts =====

import { requestUrl } from 'obsidian';

export async function fetchLocalModels(): Promise<string[]> {
	try {
		// Check if Ollama is running
		await requestUrl({ url: 'http://localhost:11434', method: 'GET' });
		const response = await requestUrl({ url: 'http://localhost:11434/api/tags', method: 'GET' });
		return response.json.models?.map((m: any) => m.name).sort() ?? [];
	} catch (err) {
		console.error('[Local] Model fetch error:', err);
		throw new Error("Unable to connect to Ollama at http://localhost:11434");
	}
}
===== src/settings/providers/openrouter.ts =====

import { requestUrl } from 'obsidian';

export async function fetchOpenRouterModels(apiKey: string): Promise<string[]> {
	try {
		const url = 'https://openrouter.ai/api/v1/models';
		const response = await requestUrl({
			url,
			method: 'GET',
			headers: { Authorization: `Bearer ${apiKey}` }
		});

		if (response.status >= 400) {
			throw new Error(`OpenRouter error: ${response.status} ${response.text}`);
		}
		return response.json.data?.map((m: any) => m.id).sort() ?? [];
	} catch (err) {
		console.error('[OpenRouter] Model fetch error:', err);
		throw err;
	}
}
===== src/settings/providers/index.ts =====

import { App } from 'obsidian';
import { fetchOpenAIModels } from './openai';
import { fetchLocalModels } from './local';
import { fetchAnthropicModels } from './anthropic';
import { fetchGroqModels } from './groq';
import { fetchGeminiModels } from './gemini';
import { fetchOpenRouterModels } from './openrouter';
import { fetchGrokModels } from './grok';
import { fetchStabilityAIModels } from './stabilityai'; // Added Stability AI fetcher

export interface ProviderMetadata {
    key: string;
    defaultModel: string;
    requiresApiKey: boolean;
}

export const providerMetadata: Record<string, ProviderMetadata> = {
    openai: { key: 'openai', defaultModel: 'gpt-3.5-turbo', requiresApiKey: true },
    local: { key: 'local', defaultModel: 'llama2', requiresApiKey: false }, // Ollama
    anthropic: { key: 'anthropic', defaultModel: 'claude-3-opus-20240229', requiresApiKey: true },
    groq: { key: 'groq', defaultModel: 'mixtral-8x7b-32768', requiresApiKey: true }, // GroqCloud
    gemini: { key: 'gemini', defaultModel: 'models/gemini-pro', requiresApiKey: true }, // Google Gemini
    openrouter: { key: 'openrouter', defaultModel: 'openrouter/google/gemma-7b-it', requiresApiKey: true },
    grok: { key: 'grok', defaultModel: 'grok-1', requiresApiKey: true }, // x.ai Grok
    stabilityai: { key: 'stabilityai', defaultModel: 'stable-diffusion-xl-v1', requiresApiKey: true } // Stability AI
};

// Updated FetchFunction type to accept optional apiKey and app
type FetchFunction = (apiKey: string, app?: App) => Promise<string[]>;

export const providerFetchers: Record<string, FetchFunction> = {
    openai: fetchOpenAIModels,
    local: fetchLocalModels,
    anthropic: fetchAnthropicModels,
    groq: fetchGroqModels,
    gemini: fetchGeminiModels,
    openrouter: fetchOpenRouterModels,
    grok: fetchGrokModels,
    stabilityai: fetchStabilityAIModels // Added Stability AI fetcher
};
===== src/ui/components/TabComponent.ts =====

import { App, setIcon } from 'obsidian';
import { consoleCSS } from '../console/styles/consoleStyles';

/**
 * Interface for a tab in the TabComponent.
 */
export interface Tab {
  id: string;
  name: string;
  render(container: HTMLElement): void;
  cleanup(): void;
}

/**
 * Configuration for a tab, including its icon.
 */
export interface TabConfig {
  tab: Tab;
  icon: string;
}

/**
 * Reusable TabComponent for managing and rendering tabs.
 */
export class TabComponent {
  private activeTabId: string;
  private container: HTMLElement | null = null;
  private tabContentContainer: HTMLElement | null = null;
  private styleElement: HTMLStyleElement | null = null;

  constructor(
    private app: App,
    private tabs: TabConfig[],
    initialTabId: string
  ) {
    this.activeTabId = tabs.some(t => t.tab.id === initialTabId) ? initialTabId : tabs[0]?.tab.id;
  }

  /**
   * Renders the tab selector and content area into the provided container.
   */
  render(container: HTMLElement): void {
    this.container = container;

    // Inject CSS styles
    this.styleElement = document.createElement('style');
    this.styleElement.textContent = consoleCSS;
    document.head.appendChild(this.styleElement);

    // Create tab selector
    const tabSelector = this.container.createEl('div', { cls: 'ai-console-tab-selector' });

    // Render tab buttons
    this.tabs.forEach(({ tab, icon }) => {
      const isActive = tab.id === this.activeTabId;
      const tabButton = tabSelector.createEl('button', {
        cls: `ai-console-tab-button${isActive ? ' active' : ''}`,
      });

      // Use the icon from TabConfig
      const iconEl = tabButton.createEl('span', { cls: 'ai-console-tab-icon' });
      setIcon(iconEl, icon);

      // Add label
      tabButton.createSpan({ cls: 'ai-console-tab-label', text: tab.name.split(' ')[0] });

      // Handle click
      tabButton.addEventListener('click', () => this.switchTab(tab.id));
    });

    // Create content container
    this.tabContentContainer = this.container.createEl('div', { cls: 'ai-console-tab-content' });

    // Render initial active tab
    this.renderActiveTab();
  }

  /**
Interp   * Switches to the specified tab and re-renders the content.
   */
  private switchTab(tabId: string): void {
    if (tabId === this.activeTabId) return;
    this.activeTabId = tabId;
    this.renderActiveTab();
  }

  /**
   * Renders the content of the active tab and updates button states.
   */
  private renderActiveTab(): void {
    if (!this.container || !this.tabContentContainer) return;

    // Update button states
    const buttons = this.container.querySelectorAll('.ai-console-tab-button');
    const activeTabName = this.tabs.find(t => t.tab.id === this.activeTabId)?.tab.name.split(' ')[0] || '';

    buttons.forEach(button => {
      const buttonLabel = button.querySelector('.ai-console-tab-label')?.textContent || '';
      const isActive = buttonLabel === activeTabName;
      button.classList.toggle('active', isActive);
    });

    // Clear and render active tab content
    this.tabContentContainer.empty();
    const activeTab = this.tabs.find(t => t.tab.id === this.activeTabId)?.tab;
    if (activeTab) {
      activeTab.render(this.tabContentContainer);
    }
  }

  /**
   * Cleans up the component, including styles and tab content.
   */
  cleanup(): void {
    this.tabs.forEach(({ tab }) => tab.cleanup());
    if (this.container) {
      this.container.empty();
    }
    if (this.styleElement && this.styleElement.parentNode) {
      this.styleElement.parentNode.removeChild(this.styleElement);
    }
    this.container = null;
    this.tabContentContainer = null;
    this.styleElement = null;
  }

  /**
   * Gets the ID of the currently active tab.
   */
  getActiveTabId(): string {
    return this.activeTabId;
  }
}
===== src/ui/console/AiConsoleModal.ts =====

import { App, Modal, Notice } from 'obsidian';
import type { MyPluginSettings } from '../../settings/settings';
import type { SecretsManager } from '../../utils/secrets';
import { TextConsoleTab } from './tabs/TextConsoleTab';
import { ImageConsoleTab } from './tabs/ImageConsoleTab';
import { VideoConsoleTab } from './tabs/VideoConsoleTab';
import { AudioConsoleTab } from './tabs/AudioConsoleTab';
import { OcrConsoleTab } from './tabs/OcrConsoleTab';
import { ThreeDConsoleTab } from './tabs/ThreeDConsoleTab';
import { TabComponent, TabConfig } from '../components/TabComponent';

interface PromptHistoryEntry {
  provider: string;
  model: string;
  prompt: string;
  output: string;
  timestamp: string;
}

interface ConsoleTab {
  id: string;
  name: string;
  icon: string;
  render(container: HTMLElement): void;
  cleanup(): void;
  renderHistory?(history: PromptHistoryEntry[]): void;
}

export class AiConsoleModal extends Modal {
  private settings: MyPluginSettings;
  private secrets: SecretsManager;
  private tabs: ConsoleTab[] = [];
  private tabComponent: TabComponent;
  private history: PromptHistoryEntry[] = [];
  private maxHistoryEntries = 10;

  constructor(app: App, settings: MyPluginSettings, secrets: SecretsManager) {
    super(app);
    this.settings = settings;
    this.secrets = secrets;
    this.initializeTabs();
    const tabConfigs: TabConfig[] = this.tabs.map(tab => ({
      tab,
      icon: tab.icon
    }));
    this.tabComponent = new TabComponent(this.app, tabConfigs, 'text');
  }

  private initializeTabs() {
    this.tabs = [
      new TextConsoleTab(this.app, this.settings, this.secrets, this.addToHistory.bind(this), this.renderHistory.bind(this)),
      new ImageConsoleTab(this.app, this.settings, this.secrets),
      new VideoConsoleTab(this.app, this.settings, this.secrets),
      new AudioConsoleTab(this.app, this.settings, this.secrets),
      new OcrConsoleTab(this.app, this.settings, this.secrets),
      new ThreeDConsoleTab(this.app, this.settings, this.secrets)
    ];
  }

  onOpen() {
    console.log('[AiConsoleModal] Opening modal...');
    this.titleEl.setText('AI Console Playground');
    this.contentEl.empty();
    const container = this.contentEl.createEl('div', { cls: 'ai-console-container' });
    this.tabComponent.render(container);
  }

  private addToHistory(entry: PromptHistoryEntry) {
    this.history.unshift(entry);
    if (this.history.length > this.maxHistoryEntries) {
      this.history.pop();
    }
    this.renderHistory();
  }

  public renderHistory() {
    const activeTab = this.tabs.find(tab => tab.id === this.tabComponent.getActiveTabId());
    if (activeTab && activeTab.renderHistory) {
      activeTab.renderHistory(this.history);
    }
  }

  onClose() {
    this.tabComponent.cleanup();
    console.log('[AiConsoleModal] Modal closed.');
  }
}
===== src/ui/console/tabs/ImageConsoleTab.ts =====

// src/ui/console/tabs/ImageConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/settings';
import type { SecretsManager } from '../../../utils/secrets';

export class ImageConsoleTab {
  id = 'image';
  name = 'Image Playground';
  icon = 'image';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'Image Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/ThreeDConsoleTab.ts =====

import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/settings';
import type { SecretsManager } from '../../../utils/secrets';

export class ThreeDConsoleTab {
  id = '3d';
  name = '3D Playground';
  icon = 'cube';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: '3D Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/VideoConsoleTab.ts =====

// src/ui/console/tabs/VideoConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/settings';
import type { SecretsManager } from '../../../utils/secrets';

export class VideoConsoleTab {
  id = 'video';
  name = 'Video Playground';
  icon = 'film';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'Video Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/TextConsoleTab.ts =====

// src/ui/console/tabs/TextConsoleTab.ts
import { App, Notice, Setting, SliderComponent, TextComponent } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/settings';
import type { SecretsManager } from '../../../utils/secrets';
import { TextGateway } from '../../../gateways/TextGateway';
import type { LLMRequest, LLMResponse } from '../../../core/Adapter';
import { ProviderSelector } from '../sections/ProviderSelector';
import { ParameterControls } from '../sections/ParameterControls';
import { PromptInput } from '../sections/PromptInput';
import { OutputViewer } from '../sections/OutputViewer';
import { PromptHistory } from '../sections/PromptHistory';

interface PromptHistoryEntry {
  provider: string;
  model: string;
  prompt: string;
  output: string;
  timestamp: string;
}

export class TextConsoleTab {
  id = 'text';
  name = 'Text Playground';
  icon = 'file-text';
  private textGateway?: TextGateway;
  private providerSelector: ProviderSelector;
  private parameterControls: ParameterControls;
  private promptInput: PromptInput;
  private outputViewer: OutputViewer;
  private promptHistory: PromptHistory;

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager,
    private addToHistory: (entry: PromptHistoryEntry) => void,
    renderHistory: () => void
  ) {
    this.providerSelector = new ProviderSelector(app, settings, secrets);
    this.parameterControls = new ParameterControls();
    this.promptInput = new PromptInput();
    this.outputViewer = new OutputViewer();
    this.promptHistory = new PromptHistory();
  }

  async render(container: HTMLElement) {
    console.log('[TextConsoleTab] Rendering...');
    try {
      this.textGateway = await TextGateway.create(this.secrets, this.settings);
      console.log('[TextConsoleTab] TextGateway initialized successfully.');
    } catch (error: any) {
      console.error('[TextConsoleTab] Failed to initialize TextGateway:', error);
      new Notice('Failed to initialize Text Console. Some features may be limited.');
      container.createEl('p', { text: 'Error initializing Text Console.' });
    }

    // Render sections
    this.providerSelector.render(container, this.textGateway);
    this.parameterControls.render(container);
    this.promptInput.render(container, this.runPrompt.bind(this));
    this.outputViewer.render(container);
    this.promptHistory.render(container, this.historyClickHandler.bind(this));
  }

  private async runPrompt() {
    console.log('[TextConsoleTab] Run button clicked.');
    const provider = this.providerSelector.getSelectedProvider();
    const model = this.providerSelector.getSelectedModel() || this.settings.providers[provider]?.model || '';
    const prompt = this.promptInput.getPrompt().trim();
    const temperature = this.parameterControls.getTemperature();
    const maxTokens = this.parameterControls.getMaxTokens();

    this.outputViewer.clear();

    if (!prompt) {
      new Notice('Please enter a prompt.');
      return;
    }
    if (!provider) {
      new Notice('Please select a provider.');
      return;
    }
    if (!this.textGateway) {
      new Notice('TextGateway not initialized. Cannot generate response.');
      this.outputViewer.setOutput('Error: TextGateway not initialized.');
      return;
    }

    const request: LLMRequest = { prompt, model, temperature, maxTokens };
    const adapter = (this.textGateway as any).adapters[provider];
    if (!adapter) {
      new Notice(`No adapter found for provider: ${provider}. Please check configuration.`);
      this.outputViewer.setOutput(`Error: No adapter for ${provider}.`);
      console.error('[TextConsoleTab] No adapter found for provider:', provider);
      return;
    }

    try {
      this.outputViewer.setOutput('Generating...');
      console.log('[TextConsoleTab] Testing provider:', provider, 'with request:', {
        prompt: prompt.length > 50 ? prompt.slice(0, 50) + '...' : prompt,
        model,
        temperature,
        maxTokens,
      });

      const result: LLMResponse = await adapter.generate(request);
      let output = '[No result returned]';
      let tokensUsed = 0;

      if (result && typeof result.output === 'string') {
        output = result.output.trim();
        tokensUsed = result.tokensUsed || 0;
      } else {
        console.warn('[TextConsoleTab] Unexpected response format from provider:', provider, result);
        output = '[Unexpected response format]';
      }

      this.outputViewer.setOutput(output);
      this.outputViewer.setCode(`await window.aiNNS.text.generate("${prompt.replace(/"/g, '\\"')}", { model: "${model}", temperature: ${temperature}, maxTokens: ${maxTokens} });`);
      this.addToHistory({ provider, model, prompt, output, timestamp: new Date().toLocaleString() });
      console.log('[TextConsoleTab] Response received for', provider, ':', {
        output: output.length > 50 ? output.slice(0, 50) + '...' : output,
        tokensUsed,
      });
    } catch (error: any) {
      console.error('[TextConsoleTab] Generation error for', provider, ':', error);
      let errorMessage = `Error: ${error.message || 'Unknown error'}`;
      this.outputViewer.setOutput(errorMessage);
      new Notice(`Failed to generate with ${provider}: ${error.message || 'Unknown error'}`);
    }
  }

  private historyClickHandler(entry: PromptHistoryEntry) {
    this.providerSelector.setProvider(entry.provider, entry.model);
    this.promptInput.setPrompt(entry.prompt);
  }

  cleanup() {
    this.providerSelector.cleanup();
    this.parameterControls.cleanup();
    this.promptInput.cleanup();
    this.outputViewer.cleanup();
    this.promptHistory.cleanup();
  }

  renderHistory(history: PromptHistoryEntry[]) {
    this.promptHistory.updateHistory(history, this.historyClickHandler.bind(this));
  }
}
===== src/ui/console/tabs/OcrConsoleTab.ts =====

// src/ui/console/tabs/OcrConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/settings';
import type { SecretsManager } from '../../../utils/secrets';

export class OcrConsoleTab {
  id = 'ocr';
  name = 'OCR Playground';
  icon = 'scan';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'OCR Console (Coming Soon)' });
  }

  cleanup() {}
}
===== src/ui/console/tabs/AudioConsoleTab.ts =====

// src/ui/console/tabs/AudioConsoleTab.ts
import { App } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/settings';
import type { SecretsManager } from '../../../utils/secrets';

export class AudioConsoleTab {
  id = 'audio';
  name = 'Audio Playground';
  icon = 'volume-2';

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  render(container: HTMLElement) {
    container.createEl('p', { text: 'Audio Console (Coming Soon)' });
  }

  cleanup() {}
}

===== src/ui/console/sections/ParameterControls.ts =====

// src/ui/console/sections/ParameterControls.ts
import { Setting, SliderComponent, TextComponent, Notice } from 'obsidian';

export class ParameterControls {
  private temperatureSlider?: SliderComponent;
  private maxTokensInput?: TextComponent;

  render(container: HTMLElement) {
    const paramsContainer = container.createEl('div', { cls: 'ai-console-params' });
    paramsContainer.createEl('h4', { text: 'Parameters' });

    try {
      new Setting(paramsContainer)
        .setName('Temperature')
        .setDesc('Controls randomness (0.0 to 1.0).')
        .addSlider(slider => {
          this.temperatureSlider = slider.setLimits(0, 1, 0.1).setValue(0.7).setDynamicTooltip();
        });
    } catch (error) {
      console.error('[ParameterControls] Error creating temperature slider:', error);
      paramsContainer.createEl('p', { text: 'Error loading temperature slider.' });
    }

    try {
      new Setting(paramsContainer)
        .setName('Max Tokens')
        .setDesc('Maximum number of tokens to generate.')
        .addText(text => {
          this.maxTokensInput = text
            .setPlaceholder('1000')
            .setValue('1000')
            .onChange(value => {
              if (isNaN(parseInt(value)) && value !== '') {
                new Notice('Max Tokens must be a number.');
                text.setValue('1000');
              }
            });
        });
    } catch (error) {
      console.error('[ParameterControls] Error creating max tokens input:', error);
      paramsContainer.createEl('p', { text: 'Error loading max tokens input.' });
    }
  }

  getTemperature(): number {
    try {
      return parseFloat(this.temperatureSlider!.getValue().toString()) || 0.7;
    } catch (error) {
      console.error('[ParameterControls] Error getting temperature:', error);
      return 0.7;
    }
  }

  getMaxTokens(): number {
    try {
      return parseInt(this.maxTokensInput!.getValue()) || 1000;
    } catch (error) {
      console.error('[ParameterControls] Error getting max tokens:', error);
      return 1000;
    }
  }

  cleanup() {
    // No cleanup needed for sliders and inputs
  }
}
===== src/ui/console/sections/ProviderSelector.ts =====

// src/ui/console/sections/ProviderSelector.ts
import { App, Setting, Notice } from 'obsidian';
import type { MyPluginSettings } from '../../../settings/settings';
import type { SecretsManager } from '../../../utils/secrets';
import { providerMetadata, providerFetchers } from '../../../settings/providers/index';
import type { TextGateway } from '../../../gateways/TextGateway';

export class ProviderSelector {
  private providerSelectEl: HTMLSelectElement;
  private modelSelectEl: HTMLSelectElement;
  private providers: string[] = [];

  constructor(
    private app: App,
    private settings: MyPluginSettings,
    private secrets: SecretsManager
  ) {}

  async render(container: HTMLElement, textGateway?: TextGateway) {
    const controlsSection = container.createEl('div', { cls: 'ai-console-controls' });
    controlsSection.createEl('h3', { text: 'Settings' });

    this.providers = [];

    try {
      for (const key of Object.keys(this.settings.providers)) {
        const meta = providerMetadata[key];
        if (meta.requiresApiKey) {
          const apiKey = await this.secrets.getSecret(key);
          if (apiKey) this.providers.push(key);
        } else {
          this.providers.push(key);
        }
      }
      console.log('[ProviderSelector] Providers loaded:', this.providers);
    } catch (error) {
      console.error('[ProviderSelector] Error gathering providers:', error);
      new Notice('Failed to load providers. Using fallback options.');
    }

    new Setting(controlsSection)
      .setName('Provider')
      .setDesc('Select the AI provider to use.')
      .addDropdown(dropdown => {
        this.providerSelectEl = dropdown.selectEl;
        if (this.providers.length === 0) {
          dropdown.addOption('', 'No providers available');
        } else {
          this.providers.forEach(p => dropdown.addOption(p, p));
          const initial = this.settings.defaultProvider && this.providers.includes(this.settings.defaultProvider)
            ? this.settings.defaultProvider
            : this.providers[0];
          dropdown.setValue(initial);
          dropdown.onChange(async value => {
            console.log('[ProviderSelector] Provider changed to:', value);
            await this.updateModelDropdown(value);
          });
        }
      });

      const modelSetting = new Setting(controlsSection)
      .setName('Model')
      .setDesc('Select the model for the selected provider.');
    
    modelSetting.controlEl.style.flexDirection = 'column';
    modelSetting.controlEl.style.alignItems = 'stretch';
    
    modelSetting.addDropdown(dropdown => {
      this.modelSelectEl = dropdown.selectEl;
      this.modelSelectEl.style.width = '100%'; // ⬅️ make dropdown full width
      dropdown.setDisabled(this.providers.length === 0);
    });

    if (this.providers.length > 0) {
      try {
        await this.updateModelDropdown(this.providerSelectEl.value);
      } catch (error) {
        console.error('[ProviderSelector] Error populating models:', error);
      }
    }
  }

  private async updateModelDropdown(provider: string) {
    console.log('[ProviderSelector] Updating model dropdown for provider:', provider);
    this.modelSelectEl.innerHTML = '';
    this.modelSelectEl.disabled = true;

    if (!provider || !this.settings.providers[provider]) {
      this.modelSelectEl.add(new Option('No models available', ''));
      return;
    }

    try {
      let models: string[] = [];
      if (providerMetadata[provider].requiresApiKey) {
        const apiKey = await this.secrets.getSecret(provider);
        if (apiKey) {
          models = await providerFetchers[provider](apiKey, this.app);
        }
      } else {
        models = await providerFetchers[provider]('', this.app);
      }

      if (!models.length) {
        this.modelSelectEl.add(new Option('No models available', ''));
        return;
      }

      models.forEach(m => this.modelSelectEl.add(new Option(m, m)));
      const current = this.settings.providers[provider].model;
      this.modelSelectEl.value = models.includes(current) ? current : models[0];
      this.modelSelectEl.disabled = false;
      console.log('[ProviderSelector] Models loaded:', models);
    } catch (error) {
      console.error('[ProviderSelector] Error fetching models:', error);
      this.modelSelectEl.add(new Option('Error fetching models', ''));
    }
  }

  getSelectedProvider(): string {
    return this.providerSelectEl.value;
  }

  getSelectedModel(): string {
    return this.modelSelectEl.value;
  }

  setProvider(provider: string, model: string) {
    if (this.providers.includes(provider)) {
      this.providerSelectEl.value = provider;
      this.updateModelDropdown(provider).then(() => {
        if (this.modelSelectEl.options.length > 0) {
          this.modelSelectEl.value = model;
        }
      });
    }
  }

  cleanup() {
    // No cleanup needed for dropdowns
  }
}
===== src/ui/console/sections/OutputViewer.ts =====

// src/ui/console/sections/OutputViewer.ts
export class OutputViewer {
    private outputArea: HTMLElement;
    private codeBlock: HTMLElement;
  
    render(container: HTMLElement) {
      const outputSection = container.createEl('div', { cls: 'ai-console-output-section' });
      outputSection.createEl('h4', { text: 'Output' });
      this.outputArea = outputSection.createEl('div', { cls: 'ai-console-output' });
      this.codeBlock = outputSection.createEl('pre', { cls: 'ai-console-code' });
    }
  
    setOutput(output: string) {
      this.outputArea.setText(output);
    }
  
    setCode(code: string) {
      this.codeBlock.setText(code);
    }
  
    clear() {
      this.outputArea.empty();
      this.codeBlock.empty();
    }
  
    cleanup() {
      // No cleanup needed for output elements
    }
  }
===== src/ui/console/sections/PromptHistory.ts =====

// src/ui/console/sections/PromptHistory.ts
interface PromptHistoryEntry {
    provider: string;
    model: string;
    prompt: string;
    output: string;
    timestamp: string;
  }
  
  export class PromptHistory {
    private historyContainer: HTMLElement;
    private historyList: HTMLElement;
    private isHistoryVisible: boolean = true;
  
    render(container: HTMLElement, onClick: (entry: PromptHistoryEntry) => void) {
      this.historyContainer = container.createEl('div', { cls: 'ai-console-history' });
      const historyHeader = this.historyContainer.createEl('h4', { text: 'Recent Prompts ▼' });
      this.historyList = this.historyContainer.createEl('ul', { cls: 'ai-console-history-list' });
  
      historyHeader.addEventListener('click', () => {
        this.isHistoryVisible = !this.isHistoryVisible;
        this.historyList.style.display = this.isHistoryVisible ? 'block' : 'none';
        historyHeader.textContent = `Recent Prompts ${this.isHistoryVisible ? '▼' : '▲'}`;
      });
    }
  
    updateHistory(history: PromptHistoryEntry[], onClick: (entry: PromptHistoryEntry) => void) {
      this.historyList.empty();
      history.forEach(entry => {
        const li = this.historyList.createEl('li');
        li.createEl('strong', { text: `[${entry.timestamp}] ${entry.provider} (${entry.model})` });
        li.createEl('br');
        li.createEl('span', { text: `Prompt: ${entry.prompt}${entry.prompt.length > 50 ? '...' : ''}` });
        li.addEventListener('click', () => onClick(entry));
      });
    }
  
    cleanup() {
      this.historyContainer.empty();
    }
  }
===== src/ui/console/sections/PromptInput.ts =====

// src/ui/console/sections/PromptInput.ts
import { Notice } from 'obsidian';

export class PromptInput {
  private promptInput: HTMLTextAreaElement;

  render(container: HTMLElement, onRun: () => void) {
    const promptSection = container.createEl('div', { cls: 'ai-console-prompt-section' });
    this.promptInput = promptSection.createEl('textarea', {
      attr: { placeholder: 'Enter your prompt here...' },
      cls: 'ai-console-prompt'
    }) as HTMLTextAreaElement;

    const runBtn = promptSection.createEl('button', { text: 'Run', cls: 'ai-console-run-btn' });
    runBtn.addEventListener('click', onRun);
  }

  getPrompt(): string {
    return this.promptInput.value;
  }

  setPrompt(prompt: string) {
    this.promptInput.value = prompt;
  }

  cleanup() {
    // No cleanup needed for textarea
  }
}

===== src/ui/console/styles/consoleStyles.ts =====

export const consoleCSS = `
.ai-console-container {
  padding: 20px;
  max-width: 900px;
  margin: auto;
  background: var(--background-primary);
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.ai-console-tab-selector {
  display: flex;
  gap: 0;
  margin-bottom: 0;
  background: #2F2F2F;
  padding: 0;
  border-bottom: 1px solid var(--background-modifier-border);
}

.ai-console-tab-button {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  border: none;
  border-right: 1px solid var(--background-modifier-border);
  background: #2F2F2F;
  color: var(--text-faint);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  flex: 1;
  text-align: center;
  justify-content: center;
  opacity: 0.4;
}

.ai-console-tab-button:last-child {
  border-right: none;
}

.ai-console-tab-button:hover:not(.active) {
  background: #3A3A3A;
  color: var(--text-muted);
  opacity: 0.6;
}

.ai-console-tab-button.active {
  background: var(--background-primary);
  color: var(--text-normal);
  border-top-left-radius: 6px;
  border-top-right-radius: 6px;
  border-bottom: none;
  position: relative;
  z-index: 1;
  opacity: 1;
}

.ai-console-tab-icon {
  width: 16px;
  height: 16px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.ai-console-tab-icon svg {
  fill: currentColor;
  stroke: currentColor;
  opacity: inherit;
}

.ai-console-tab-label {
  display: inline-block;
}

.ai-console-tab-content {
  padding: 16px;
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border);
  border-top: none;
  border-radius: 0 0 6px 6px;
}

.ai-console-controls {
  margin-bottom: 20px;
  padding: 15px;
  background: var(--background-secondary);
  border-radius: 6px;
  border: 1px solid var(--background-modifier-border);
}

.ai-console-controls h3 {
  margin: 0 0 15px 0;
  font-size: 18px;
  color: var(--text-normal);
}

.ai-console-params {
  margin-top: 15px;
  padding-top: 10px;
  border-top: 1px solid var(--background-modifier-border);
}

.ai-console-params h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--text-normal);
}

.ai-console-prompt-section {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  align-items: flex-end;
}

.ai-console-prompt {
  flex: 1;
  width: 100%;
  height: 120px;
  padding: 10px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 6px;
  background: var(--background-primary-alt);
  color: var(--text-normal);
  font-size: 14px;
  resize: vertical;
  transition: border-color 0.2s ease;
}

.ai-console-prompt:focus {
  border-color: var(--interactive-accent);
  outline: none;
}

.ai-console-run-btn {
  padding: 10px 20px;
  background: var(--interactive-accent);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  transition: background 0.2s ease;
}

.ai-console-run-btn:hover {
  background: var(--interactive-accent-hover);
}

.ai-console-output-section {
  margin-bottom: 20px;
}

.ai-console-output-section h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--text-normal);
}

.ai-console-output {
  padding: 15px;
  background: var(--background-secondary);
  border-radius: 6px;
  min-height: 120px;
  white-space: pre-wrap;
  border: 1px solid var(--background-modifier-border);
  font-size: 14px;
  color: var(--text-normal);
}

.ai-console-code {
  margin-top: 10px;
  padding: 15px;
  background: var(--code-block-background);
  border-radius: 6px;
  overflow-x: auto;
  font-size: 13px;
  color: var(--text-muted);
  border: 1px solid var(--background-modifier-border);
}

.ai-console-history {
  margin-top: 20px;
  padding: 15px;
  background: var(--background-secondary);
  border-radius: 6px;
  border: 1px solid var(--background-modifier-border);
}

.ai-console-history h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--text-normal);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
}

.ai-console-history-list {
  list-style: none;
  padding: 0;
  max-height: 200px;
  overflow-y: auto;
}

.ai-console-history-list li {
  padding: 10px;
  border-bottom: 1px solid var(--background-modifier-border);
  cursor: pointer;
  font-size: 14px;
  color: var(--text-normal);
  transition: background 0.2s ease;
}

.ai-console-history-list li:hover {
  background: var(--background-modifier-hover);
}

.ai-console-history-list li:last-child {
  border-bottom: none;
}

.ai-console-history-list strong {
  color: var(--text-accent);
}

.ai-console-history-list span {
  color: var(--text-muted);
}
`;
